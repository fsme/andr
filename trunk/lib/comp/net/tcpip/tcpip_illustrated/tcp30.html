<html>

<head>
<title>Другие приложения TCP/IP</title>

<meta http-equiv="Content-type" content="text/html; charset=koi8-r">
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>


<b>

<p><a NAME="t300000"></a>Глава 30 Другие приложения TCP/IP</p>
<u>

<p><a NAME="t301000"></a>Введение</p>
</u></b>

<p><small>В этой главе мы опишем приложения TCP/IP,
которые присутствуют почти во всех реализациях.
Некоторые из них просты и их можно описать
целиком (Finger и Whois), тогда как другие достаточно
сложны (X Window System). Сложные приложения мы
рассмотрим, не вдаваясь в подробности, фокусируя
свое внимание на то, как они используют протоколы
TCP/IP. </small></p>

<p><small>В дополнение, мы приведем обзор некоторых
средств <a NAME="t301001"></a>Internet, которые позволяют
определить ресурсы. Это средства, которые
помогают нам ориентироваться в Internet, искать
отдельные пункты, точное положение которых и
точные имена которых не известны.</small></p>
<u><b>

<p><a NAME="t302000"></a>Протокол Finger</p>
</b></u>

<p><small>Протокол Finger возвращает информацию об
одном или нескольких пользователях на указанном
хосте. Это приложение обычно используется, для
того чтобы посмотреть, находится ли конкретный
пользователь в настоящее время в системе, или
чтобы получить имя какого-либо пользователя,
чтобы послать ему почту. RFC 1288 [<a NAME="t302001"></a>Zimmerman
1991] описывает этот протокол. </small></p>

<p><small>Многие узлы не запускают Finger сервер по двум
причинам. Во-первых, ошибки в программировании в
ранних версиях сервера были одной из точек входа <a NAME="t302002"></a>&quot;червяка&quot; в Internet в 1988 году. (RFC 1135 [<a NAME="t302003"></a>Reynolds 1989] и [<a NAME="t302004"></a>Curry 1992] описывают
этого &quot;червяка&quot; более подробно.) Во-вторых,
протокол Finger может предоставить подробную
информацию о пользователях (login имя, телефонные
номера, время последнего логирования и так
далее), а эту информацию большинство
администраторов считают частной. Раздел 3 RFC 1288
детально описывает аспекты секретности,
соответствующие сервису Finger. </small></p>

<p><small>Сервер Finger использует заранее известный
порт 79. Клиент осуществляет активное открытие на
этот порт и отправляет запрос длиной в 1 строку.
Сервер обрабатывает запрос, посылает назад вывод
и закрывает соединение. Запрос и отклик в формате
<a NAME="t302005"></a>NVT ASCII, почти так же как мы видели в
случае FTP и SMTP. </small></p>

<p><small>Обычно большинство пользователей Unix
получают доступ к серверу Finger с использованием
клиента finger(1), однако мы воспользуемся Telnet
клиентом, подсоединимся непосредственно к
серверу и рассмотрим команды, которые выдаются
клиентом (команды длиной в 1 строку). Если запрос
клиента состоит из пустой строки (которая в NVT ASCII
передается как CR, за которой следует LF), это
воспринимается как запрос на информацию о всех
текущих пользователях.</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>telnet slip finger </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; первые
три строки - вывод Telnet клиента<br>
Trying 140.252.13.65 ...<br>
Connected to slip.<br>
Escape character is '^]'.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; здесь
вводим RETURN в качестве команды клиента Finger<br>
Login&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Name
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tty
&nbsp;&nbsp;&nbsp; Idle&nbsp;&nbsp;&nbsp; Login Time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Office
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Office Phone<br>
rstevens&nbsp;&nbsp;&nbsp; Richard Stevens&nbsp;&nbsp;&nbsp; *c0&nbsp;&nbsp;&nbsp; 45
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Jul 31 09:13<br>
rstevens&nbsp;&nbsp;&nbsp; Richard Stevens&nbsp;&nbsp;&nbsp; *c2&nbsp;&nbsp;&nbsp; 45
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Aug 5 09:41<br>
Connection closed by foreign host.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вывод Telnet
клиента<br>
</p>


<p>&nbsp;</p>

<p><small>Пустые поля с названием офиса и рабочего
телефона взяты из необязательных полей в файле
пользовательских паролей (которые в данном
случае отсутствуют). </small></p>

<p><small>Сервер на своей стороне осуществляет
активное закрытие, при этом сервер возвращает
переменное количество информации, а получение
клиентом метки конца файла оповещает клиента о
том, что вывод завершен. </small></p>

<p><small>Когда в запросе клиента содержится имя
пользователя, сервер выдает информацию только об
этом пользователе. Здесь приведен еще один
пример, вывод Telnet клиента удален:</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>telnet vangogh.cs.berkeley.edu finger<br>
rstevens </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; это
клиент, о котором мы хотим узнать<br>
Login: rstevens
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Name:
Richard Stevens<br>
Directory: /a/guest/rstevens
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shell:
/bin/csh<br>
Last login Thu Aug 5 09:55 (PDT) on ttyq2 from sun.tuc.noao.edu<br>
Mail forwarded to: rstevens@noao.edu<br>
No Plan.<br>
</p>


<p>&nbsp;</p>

<p><small>Когда Finger сервис отключен, клиент, в ответ
на активное открытие, получает от сервера RST, так
как никакой из процессов не осуществил пассивное
открытие на порт 79:</small></p>

<p>&nbsp;</p>


<p>sun % <b>finger @svr4<br>
</b>[svr4.tuc.noao.edu] connect: Connection refused&nbsp;</p>

<p>&nbsp;</p>

<p><small>Некоторые узлы предоставляют определенный
сервис на порт 79, однако они просто сообщают
информацию, не обращая внимание на клиентские
запросы:</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>finger @att.com</b><br>
[att.com]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; это
строка вывода от Finger клиента; все остальное от
сервера<br>
------------------------------------------------------------<br>
There are no user accounts on the AT&amp;T Internet gateway.<br>
To send email to an AT&amp;T employee, send email to their name<br>
separated by periods at att.com. If the employee has an email<br>
address registered in the employee database, they will receive<br>
email - otherwise, you'll receive a non-delivery notice.<br>
For example: John.Q.Public@att.com<sup>1</sup><br>
<br>
sun % <b>finger clinton@whitehouse.gov</b><br>
[whitehouse.gov]<br>
<br>
Finger service for arbitrary addresses on whitehouse.gov is not<br>
supported. If you wish to send electronic mail, valid addresses are<br>
&quot;PRESIDENT@WHITEHOUSE.GOV&quot;, and &quot;VICE-PRESIDENT@WHITEHOUSE.GOV&quot;<sup>2</sup>.<br>
</p>


<p><small>&nbsp;</small> 

<ol>
  <li>На Internet маршрутизаторе фирмы
    AT&amp;T нет пользовательских бюджетов. Чтобы
    послать электронную почту работникам AT&amp;T,
    отправьте ее на имя работника, отделенного
    точкой от имени att.com. Если работник имеет адрес
    электронной почты - он ее получит, иначе Вы
    получите сообщение о недоставке почты. Например,
    John.Q.Public@att.com.</li>
  <li>Сервис Finger не поддерживается для адреса whitehouse.gov.
    Если Вам необходимо послать электронную почту,
    самые подходящие адреса это &quot;PRESIDENT@WHITEHOUSE.GOV&quot;
    и &quot;VICE-PRESIDENT@WHITEHOUSE.GOV&quot;.</li>
</ol>


<p>&nbsp;</p>

<p><small>Существует возможность организовать
брандмауэр (<a NAME="t302006"></a>firewall gateway). Маршрутизатор
между организацией и Internet, который фильтрует
конкретные IP датаграммы. (<a NAME="t302007"></a>[Cheswick and
Bellovin 1994] описывает брандмауэры более подробно.)
Брандмауэр может быть сконфигурирован таким
образом, чтобы отбрасывать входящие датаграммы,
которые содержат TCP сегменты на порт 79. В этом
случае Finger клиент прекратит работу по тайм-ауту
примерно через 75 секунд. </small></p>

<p><small>У Finger сервера и Unix клиента finger существуют
набор опций. Обратитесь к RFC 1288 и к страницам
помощи по finger(1) за более подробной информацией.</small></p>

<p>&nbsp;</p>


<p>RFC 1288 заявляет, что
машины с TCP/IP соединениями, которые предоставляют
сервер Finger, должны отвечать на запрос клиента
содержащий пустую строку, списком всех пунктов,
доступных в настоящий момент. Они должны
отвечать на запрос клиента содержащий имя,
счетчиком или списком доступных пунктов для
этого продукта.</p>


<p><small><a NAME="t303000"></a>&nbsp;</small></p>
<u><b>

<p>Протокол Whois</p>
</b></u>

<p><small>Протокол Whois это еще один информационный
сервис. Несмотря на то, что любой узел может
предоставить Whois сервис, наиболее широко
используется <a NAME="t303001"></a>InterNIC, <a NAME="t303002"></a>rs.internic.net.
Этот сервер содержит информацию о всех
зарегистрированных DNS доменах и о большинстве
системных администраторов, которые ответственны
за системы, подключенные к Internet. (Еще один
подобный сервер <a NAME="t303003"></a>nic.ddn.mil содержит
информацию о сети <a NAME="t303004"></a>MILNET.) К сожалению,
не всегда предоставляется полная информация. RFC
954 <a NAME="t303005"></a>[Harrenstein, Stahl, and Feinler 1985]
документирует сервис Whois. </small></p>

<p><small>С точки зрения протокола, сервер Whois
работает с заранее известным портом TCP 43. Он
принимает от клиента запрос на соединение, после
чего клиент отправляет на сервер запрос длиной в
1 строку. Сервер выдает информацию и закрывает
соединение. Запросы и отклики передаются в
формате NVT <a NAME="t303006"></a>ASCII. Он практически
идентичен серверу Finger, за исключением того, что
запросы и отклики содержат разную информацию. </small></p>

<p><small>Широко используемый Unix клиент - программа <a NAME="t303007"></a>whois(1) , однако можно использовать Telnet и
ввести команды самостоятельно. Сначала
отправляется запрос, содержащий знак вопроса, на
что возвращается более подробная информация о
поддерживаемых запросах клиента.</small></p>

<p>&nbsp;</p>


<p>Когда NIC было
переименовано в InterNIC в 1993 году, узел для сервера
Whois переместился с nic.ddn.mil на rs.internic.net. Многие
производители все еще поставляют версии клиента
whois с именем nic.ddn.mil, встроенном вовнутрь. Вам
может потребоваться указать аргумент командной
строки <a NAME="t303008"></a>-h rs.internic.net, чтобы
подсоединиться к нужному серверу.</p>

<p>Другой способ - использовать Telnet,
чтобы подсоединиться к rs.internic.net с именем whois.</p>


<p>&nbsp;</p>

<p><small>Воспользуемся Whois сервером, чтобы получить
информацию об авторе. (Весь вывод Telnet клиента
удален.) Первый запрос - поиск всех имен,
совпадающих с шаблоном &quot;stevens.&quot;</small></p>

<p>&nbsp;</p>


<p>sun % <b>telnet rs.internic.net whois<br>
stevens </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; это
командная строка, которую мы ввели клиенту<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; информация
о 25 других &quot;стивенсах&quot;, которую мы
игнорировали<br>
Stevens, W. Richard (WRS28) stevens@kohala.com
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +1 602 297 9416<br>
<br>
The InterNIC Registration Services Host ONLY contains Internet<br>
Information (Networks, ASN's, Domains, and POC's).<br>
Please use the whois server at nic.ddn.mil for MILNET Information.<br>
</p>


<p>&nbsp;</p>

<p><small>Три заглавные буквы, которые стоят перед
цифрами в скобках после имени, (WRS28), это
персональный описатель NIC. Следующий запрос
содержит восклицательный знак и описатель NIC, что
позволяет получить более подробную информацию
об этом человеке.</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>telnet rs.internic.net whois<br>
!wrs28 </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; запрос
клиента<br>
Stevens, W. Richard (WRS28)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stevens@kohala.com<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Kohala Software<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1202 E. Paseo del Zorro<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tuscon, AZ 85718<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +1 602 297 9416<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Record last updated on 11-Jan-91.<br>
</p>


<p>&nbsp;</p>

<p><small>Также можно получить дополнительную
информацию о переменных Internet. Например, запрос net
140.252 возвращает информацию о сети класса B 140.252.</small></p>
<i><b>

<p><a NAME="t303009"></a>Белые страницы</p>
</b></i>

<p><small>С использованием команды VRFY в SMTP, вместе с
протоколом Finger и протоколом Whois можно определить
положение пользователей в <a NAME="t303010"></a>Internet. Это
напоминает использование белых страниц в
телефонной книге, когда необходимо найти
чей-нибудь телефонный номер. В настоящее время
существуют широко доступные средства, однако
проводятся исследования, призванные улучшить
этот тип сервиса. </small></p>

<p><small><a NAME="t303011"></a>[Schwartz and Tsirigotis 1991] приводит
дополнительную информацию о различных сервисах
белых страниц, которые появляются в Internet. Один из
них <a NAME="t303012"></a>Netfind; к нему можно получить доступ
по Telnet на хосте bruno.cs.colorado.edu или ds.internic.net (имя
пользователя netfind). </small></p>

<p><small>RFC 1309 <a NAME="t303013"></a>[Weider, Reynolds, and Heker 1992]
предоставляет краткое описание службы
директорий <a NAME="t303014"></a>OSI, которая называется <a NAME="t303015"></a>X.500, где приводится сравнение отличие с
текущими технологиями Internet (Finger и Whois).</small></p>
<u><b>

<p><a NAME="t304000"></a>Archie, WAIS, Gopher, Veronica и WWW</p>
</b></u>

<p><small>Средства, которые мы описали в двух
предыдущих разделах, - Finger, Whois и сервис белых
страниц предоставляют информацию о
местонахождении персон. Существуют другие
средства, которые позволяют находить файлы и
документы. В следующем разделе дается краткое
описание этих средств. Мы приводим только
краткое описание, потому что рассмотрение в
деталях каждого из них может занять целую книгу.
Новые программы разрабатываются постоянно. <a NAME="t304001"></a>[Obraczka, Danzig, and Li 1993] описывает сервисы
поиска ресурсов в Internet.</small></p>
<i><b>

<p><a NAME="t304002"></a>Archie</p>
</b></i>

<p><small>Многое из того, что показано этой книге,
было получено с использованием анонимного FTP.
Проблема заключается в том, чтобы найти FTP узел,
на котором находится необходимая программа.
Иногда мы даже не знаем точное имя файла, однако
знаем какое-либо ключевое слово, которое может
появиться в имени файла. </small></p>

<p><small>Archie предоставляет информацию о тысячах FTP
серверов на бескрайних просторах Internet. Мы можем
получить доступ к этой информации, зайдя на
сервер Archie и осуществив поиск файла, имя которого
содержит указанное регулярное выражение. В ответ
появится список серверов, для которых было
найдено совпадение с именами файлов. Затем мы
используем анонимный FTP, чтобы получить файл. </small></p>

<p><small>Существует много Archie серверов по всему
миру. Стартовая точка - Telnet заход на ds.internic.net, под
именем archie и исполнение команды servers. При этом
будет возвращен список всех Archie серверов и их
положений.</small></p>
<i><b>

<p><a NAME="t304003"></a>WAIS: информационные сервисы
глобальных сетей</p>
</b></i>

<p><small>Archie помогает найти положение имен файлов,
содержащих ключевые слова, однако иногда
приходится искать файл или базу данных, ключевое
слово в которой содержится внутри. Таким образом,
осуществляется поиск файла, содержащего
ключевое слово, а не имени файла, содержащего
ключевое слово. </small></p>

<p><small>WAIS знает о сотнях баз данных, которые
содержат информацию по темам, связанным с
компьютерами, и другим общим темам. Чтобы
использовать WAIS, мы выбираем базы данных для
поиска и указываем ключевые слова. Чтобы
попробовать WAIS, попробуйте подсоединиться Telnetом
к quake.think.com с именем пользователя wais.</small></p>
<i><b>

<p><a NAME="t304004"></a>Gopher</p>
</b></i>

<p><small>Gopher это меню-ориентированное приложение
для работы с разнообразными сервисами Internet,
таких как <a NAME="t304005"></a>Archie, WAIS и анонимный FTP. Gopher
это одно из наиболее легко используемых средств,
так как его пользовательский интерфейс не
зависит от того, какой сервис используется. </small></p>

<p><small>Чтобы воспользоваться Gopher, подсоединитесь
Telnetом к <a NAME="t304006"></a>is.internic.net с именем
пользователя gopher.</small></p>
<i><b>

<p><a NAME="t304007"></a>Veronica: Very Easy Rodent-Oriented Netwide Index to Computerized
Archives</p>
</b></i>

<p><small>Тогда как Archie это индекс анонимных FTP
серверов, Veronica это индекс заголовков пунктов Gopher.
Veronica обычно осуществляет поиск по сотням Gopher
серверов. </small></p>

<p><small>Чтобы получить доступ к Veronica, необходимо
воспользоваться клиентом Gopher. Выберите пункт
меню в Gopher &quot;Beyond InterNIC: Virtual Treasures of the Internet&quot;, а
затем выберите Veronica из следующего меню.</small></p>
<i><b>

<p><a NAME="t304008"></a>WWW: World Wide Web</p>
</b></i>

<p><small>World Wide Web позволяет нам просмотреть в
мировом масштабе большой набор сервисов и
документов с использованием средства, которое
называется <a NAME="t304009"></a>гипертекст (hypertext). По мере
того как информация отображается, определенные
ключевые слова подсвечиваются, и мы можем
получить более подробную информацию с
использованием этих ключевых слов. </small></p>

<p><small>Чтобы получить доступ к WWW, подсоединитесь
Telnetом к info.cern.ch.</small></p>
<u><b>

<p><a NAME="t305000"></a>X Window System</p>
</b></u>

<p><small><a NAME="t305001"></a>X Window System, или просто X, это
приложение клиент-сервер, которое позволяет
нескольким клиентам (приложениям) использовать
графический дисплей, управляемый сервером.
Сервер это программное обеспечение, которое
управляет дисплеем, клавиатурой и мышкой. Клиент
это программа приложения, которая запущена либо
на том же самом хосте, что и сервер, либо на другом
хосте. В последнем случае обычная форма связи
между клиентом и сервером это TCP, однако могут
быть использованы и другие протоколы, такие как
DECNET. В некоторых случаях сервер это часть
аппаратного обеспечения (X терминал), которая
общается с клиентом на другом хосте. В другом
случае отдельно стоящая рабочая станция, клиент
и сервер находятся на одном и том же хосте и
общаются с помощью коммуникаций между
процессами на этом хосте, без использования
сетевого обеспечения. Однако наиболее
стандартная ситуация, когда клиенты запущены на
том же хосте, что сервер, или когда клиенты
запущены на других хостах. </small></p>

<p><small>X требует надежный, двунаправленный
потоковый протокол, такой как TCP. (X не разработана
для работы с ненадежными протоколами, такими как
UDP.) Общение между клиентом и сервером
осуществляется посредством обмена 8-битовыми
байтами по этому соединению. [<a NAME="t305002"></a>Nye 1992]
приводит формат более чем 150 сообщений, которыми
обмениваются клиент и сервер по TCP соединению. </small></p>

<p><small>В Unix системах, когда X клиент и X сервер
находятся на одном и том же хосте, вместо TCP
обычно используются протоколы <a NAME="t305003"></a>Unix
domain, потому что в этом случае осуществляется
меньше обработки протоколов, нежели при
использовании с TCP. <a NAME="t305004"></a>Протоколы Unix domain
это форма общения между процессами, которая
может быть использована между клиентами и
серверами на одном и том же хосте. Обратитесь к <a HREF="tcp02.html#t027001">рисунку 2.4</a>, на котором видно, что
когда TCP используется для общения между двумя
процессами на одном и том же хосте, эти данные
передаются по петле ниже IP уровня, при этом
осуществляется обработка данных и TCP, и UDP. На
рисунке 30.1 показан возможный вариант общения
трех клиентов, использующих один дисплей. Один
клиент на том же самом хосте, что и сервер,
использует Unix domain протоколы. Остальные два
клиента находятся на других хостах и используют
TCP. Один клиент это обычно <a NAME="t305005"></a>оконный
менеджер (window manager), который имеет право
располагать окна на дисплее. Оконный менеджер
позволяет нам передвигать окна по экрану или,
например, менять их размер. </small></p>

<p><small>На первый взгляд термины клиент и сервер не
совсем уместны в данном случае. С такими
приложениями как Telnet и FTP мы считаем, что клиент
это интерактивный пользователь, который сидит за
клавиатурой и дисплеем. Однако в случае X
клавиатура и дисплей принадлежат самому серверу.
Поэтому в данном случае сервер это то, что
предоставляет сервис. Сервис, предоставляемый X,
это доступ к окну, клавиатуре и мышке. В случае
Telnet сервис это терминальный заход на удаленный
хост. В случае FTP сервис это файловая система
сервера. </small></p>

<p><small>X сервер обычно стартует, когда X терминал
или рабочая станция загружаются. Сервер создает
конечную точку TCP и осуществляет пассивное
открытие на порт 6000 + n, где n это номер дисплея
(обычно 0).<a NAME="t305006"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t30_1000.jpg" WIDTH="520" HEIGHT="209"></small></p>


<p ALIGN="CENTER"><small>Рисунок 30.1 Три X клиента,
использующие один дисплей.</small></p>

<p>&nbsp;</p>

<p><small>Большинство Unix серверов также создают <a NAME="t305007"></a>Unix domain сокет с именем /tmp/.X11-unix/Xn, где n
это тот же номер дисплея. </small></p>

<p><small>Когда клиент стартует на другом хосте, он
создает TCP конечную точку и осуществляет
активное открытие на порт 6000 + n сервера. Каждый
клиент имеет свое собственное TCP соединение с
сервером. Уже от сервера будет зависеть, как он
поделит ресурсы между всеми клиентами. Клиент
отправляет по TCP соединению запросы на сервер
(создает окно), сервер посылает обратно отклики, а
также сервер посылает события клиенту (нажатие
кнопки мыши, нажатие клавиш на клавиатуре,
перемещение окна, изменение размера окна и так
далее). </small></p>

<p><small>На рисунке 30.2 повторен рисунок 30.1, где
показаны фазы общения клиента с процессом X
сервера, которые, в свою очередь, обслуживают
окна на дисплее. Здесь не показано, как X сервер
обслуживает клавиатуру и мышь.<a NAME="t305008"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t30_2000.jpg" WIDTH="520" HEIGHT="247"></small></p>


<p ALIGN="CENTER"><small>Рисунок 30.2 Три клиента,
использующие один дисплей.</small></p>

<p>&nbsp;</p>

<p><small>Подобная форма, когда один сервер
обрабатывает несколько клиентов, отличается от
обычного TCP <a NAME="t305009"></a>конкурентного сервера,
который мы описали в разделе <a HREF="tcp18.html#t18B000">&quot;Реализация
TCP сервера&quot;</a> главы 18. FTP и Telnet серверы,
например, запускают новый процесс каждый раз,
когда приходит запрос на новое TCP соединение,
поэтому каждый клиент общается со своим
процессом сервера. В случае X, все клиенты,
запущенные на этом же хосте или на другом хосте,
общаются с одним сервером. </small></p>

<p><small>По TCP соединению между X клиентом и его
сервером осуществляется обмен большим
количеством данных. Количество данных зависит от
конкретной реализации приложения. Например, если
мы запустим клиента Xclock, который отображает
текущее время и дату в окне клиента на сервере и
укажем ему обновляться один раз в секунду, X
сообщения посылаются по TCP соединению от клиента
к серверу один раз в секунду. Если мы запустим
эмулятор X терминала, Xterm, каждое нажатие клавиши
будет генерировать 32-байтное X сообщение (72 байта
вместе со стандартными IP и TCP заголовками), и еще
больше X сообщений в обратном направлении с
символами, отраженными эхом. <a NAME="t305010"></a>[Droms and
Dyksen 1990] рассчитывает TCP траффик между различными X
клиентами и одним конкретным сервером.</small></p>
<i><b>

<p><a NAME="t305011"></a>Программа Xscope</p>
</b></i>

<p><small>Удобная программа, с помощью которой можно
определить, чем обмениваются X клиент и его
сервер, это Xscope. Она поставляется с большинством
реализаций X Window. Программа находится между
клиентом и сервером, пропуская все данные в обоих
направлениях, при этом отлавливая все запросы
клиента и отклики сервера. На рисунке 30.3
показано, как это происходит.<a NAME="t305012"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t30_3000.jpg" WIDTH="520" HEIGHT="282"></small></p>


<p ALIGN="CENTER"><small>Рисунок 30.3 Использование xscope для
мониторинга X соединения.</small></p>

<p>&nbsp;</p>

<p><small>Во-первых, мы стартовали процесс xscope на том
же самом хосте, где находится сервер, при этом xscope
слушает запросы на TCP соединение приходящие на
порт 6001, а не 6000. Затем мы стартовали клиента на
другом хосте и указали дисплей номер 1, а не 0,
таким образом, клиент подключается к xscope, а не
непосредственно к серверу. Когда запрос на
соединение прибывает от клиента, xscope создает TCP
соединение на реальный порт сервера 6000 и
копирует все между клиентом и сервером, а также
предоставляет читаемое описание запросов и
откликов. Мы запустим xscope на хосте sun, а клиента <a NAME="t305013"></a>xclock на хосте svr4. </small></p>

<p>&nbsp;</p>


<p>svr4 % <a NAME="t305014"></a><b>DISPLAY=sun:1
xclock -digital -update 5</p>
</b>

<p>&nbsp;</p>

<p><small>При этом отображаются время и дата в
цифровом формате</small></p>

<p>&nbsp;</p>


<p>Thu Sep 9 10:32:55 1993</p>


<p>&nbsp;</p>

<p><small>в окне на хосте sun. Мы указали обновлять
время один раз каждые 5 секунд. </small></p>

<p><small>Также указана опция -q команды xscope, чтобы
получать минимальный вывод. Доступны различные
уровни отладки, что позволяет просмотреть все
поля в каждом сообщении. Следующий вывод
показывает первые три запроса и отклика.</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>xscope -q</b><br>
0.00: Client --&gt; 12 bytes<br>
0.02:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 152
bytes &lt;-- X11 Server<br>
0.03: Client --&gt; 48 bytes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ............REQUEST: CreateGC<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ............REQUEST: GetProperty<br>
0.20:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 396
bytes &lt;-- X11 Server<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ..............REPLY:
GetProperty<br>
0.30: Client --&gt; 8 bytes<br>
0.38: Client --&gt; 20 bytes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ............REQUEST: InternAtom<br>
0.43:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32
bytes &lt;-- X11 Server<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ..............REPLY:
InternAtom<br>
</p>


<p>&nbsp;</p>

<p><small>Первое сообщение от клиента в момент
времени 0,00 и отклик сервера в момент времени 0,02
это стандартное установление соединения между
клиентом и сервером. Клиент указывает <a NAME="t305015"></a>порядок
следования байтов и версию сервера, которую он
ожидает. Сервер сообщает о себе различную
информацию. </small></p>

<p><small>Следующее сообщение в момент времени 0,03
содержит два запроса от клиента. Первый запрос
создает на сервере графическое окружение, в
котором клиент будет рисовать. Второй получает
свойства от сервера (характеристика RESOURCE_MANAGER).
Свойства обеспечивают общение между клиентами,
обычно между приложением и оконным менеджером.
Отклик от сервера размером 396 байт в момент
времени 0,20 содержит это свойство. </small></p>

<p><small>Следующие два сообщения от клиента в
моменты времени 0,30 и 0,38 имеют форму одного
запроса, который требует вернуть атом. (Каждое
свойство имеет уникальный целый идентификатор,
который называется атом.) В момент времени 0.43
сервер отправляет отклик, содержащий атом. </small></p>

<p><small>Рассматривать этот пример дальше
невозможно без подробного описания того, как
работает система X window system, что не является целью
нашего повествования. В этом примере мы видим,
что перед тем как на дисплее появилось окно,
клиент отправил 12 сегментов, содержащих 1668 байт,
а сервер отправил 10 сегментов, содержащих 1120
байт. Весь процесс занял 3,17 секунды. С этого
момента, каждые 5 секунд, клиент посылает
маленький запрос в среднем по 44 байта, которые
обновляют окно. Это продолжается до тех пор, пока
клиент не будет выключен.</small></p>
<i><b>

<p><a NAME="t305016"></a>LBX: X с низкой шириной полосы</p>
</b></i>

<p><small>Кодирование, используемое протоколом X,
оптимально для работы в локальных сетях, где
время, которое тратится на кодирование и
декодирование данных, более важно, нежели
минимизация количества передаваемых данных. При
работе с Ethernet все нормально, однако в случае
медленных последовательных каналов, таких как <a NAME="t305017"></a>SLIP и <a NAME="t305018"></a>PPP (глава 2, разделы <a HREF="tcp02.html#t024000">&quot;SLIP: IP по последовательной
линии&quot;</a> и <a HREF="tcp02.html#t026000">&quot;PPP: протокол
точка-точка&quot;</a>) возникают проблемы. </small></p>

<p><small>Поэтому был разработан стандарт Low Bandwidth X
(LBX), который использует следующую технику для
уменьшения сетевого траффика: кэширование,
отправку изменений от предыдущих пакетов и
сжатие. Спецификации появились в 1993 году с
реализацией X window system Release 6.</small></p>
<u><b>

<p><a NAME="t306000"></a>Краткие выводы</p>
</b></u>

<p><small>Первые два приложения, которые мы
рассмотрели, Finger и Whois, предназначены для
получения информации о пользователях. Клиент Finger
запрашивает сервер, чаще всего для того, чтобы
найти какое-либо имя (например, чтобы отправить
пользователю почту) или для того чтобы
посмотреть, зашел ли кто-либо в систему
терминалом в настоящий момент. Клиент Whois обычно
общается с сервером, запущенным от <a NAME="t306001"></a>InterNIC,
в поисках информации о человеке, организации,
домене или номере сети. </small></p>

<p><small>Другие сервисы, позволяющие более
эффективно работать с ресурсами Internet, это <a NAME="t306002"></a>Archie, WAIS, <a NAME="t306003"></a>Gopher, Veronica и WWW. Они
помогают найти в Internet файлы и документы. В
настоящее время разрабатываются и другие
средства определения ресурсов. </small></p>

<p><small>Эта глава закончена кратким рассмотрением
системы X Window System, еще одного очень
&quot;серьезного&quot; приложения, работающего с TCP/IP.
Мы видели, что X сервер обслуживает несколько
окон на дисплее и обеспечивает общение клиента с
его окном. С помощью программы Xscope мы видели, как
существует возможность поместить еще одну
программу между клиентом и сервером, чтобы
получить информацию о том, с помощью каких
сообщений осуществляется обмен.</small></p>
<i><b>

<p>Упражнения</b></i> 

<ol>
  <li>Используйте Whois, чтобы найти
    владельца сети класса A с идентификатором сети 88.</li>
  <li>Используйте Whois, чтобы найти DNS сервер в домене
    whitehouse.gov. Совпадет ли отклик с ответом, который
    можно получить от системы DNS?</li>
  <li>Как Вы думаете, должен ли быть процесс xscope,
    показанный на рисунке 30.3, запущен на том же самом
    хосте, что и X сервер?</li>
</ol>


<hr>

</body>
</html>

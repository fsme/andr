<html>

<head>
<title>TCP таймер &quot;оставайся в живых&quot;</title>

<meta http-equiv="Content-type" content="text/html; charset=koi8-r">
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>




<p><a NAME="t230000"></a>Глава 23 TCP таймер &quot;оставайся в
живых&quot;</p>
<u>

<p><b><a NAME="t231000"></a>Введение</p>
</b></u>

<p><small>Большинство новичков в TCP/IP, как правило,
бывают очень удивлены, когда узнают, что по
свободному TCP соединению не передаются данные. А
это именно так, то есть если ни один из процессов
на концах TCP соединения не посылает данные
другому процессу, обмена между двумя TCP модулями
не осуществляется. Например, не осуществляется
опросов, как это происходит в других сетевых
протоколах. Другими словами, мы можем запустить
процесс клиента, который установит TCP соединение
с сервером, а затем уйти на несколько часов, дней,
недель или месяцев, а соединение будет держаться.
Промежуточные маршрутизаторы могут выходить из
строя и перезагружаться, телефонные линии могут
обрыватьься и восстанавливаться, однако если
хосты на концах соединения не будут
перезагружены, соединение будет оставаться
установленным. </small></p>

<p><small>При этом подразумевается, что ни одно из
приложений - клиент или сервер - не имеет таймеров
на прикладном уровне, которые позволяют
определить отсутствие активности по соединению,
и прекратить работу приложения. Обратитесь к
концу раздела <a HREF="tcp10.html#t107000">&quot;BGP: протокол
граничных маршрутизаторов&quot;</a> главы 10, где
показано, что BGP посылает пробы приложениям на
удаленном конце каждые 30 секунд. Это прикладной
таймер, который действует независимо от TCP
таймера &quot;оставайся в живых&quot;. </small></p>

<p><small>Однако существуют моменты, когда сервер
хочет узнать, что случилось с хостом клиента: или
он вышел из строя и был выключен, или вышел из
строя и перезагрузился. <a NAME="t231001"></a>Таймер
&quot;оставайся в живых&quot; (keepalive timer) это
характеристика большинства реализаций, которая
предоставляет эту возможность.</small></p>

<p>&nbsp;</p>


<p>Таймеры &quot;оставайся в
живых&quot; не являются частью TCP спецификации.
Требования к хостам <a NAME="t231002"></a>Host Requirements RFC
приводят три причины, по которым их не следует
использовать: (1) они могут привести к тому, что
абсолютно нормальное соединение будет разорвано
из-за непродолжительного сбоя, (2) они занимают
определенную ширину полосы, и (3) они стоят денег,
так как обмен пакетами между сетями имеет
определенную цену. Тем не менее, большинство
реализаций имеют таймер &quot;оставайся в живых&quot;.</p>


<p>&nbsp;</p>

<p><small>Необходимость иметь таймер &quot;оставайся в
живых&quot; все еще обсуждается. Многие считают, что
подобный опрос удаленного конца не свойственен
TCP и должен по необходимости осуществляться
приложением. От подобных заявлений отдает
религией, в основном из-за того, что они
декларируются очень эмоционально и с большим
жаром. </small></p>

<p><small>Опция &quot;оставайся в живых&quot; может
вызвать разрыв устойчивого соединения между
двумя процессами из-за временной потери
соединения между двумя конечными системами.
Например, если проба &quot;оставайся в живых&quot;
отправлена в тот момент, когда промежуточный
маршрутизатор вышел из строя и перезагружается,
TCP подумает, что вышел из строя хост клиента, что,
естественно, не так. </small></p>

<p><small>Характеристика &quot;оставайся в живых&quot;
предназначена для того, чтобы приложение сервера
могло оценить поведение клиентов и имело
возможность определить, что клиент вышел из
строя. Большинство версий Telnet и Rlogin серверов по
умолчанию включают опцию &quot;оставайся в
живых&quot;. </small></p>

<p><small>Можно привести пример, однозначно
доказывающий необходимость характеристики
&quot;оставайся в живых&quot;. Пользователи
персональных компьютеров часто заходят
терминалами на хост с помощью Telnet. В конце
рабочего дня они просто выключают питание
компьютера, не закрыв соединения. При этом
остается полуоткрытое соединение. На <a HREF="tcp18.html#t187001">рисунке 18.16</a> мы показали, что
отправка данных по полуоткрытому соединению
приводит к возврату сброса (reset), однако это
происходит в том случае когда данные
отправляются клиентом. Если клиент исчез,
оставив полуоткрытое соединение на конце
сервера, а сервер ожидает каких-либо данных от
клиента, он будет ждать вечно. Характеристика
&quot;оставайся в живых&quot; предназначена для того,
чтобы помочь серверу определить наличие
полуоткрытых соединений.</small></p>
<u><b>

<p><a NAME="t232000"></a>Описание</p>
</b></u>

<p><small>В этом описании мы будем называть конец, на
котором включается опция &quot;оставайся в
живых&quot;, сервером, а другой конец - клиентом.
Ничто не запрещает клиенту установить эту опцию,
однако она устанавливается именно на сервере.
Опция может быть установлена на обоих концах
соединения, если каждому концу необходимо знать,
работает ли удаленный конец. (В <a HREF="tcp29.html">главе
29</a> мы увидим, что когда NFS использует TCP, оба, и
клиент, и сервер, устанавливают эту опцию. А в <a HREF="tcp26.html">главе 26</a>, когда мы будем рассматривать
Rlogin и Telnet, мы увидим, что эту опцию устанавливает
только сервер, но не клиент.) </small></p>

<p><small>Если в заданном соединении не
осуществляются какие-либо действия в течение 2
часов, сервер отправляет клиенту пробный
сегмент. (Мы увидим, что представляет из себя
пробный сегмент, в примере, который приведен
ниже.) Хост клиента должен находиться в одном из
четырех состояний.</small> 

<ol>
  <li><small>Хост клиента включен и доступен для сервера.
    TCP клиент откликается нормально, и сервер знает,
    что удаленный конец все еще включен. TCP сервер
    перезапустит таймер &quot;оставайся в живых&quot; еще
    на 2 часа. Если до истечения следующих 2 часов по
    соединению будет осуществлен какой-либо обмен,
    таймер снова сбросится и установится в 2 часа.</small></li>
  <li><small>Хост клиента вышел из строя и либо выключен,
    либо перезагружается. В обоих случаях его TCP не
    отвечает. Сервер не получит отклик на свою пробу
    и отработает тайм-аут равный 75 секундам. Всего
    сервер отправляет 10 таких проб, с интервалом в 75
    секунд, и если он так и не получил отклика, сервер
    считает, что хост клиента выключен, и разрывает
    соединение.</small></li>
  <li><small>Хост клиента вышел из строя и
    перезагрузился. В этом случае сервер получит
    отклик на свою пробу &quot;оставайся в живых&quot;,
    однако отклик будет игнорирован и сервер
    разорвет соединение.</small></li>
  <li><small>Хост клиента запущен и работает, однако
    недоступен для сервера. Для TCP это то же самое, что
    и пункт 2. В обоих случаях можно сказать, что на
    пробы не получен отклик.</small></li>
</ol>

<p><small>Сервер не должен беспокоиться о том, что
хост клиента был выключен и затем перезагружен.
(Имеется ввиду shutdown, а не выход хоста из строя.)
Когда система выключена оператором, все процессы
клиента корректно завершают свою работу, при
этом TCP клиент отправляет FIN для соединения. При
получении FIN, TCP сервер выдает метку конца файла
процессу сервера, что позволяет серверу
корректно закрыть соединение. </small></p>

<p><small>В первом сценарии приложение сервера не
подозревает о том, что были отправлены пробы
&quot;оставайся в живых&quot;. Все это делается на TCP
уровне. Для приложения абсолютно безразлично,
имели ли место сценарии 2, 3 или 4. Во всех трех
случаях приложению сервера возвращается ошибка
от его собственного TCP. (Обычно сервер
осуществляет чтение из сети, ожидая данные от
клиента. Если характеристика &quot;оставайся в
живых&quot; возвратила ошибку, она передается
серверу как код возврата на операцию чтения.) В
случае второго сценария ошибка выглядит
примерно следующим образом: &quot;соединение
закрыто по тайм-ауту&quot; (connection timed out), а в случае
третьего сценария мы можем ожидать
&quot;соединение сброшено удаленным концом&quot;
(connection reset by peer). Четвертый сценарий может
выглядеть как, если соединение разорвано по
тайм-ауту, однако может быть возвращена и другая
ошибка, в зависимости от того, какая принята ICMP
ошибка по этому соединению. Мы рассмотрим все
четыре сценария в следующих разделах.</small></p>

<p>&nbsp;</p>


<p>Вечный вопрос, который
задают люди, изучающие опцию &quot;оставайся в
живых&quot;, заключается в том, может ли быть
изменено значение 2-часового тайм-аута. Обычно
требуется значительно меньше времени, где-то
несколько минут. Как мы показали в <a HREF="tcp_e.html">приложении
Е</a>, это значение обычно может быть изменено,
однако во всех системах, описанных в этом
приложении, интервал &quot;оставайся в живых&quot;
является системным значением, поэтому его
изменение окажет влияние на всех пользователей.</p>

<p>&nbsp;</p>

<p>Требования к хостам <a NAME="t232001"></a>Host
Requirements RFC говорят, что реализации могут иметь
характеристику &quot;оставайся в живых&quot;, однако
она не должна включаться, за исключением тех
случаев, когда приложение специально требует
это. Более того, интервал &quot;оставайся в живых&quot;
должен быть конфигурируемым, однако по умолчанию
он должен быть не меньше чем 2 часа.</p>


<p><small><a NAME="t233000"></a>&nbsp;</small></p>
<u><b>

<p>Примеры &quot;оставайся в живых&quot;</p>
</b></u>

<p><small>Сейчас мы просмотрим сценарии 2, 3 и 4 из
предыдущего раздела, чтобы рассмотреть обмен
пакетами при использовании опции &quot;оставайся в
живых&quot;.</small></p>
<i><b>

<p>Удаленный конец вышел из строя</p>
</b></i>

<p><small>Давайте посмотрим, что произойдет, когда
хост сервера вышел из строя и не перезагрузился.
Чтобы имитировать эту ситуацию, мы поступим
следующим образом:</small> 

<ul>
  <li><small>Установим соединение между клиентом
    (программа <a NAME="t233001"></a>sock на хосте bsdi) и
    стандартным эхо сервером на хосте svr4. Клиент
    включает опцию &quot;оставайся в живых&quot; с помощью
    опции <a NAME="t233002"></a>-K. </small></li>
  <li><small>Убедимся, что данные могут проходить по
    соединению. </small></li>
  <li><small>Посмотрим, что TCP модуль клиента отправляет
    пакеты &quot;оставайся в живых&quot; каждые 2 часа, и
    увидим, что они подтверждаются TCP модулем
    сервера. </small></li>
  <li><small>Отсоединим Ethernet кабель от сервера и оставим
    его отсоединенным до тех пор, пока пример не
    будет завершен. Это заставит клиента думать, что
    хост сервера вышел из строя. </small></li>
  <li><small>Мы ожидаем, что клиент отправит 10 проб
    &quot;оставайся в живых&quot; с интервалом в 75 секунд,
    перед тем как решит, что соединение умерло.</small></li>
</ul>

<p><small>Здесь приводится интерактивный вывод
клиента:</small></p>

<p>&nbsp;</p>


<p><br>
bsdi % <b>sock -K svr4 echo </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; опция -K
для включения &quot;оставайся в живых&quot;<br>
<b>hello, world </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; убедимся,
что соединение работает<br>
hello, world
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; отражение
эхом<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; отсоединяем
Ethernet кабель после 4 часов<br>
read error: Connection timed out&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; это произошло
примерно через 6 часов 10 минут после начала
эксперимента<br>
</p>


<p>&nbsp;</p>

<p><small>На рисунке 23.1 показан вывод tcpdump. (Мы удалили
все посвященное установлению соединения и
объявлению окна.)<a NAME="t233003"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1055
&gt; svr4.echo: P 1:14(13)ack 1<br>
2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.006105 (&nbsp;&nbsp; 0.0061)&nbsp;&nbsp; svr4.echo &gt;
bsdi.1055: P 1:14(13)ack14<br>
3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.093140 (&nbsp;&nbsp; 0.0870)&nbsp;&nbsp; bsdi.1055 &gt;
svr4.echo: . ack 14<br>
<br>
4&nbsp;&nbsp; 7199.972793 (7199.8797)&nbsp;&nbsp; arp who-has svr4 tell bsdi<br>
5&nbsp;&nbsp; 7199.974878 (&nbsp;&nbsp; 0.0021)&nbsp;&nbsp; arp reply svr4 is-at
0:0:c0:c2:9b:26<br>
6&nbsp;&nbsp; 7199.975741 (&nbsp;&nbsp; 0.0009)&nbsp;&nbsp; bsdi.1055 &gt; svr4.echo: .
ack 14<br>
7&nbsp;&nbsp; 7199.979843 (&nbsp;&nbsp; 0.0041)&nbsp;&nbsp; svr4.echo &gt; bsdi.1055: .
ack 14<br>
<br>
8&nbsp; 14400.134330 (7200.1545)&nbsp;&nbsp; arp who-has svr4 tell bsdi<br>
9&nbsp; 14400.136452 (&nbsp;&nbsp; 0.0021)&nbsp;&nbsp; arp reply svr4 is-at
0:0:c0:c2:9b:26<br>
10&nbsp; 14400.137391 (&nbsp;&nbsp; 0.0009)&nbsp;&nbsp; bsdi.1055 &gt; svr4.echo: . ack 14<br>
11&nbsp; 14400.141408 (&nbsp;&nbsp; 0.0040)&nbsp;&nbsp; svr4.echo &gt; bsdi.1055: . ack 14<br>
<br>
12&nbsp; 21600.318309 (7200.1769)&nbsp;&nbsp; arp who-has svr4 tell bsdi<br>
13&nbsp; 21675.320373 (&nbsp; 75.0021)&nbsp;&nbsp; arp who-has svr4 tell bsdi<br>
14&nbsp; 21750.322407 (&nbsp; 75.0020)&nbsp;&nbsp; arp who-has svr4 tell bsdi<br>
15&nbsp; 21825.324460 (&nbsp; 75.0021)&nbsp;&nbsp; arp who-has svr4 tell bsdi<br>
16&nbsp; 21900.436749 (&nbsp; 75.1123)&nbsp;&nbsp; arp who-has svr4 tell bsdi<br>
17&nbsp; 21975.438787 (&nbsp; 75.0020)&nbsp;&nbsp; arp who-has svr4 tell bsdi<br>
18&nbsp; 22050.440842 (&nbsp; 75.0021)&nbsp;&nbsp; arp who-has svr4 tell bsdi<br>
19&nbsp; 22125.432883 (&nbsp; 74.9920)&nbsp;&nbsp; arp who-has svr4 tell bsdi<br>
20&nbsp; 22200.434697 (&nbsp; 75.0018)&nbsp;&nbsp; arp who-has svr4 tell bsdi<br>
21&nbsp; 22275.436788 (&nbsp; 75.0021)&nbsp;&nbsp; arp who-has svr4 tell bsdi<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 23.1 Пакеты &quot;оставайся в живых&quot;,
которые определяют, что хост вышел из строя.</small></p>

<p>&nbsp;</p>

<p><small>В строках 1, 2 и 3 отправляется строка &quot;hello,
world&quot; от клиента к серверу и обратно. Первая
проба &quot;оставайся в живых&quot; появляется через 2
часа (7200 секунд) в строке 4. Первое на что
необходимо обратить внимание - это ARP запрос и ARP
отклик перед отправкой TCP сегмента в строке 6. На
пробу &quot;оставайся в живых&quot; в строке 6 приходит
отклик с удаленного конца (строка 7). Тот же обмен
пакетами происходит через 2 часа в строках 8-11. </small></p>

<p><small>Если бы мы могли видеть все поля в пробах
&quot;оставайся в живых&quot; (строки 6 и 10), то
обязательно обратили бы внимание на то, что поле
номера последовательности на единицу меньше чем
следующий отправляемый номер
последовательности, который должен быть
отправлен (в данном примере 13, тогда как должен
быть 14). Так как в сегменте нет данных, <a NAME="t233004"></a>tcpdump
не печатает поле номера последовательности.
(Программа tcpdump печатает номер
последовательности для пустых сегментов, только
в том случае если они содержат флаги SYN, FIN или RST.)
Именно прием этих неверных номеров
последовательности заставляет TCP модуль сервера
отвечать подтверждениями на пробы &quot;оставайся
в живых&quot;. В отклике клиенту сообщается
следующий номер последовательности, которую
ожидает сервер (14).</small></p>

<p>&nbsp;</p>


<p>Некоторые более старые
реализации, основанные на <a NAME="t233005"></a>4.2BSD, не
отвечают откликом на пробы &quot;оставайся в
живых&quot;, если сегмент не содержит данных.
Некоторые системы могут быть сконфигурированы
так, чтобы посылать в пробе один байт данных,
чтобы получить на него отклик. Этот байт не
принесет никакого вреда, потому что это не
ожидаемый байт (байт, который получатель уже
ранее получил и подтвердил), поэтому он
отбрасывается получателем. Другие системы
посылают сначала сегмент в стиле <a NAME="t233006"></a>4.3BSD
(без данных) в качестве пробы, и если отклик не
получен, переключаются на сегменты в стиле 4.2BSD.</p>


<p>&nbsp;</p>

<p><small>Затем мы отсоединили кабель и ожидаем, что
на следующую пробу (а именно через 2 часа) отклик
не будет получен. Когда появляется следующая
проба, мы никогда не увидим TCP сегменты в кабеле,
потому что хост не отвечает на ARP запросы. Все же
мы видим, что клиент отправляет 10 проб, с
промежутком в 75 секунд, перед тем как прекратить
попытки. Из нашего интерактивного скрипта мы
видим, что код ошибки, возвращенный процессу
клиента от TCP модуля, транслируется в сообщение
&quot;Connection timed out&quot; (соединение закрыто по
тайм-ауту).</small></p>
<i><b>

<p>Удаленный конец вышел из строя и
перезагрузился</p>
</b></i>

<p><small>В этом примере мы увидим, что произойдет,
если сервер выйдет из строя и перезагрузится.
Первоначальный сценарий такой же как и раньше,
однако после того, как мы убедились, что
соединение функционирует, мы отсоединили сервер
от Ethernet, перезагрузили его и затем вновь
подсоединили его к Ethernet. Мы ожидаем, что
следующая проба &quot;оставайся в живых&quot;
сгенерирует сброс (reset) от сервера, потому что
сервер сейчас ничего не знает об этом соединении.
Ниже приводится интерактивная сессия:</small></p>

<p>&nbsp;</p>


<p><br>
bsdi % <b>sock -K svr4 echo </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; опция
-K для включения &quot;оставайся в живых&quot;<br>
<b>hi there </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; проверяем,
что соединение функционирует<br>
hi there
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; это
отражается эхом с удаленного конца<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; здесь
сервер перезагружен, пока отсоединен кабель Ethernet<br>
read error: Connection reset by peer<br>
</p>


<p>&nbsp;</p>

<p><small>На рисунке 23.2 показан вывод команды tcpdump. (Мы
удалили все связанное с установлением
соединения и объявлением окна.)<a NAME="t233007"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp;&nbsp;&nbsp;&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1057
&gt; svr4.echo: P 1:10(9) ack 1<br>
2&nbsp;&nbsp;&nbsp;&nbsp; 0.006406 (&nbsp;&nbsp; 0.0064)&nbsp;&nbsp;&nbsp;&nbsp; svr4.echo
&gt; bsdi.1057: P 1:10(9) ack 10<br>
3&nbsp;&nbsp;&nbsp;&nbsp; 0.176922 (&nbsp;&nbsp; 0.1705)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1057
&gt; svr4.echo: . ack 10<br>
<br>
4&nbsp; 7200.067151 (7199.8902)&nbsp;&nbsp;&nbsp;&nbsp; arp who-has svr4 tell bsdi<br>
5&nbsp; 7200.069751 (&nbsp;&nbsp; 0.0026)&nbsp;&nbsp;&nbsp;&nbsp; arp reply svr4 is-at
0:0:c0:c2:9b:26<br>
6&nbsp; 7200.070468 (&nbsp;&nbsp; 0.0007)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1057 &gt;
svr4.echo: . ack 10<br>
7&nbsp; 7200.075050 (&nbsp;&nbsp; 0.0046)&nbsp;&nbsp;&nbsp;&nbsp; svr4.echo &gt;
bsdi.1057: R 1135563275:1135563275(0)<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 23.2 Пример &quot;оставайся в живых&quot;,
когда удаленный хост вышел из строя и
перезагрузился.</small></p>

<p>&nbsp;</p>

<p><small>Мы установили соединение и послали 9 байт
данных от клиента к серверу (строки&nbsp;1-3). Два
часа спустя клиент отправил первую пробу
&quot;оставайся в живых&quot;, отклик от сервера
содержит сброс. Приложение клиента печатает
сообщение об ошибке &quot;Connection reset by peer&quot;
(соединение сброшено удаленным концом).</small></p>
<i><b>

<p>Удаленный конец недоступен</p>
</b></i>

<p><small>В этом примере сервер не выходит из строя,
однако он недоступен в течение 10-минутного
периода, когда отправляются пробы &quot;оставайся в
живых&quot;. Вполне возможно, что вышел из строя
промежуточный маршрутизатор, телефонная линия
может быть временно повреждена или произошло
что-нибудь подобное. </small></p>

<p><small>Чтобы имитировать эту ситуацию, мы
установили TCP соединение с нашего хоста slip через
SLIP канал с дозвоном на хост vangogh.cs.berkeley.edu, а затем
погасили канал. Во-первых, приведем вывод
интерактивной сессии:</small></p>

<p>&nbsp;</p>


<p><br>
slip % <b>sock -K vangogh.cs.berkeley.edu echo<br>
testing </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим
эту строку<br>
testing
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; строка
отражена эхом<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; где-то
в это время погашен SLIP канал<br>
read error: No route to host<br>
</p>


<p>&nbsp;</p>

<p><small>На рисунке 23.3 показан вывод команды tcpdump,
который получен с маршрутизатора bsdi.
(Установление соединения и объявления окна
удалены.)<a NAME="t233008"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slip.1056
&gt; vangogh.echo: P 1:9(8)ack1<br>
2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.277669 (&nbsp;&nbsp; 0.2777)
&nbsp;&nbsp;&nbsp; vangogh.echo &gt; slip.1056: P 1:9(8)ack9<br>
3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.424423 (&nbsp;&nbsp; 0.1468)&nbsp;&nbsp;&nbsp; slip.1056
&gt; vangogh.echo: . ack 9<br>
<br>
4&nbsp;&nbsp; 7200.818081 (7200.3937)&nbsp;&nbsp;&nbsp; slip.1056 &gt; vangogh.echo: . ack
9<br>
5&nbsp;&nbsp; 7201.243046 (&nbsp;&nbsp; 0.4250)&nbsp;&nbsp;&nbsp; vangogh.echo &gt;
slip.1056: . ack 9<br>
<br>
6&nbsp; 14400.688106 (7199.4451)&nbsp;&nbsp;&nbsp; slip.1056 &gt; vangogh.echo: . ack 9<br>
7&nbsp; 14400.689261 (&nbsp;&nbsp; 0.0012)&nbsp;&nbsp;&nbsp; sun &gt; slip: icmp: net
vangogh unreachable<br>
8&nbsp; 14475.684360 (&nbsp; 74.9951)&nbsp;&nbsp;&nbsp; slip.1056 &gt; vangogh.echo: . ack
9<br>
9&nbsp; 14475.685504 (&nbsp;&nbsp; 0.0011)&nbsp;&nbsp;&nbsp; sun &gt; slip: icmp: net
vangogh unreachable<br>
<br>
14 строк удалено<br>
<br>
24&nbsp; 15075.759603 (&nbsp; 75.1008)&nbsp;&nbsp;&nbsp; slip.1056 &gt; vangogh.echo: R
9:9(0)ack9<br>
25&nbsp; 15075.760761 (&nbsp;&nbsp; 0.0012)&nbsp;&nbsp;&nbsp; sun &gt; slip: icmp: net
vangogh unreachable<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 23.3 Пример &quot;оставайся в живых&quot;,
когда удаленный конец недоступен.</small></p>

<p>&nbsp;</p>

<p><small>Мы начинаем этот пример так же, как и
предыдущий: в строках 1-3 убеждаемся, что
соединение функционирует. На первую пробу
&quot;оставайся в живых&quot;, отправляемую через 2
часа, успешно получен отклик (строки 4 и 5), однако
перед тем, как будет отправлена следующая, еще
через 2 часа, мы выключили SLIP соединение между
маршрутизаторами sun и netb. (Обратитесь к топологии,
приведенной на внутренней стороне обложки.) </small></p>

<p><small>На пробу &quot;оставайся в живых&quot; в строке 6
генерируется <a NAME="t233009"></a>ICMP ошибка о
недоступности сети от маршрутизатора sun. Как мы
описали в разделе <a HREF="tcp21.html#t21A000">&quot;ICMP
ошибки&quot;</a> главы 21, это всего лишь &quot;мягкая&quot;
ошибка для принимающего TCP на хосте slip. Он
фиксирует, что была принята ICMP ошибка, однако
получение ошибки не разрывает соединение.
Отправляются еще 9 проб &quot;оставайся в живых&quot;,
с интервалом в 75 секунд, перед тем, как хост
прекращает свои попытки. Ошибка, возвращаемая
приложению, генерирует другое сообщение: &quot;No route
to host&quot; (нет маршрута к хосту). На <a HREF="tcp06.html#t066001">рисунке
6.12</a> мы видели, что это соответствует ICMP ошибке о
недоступности сети.</small></p>
<u><b>

<p><a NAME="t234000"></a>Краткие выводы</p>
</b></u>

<p><small>Как мы говорили ранее, характеристика
&quot;оставайся в живых&quot; довольно спорная.
Эксперты, работающие с протоколами, продолжают
дебаты по поводу того, принадлежит ли она
транспортному уровню или должна должна быть
реализована непосредственно в приложении. </small></p>

<p><small>Она функционирует посредством отправки
пробных пакетов по соединению, после того как
соединение не использовалось в течение 2 часов.
Могут возникнуть четыре различных сценария:
удаленный конец функционирует и откликается,
удаленный конец вышел из строя, удаленный конец
вышел из строя и перезагрузился и удаленный
конец в настоящее время недоступен. В нашем
примере мы рассмотрели все эти сценарии и видели
различные ошибки, возвращаемые для последних
трех условий. </small></p>

<p><small>В двух первых примерах только эта
характеристика позволила клиенту определить,
что другой конец вышел из строя или вышел из
строя и перезагрузился. В последнем примере,
однако, с удаленным концом ничего не произошло,
но соединение между ними было временно
разорвано. Мы должны всегда помнить эти
ограничения, когда используем опцию
&quot;оставайся в живых&quot;.</small></p>
<i><b>

<p>Упражнения</b></i> 

<ol>
  <li>Приведите список достоинств
    характеристики &quot;оставайся в живых&quot;.</li>
  <li>Приведите список недостатков характеристики
    &quot;оставайся в живых&quot;.</li>
</ol>

<hr>

</body>
</html>

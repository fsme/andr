<html>

<head>
<title>SNMP: протокол управления сетью</title>

<meta http-equiv="Content-type" content="text/html; charset=koi8-r">
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>


<b>

<p><a NAME="t250000"></a>Глава 25 SNMP: протокол управления
сетью</p>
<u>

<p><a NAME="t251000"></a>Введение</p>
</u></b>

<p><small>Так как количество сетей растет, сети
разнообразным образом объединяются
(маршрутизаторы различных поставщиков, хосты со
встроенными функциями маршрутизации,
терминальные серверы и так далее), задача
управления этими системами становится очень
важной. В этой главе рассматриваются стандарты,
которые используются внутри семейства
протоколов Internet, для управления сетью. </small></p>

<p><small>Управление сетью в объединенных сетях TCP/IP
строится на взаимодействии между <a NAME="t251001"></a>станцией
управления сетью (менеджер) и <a NAME="t251002"></a>элементами
сети. Элементами сети могут быть любые объекты,
которые используют семейство протоколов TCP/IP:
хосты, маршрутизаторы, X терминалы, терминальные
сервера, принтеры и так далее. На элементах сети
должно быть запущено программное обеспечение,
которое называется <a NAME="t251003"></a>агентом. Станции
управления это обычно рабочие станции с цветным
монитором и графическим дисплеем, которые
отображают то, что происходит с элементами
(которые из них работают, а которые нет, объем
траффика по различным каналам за единицу времени
и так далее). </small></p>

<p><small>Обмен данными, как правило, двусторонний:
менеджер просит агента сообщить ему
определенное значение (например, &quot;сколько было
сгенерировано ICMP ошибок о недоступности
порта?&quot;), или агент сообщает менеджеру о
каком-либо важном событии (&quot;подключенный
интерфейс не работает&quot;). У менеджера должна
быть возможность установить переменные в агенте
(&quot;измени значение TTL по умолчанию на 64&quot;),
помимо того, что менеджер должен иметь
возможность считывать переменные от агента. </small></p>

<p><small>Управление сетями TCP/IP состоит из трех
частей.</small> 

<ol>
  <li><small><a NAME="t251004"></a>Информационная база управления
    (MIB - Management Information Base), которая указывает, какие
    переменные в элементах сети необходимо
    обслуживать (информация, которая может быть
    запрошена и установлена менеджером). RFC 1213 <a NAME="t251005"></a>[McCloghrie and Rose 1991] определяет вторую
    версию, которая называется MIB-II.</small></li>
  <li><small>Установка общей структуры и схемы
    идентификации, используемой для обращения к
    переменным в MIB. Это называется структурой
    информации управления (<a NAME="t251006"></a>SMI - Structure of
    Management Information) и описывается в RFC 1155 <a NAME="t251007"></a>[Rose
    and McCloghrie 1990]. Например, SMI указывает, что счетчик
    (Counter) это неотрицательное целое число, которое
    изменяется от 0 до 4294967295 и затем снова
    возвращается в 0.</small></li>
  <li><small>Протокол, который функционирует между
    менеджером и элементом, называется простым
    протоколом управления сетью (<a NAME="t251008"></a>SNMP - Simple
    Network Management Protocol). RFC 1157 [<a NAME="t251009"></a>Case et al. 1990]
    описывает этот протокол. Там же подробно описан
    формат пакетов, с помощью которых осуществляется
    обмен. Несмотря на то, что в качестве
    транспортных протоколов могут быть использованы
    разные протоколы, обычно с SNMP используется UDP.</small></li>
</ol>

<p><small>Эти RFC определяют то, что в настоящее время
называется SNMPv1, или просто SNMP, что мы и обсудим в
этой главе. В течение 1993 года были опубликованы
дополнительные RFC, которые описывают SNMP Version 2
(SNMPv2), который мы опишем в разделе <a HREF="#t25C000">&quot;SNMP
версии 2&quot;</a> этой главы. </small></p>

<p><small>В этой главе мы рассмотрим протокол,
который используется для общения между
менеджером и клиентом, во-первых, а затем
посмотрим какие переменные использует агент. Мы
опишем информационную базу данных,
поддерживаемую агентом (MIB), рассмотрим группы,
которые мы уже описали в тексте: IP, UDP, TCP и так
далее. Рассмотрим примеры, соответствующие
каждому описанию, а в процессе рассмотрения
будем обращаться к концепции протоколов,
описанных в предыдущих главах.</small></p>
<u><b>

<p><a NAME="t252000"></a>Протокол</p>
</b></u>

<p><small>SNMP определяет всего пять типов сообщений,
которыми обмениваются менеджер и клиент.</small></p>

<p><small>Получить значение одной или нескольких
переменных: оператор <a NAME="t252001"></a>get-request. Получить
следующую переменную после этой или несколько
указанных переменных: оператор <a NAME="t252002"></a>get-next-request.
(Мы опишем то, что имеем в виду под словом
&quot;следующий&quot; позже в этой главе.) Установить
значение одной или нескольких переменных:
оператор <a NAME="t252003"></a>set-request. Выдать значение
одной или нескольких переменных: оператор <a NAME="t252004"></a>get-response. Это сообщение возвращается
агентом менеджеру в ответ на операторы get-request,
get-next-request и set-request. Уведомить менеджера, когда
что-либо произошло с агентом: оператор <a NAME="t252005"></a>trap.</small></p>

<p><small>Первые три сообщения отправляются от
менеджера к агенту, а последние два от агента к
менеджеру. (Мы будем называть первые три
оператора как get, get-next и set.) На рисунке 25.1
приведены все пять операторов. </small></p>

<p><small>Так как четыре из пяти SNMP сообщений
реализуются простой последовательностью
запрос-отклик (менеджер отправляет запрос, а
агент возвращает отклик), SNMP используют UDP. Это
означает, что запрос от менеджера может не
прибыть к агенту, а отклик от агента может не
прибыть к менеджеру. В этом случае менеджер,
возможно, отработает <a NAME="t252006"></a>тайм-аут и
осуществит повторную передачу.<a NAME="t252007"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t25_1000.jpg" WIDTH="432" HEIGHT="228"></small></p>


<p ALIGN="CENTER"><small>Рисунок 25.1 Пять операторов SNMP.</small></p>

<p>&nbsp;</p>

<p><small>Менеджер отправляет эти три запроса на UDP
порт 161. Агент отправляет ловушки (trap) на UDP порт 162.
Так как используются два разных порта, одна
система может выступать в роли менеджера и
агента одновременно. (См. <a HREF="#t25D001">упражнение 1</a>
в конце главы.) </small></p>

<p><small>На рисунке 25.2 показан формат пяти SNMP
сообщений, инкапсулированных в UDP датаграмму.<a NAME="t252008"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t25_2000.jpg" WIDTH="524" HEIGHT="246"></small></p>


<p ALIGN="CENTER"><small>Рисунок 25.2 Формат пяти SNMP
сообщений.</small></p>

<p>&nbsp;</p>

<p><small>На этом рисунке мы указали в байтах только
размер IP и UDP заголовков. Это объясняется тем, что
для SNMP сообщений используется кодирование -
называемое ASN.1 и BER, которые мы опишем позже в этой
главе - в зависимости от типа переменных и их
значений. </small></p>

<p><small>Значение поля version равно 0. Это значение в
действительности равно номеру версии минус
единица. (Версия SNMP, которую мы описываем,
называется SNMPv1.) </small></p>

<p><small>На рисунке 25.3 показано значение для типа
блока данных протокола (PDU type). (<a NAME="t252009"></a>PDU - это
блок данных протокола - Protocol Data Unit, обычно
называемый &quot;пакет&quot;.)<a NAME="t252010"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="330">
  <tr>
    <td WIDTH="36%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>PDU
    type</small></td>
    <td WIDTH="64%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Имя</small></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="64%" VALIGN="TOP"><small>get-request</small></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="64%" VALIGN="TOP"><small>get-next-request</small></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><p ALIGN="CENTER"><small>2</small></td>
    <td WIDTH="64%" VALIGN="TOP"><small>set-request</small></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><p ALIGN="CENTER"><small>3</small></td>
    <td WIDTH="64%" VALIGN="TOP"><small>get-response</small></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><p ALIGN="CENTER"><small>4</small></td>
    <td WIDTH="64%" VALIGN="TOP"><small>trap</small></td>
  </tr>
</table>


<p><small>Рисунок 25.3 Типы PDU сообщений SNMP. </small></p>

<p>&nbsp;</p>

<p><small><a NAME="t252011"></a>Сообщество (community) это строка
символов, в которой содержится <a NAME="t252012"></a>пароль
в открытом виде. Пароль используется при общении
между менеджером и агентом. Обычное значение -
6-символьная строка public. </small></p>

<p><small>В операторах get, get-next и set менеджер
устанавливает идентификатор запроса (request ID),
который возвращается агентом в сообщении get-response.
Мы видели этот тип переменной в других UDP
приложениях. (Вспомните поле идентификации
(identification) DNS на <a HREF="tcp14.html#t143001">рисунке 14.3</a> и поле
идентификатора транзакции (transaction ID) на <a HREF="tcp16.html#t162001">рисунке 16.2</a>.) Это позволяет
клиенту (менеджеру в данном случае) сопоставить
отклики от сервера (агент) с запросами, которые
были отправлены клиентом. Это поле также
позволяет менеджеру выдать несколько запросов
одному или нескольким агентам, а затем
отсортировать полученные отклики. </small></p>

<p><small>Статус ошибки (error status) это целое число,
которое возвращается агентам и указывает на
ошибку. На рисунке 25.4 показаны значения, имена и
описания ошибок.&nbsp;<a NAME="t252013"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="665">
  <tr>
    <td WIDTH="19%" VALIGN="MIDDLE" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>статус ошибки</small></td>
    <td WIDTH="21%" VALIGN="MIDDLE" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Имя</small></td>
    <td WIDTH="60%" VALIGN="MIDDLE" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Описание</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>noError</small></td>
    <td WIDTH="60%" VALIGN="TOP"><small>все в порядке</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>tooBig</small></td>
    <td WIDTH="60%" VALIGN="TOP"><small>клиент не может
    поместить отклик в одно SNMP сообщение</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><p ALIGN="CENTER"><small>2</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>noSuchName</small></td>
    <td WIDTH="60%" VALIGN="TOP"><small>оператор указывает
    на несуществующую переменную</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><p ALIGN="CENTER"><small>3</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>badValue</small></td>
    <td WIDTH="60%" VALIGN="TOP"><small>в операции
    установки использовано недопустимое значение
    или сделана ошибка в синтаксисе</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><p ALIGN="CENTER"><small>4</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>readOnly</small></td>
    <td WIDTH="60%" VALIGN="TOP"><small>менеджер попытался
    изменить переменную, которая помечена как
    &quot;только для чтения&quot;</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><p ALIGN="CENTER"><small>5</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>genErr</small></td>
    <td WIDTH="60%" VALIGN="TOP"><small>неопознанная
    ошибка</small></td>
  </tr>
</table>


<p><small>Рисунок 25.4 Значения статуса ошибки SNMP.</small></p>

<p>&nbsp;</p>

<p><small>Если возникла ошибка, индекс ошибки (error index)
это целое смещение, указывающее на то, в какой
переменной произошла ошибка. Это значение
устанавливается агентом только для ошибок noSuchName
(нет такого имени), badValue (неверное значение) и readOnly
(только для чтения). </small></p>

<p><small>Список имен переменных и значений следует в
get, get-next и set запросах. Раздел значений
игнорируется в операторах get и get-next. </small></p>

<p><small>Для оператора trap (PDU type равен 4) формат SNMP
сообщения изменяется. Мы опишем поля заголовка
ловушки, когда будем описывать этот оператор в
разделе <a HREF="#t25A000">&quot;Ловушки&quot;</a> этой главы.</small></p>
<u><b>

<p><a NAME="t253000"></a>Структура управляющей информации</p>
</b></u>

<p><small>SNMP использует небольшое количество
различных типов данных. В этой главе мы
рассмотрим эти типы, однако не будем
рассматривать то, как эти данные в
действительности кодируются (для хранения
данных используются битовые шаблоны).</small> 

<ul>
  <li><small><a NAME="t253001"></a>INTEGER (целое число). Некоторые
    переменные объявляются как целые без
    ограничений (например, MTU для интерфейса),
    некоторые определены с конкретными значениями
    (например, флаг IP о перенаправлении установлен в
    1, если перенаправление включено, или в 2, если
    перенаправление выключено), а другие определены
    с их минимальными и максимальными значениями
    (например, номера портов TCP и UDP находятся в
    диапазоне от 0 до 65535). </small></li>
  <li><small><a NAME="t253002"></a>OCTET STRING (восьмеричная строка).
    Строка из 0 или нескольких 8-битных байт. Каждый
    байт имеет значение от 0 до 255. В кодировании BER,
    используемом для этих типов данных и для
    следующего, счетчик количества байт в строке
    находится перед самой строкой. Эти строки не
    заканчиваются нулевыми значениями. </small></li>
  <li><small><a NAME="t253003"></a>DisplayString. Строка из 0 или
    нескольких 8-битных байт, причем каждый байт
    должен быть символом из набора <a NAME="t253004"></a>ASCII NVT
    (глава 26, раздел <a HREF="tcp26.html#t264000">&quot;Протокол
    Telnet&quot;</a>). Все переменные этого типа в MIB-II должны
    содержать не больше чем 255 символов. (Строка
    нулевой длины допустима.) </small></li>
  <li><small><a NAME="t253005"></a>OBJECT IDENTIFIER (идентификатор
    объекта). Мы опишем их в следующем разделе. </small></li>
  <li><small>NULL (ноль). Означает, что у соответствующей
    переменной нет значения. Используется, например,
    в качестве всех значений для переменных в
    запросах get или get-next, пока эти переменные
    запрашиваются, а не устанавливаются. </small></li>
  <li><small><a NAME="t253006"></a>IpAddress (IP адрес). OCTET STRING
    (восьмеричная строка) длиной 4, с 1 байтом на
    каждый байт IP адреса. </small></li>
  <li><small><a NAME="t253007"></a>PhysAddress (физический адрес). OCTET STRING
    (восьмеричная строка), содержит физический адрес
    (например, 6-байтный Ethernet адрес). </small></li>
  <li><small><a NAME="t253008"></a>Counter (счетчик). Неотрицательное
    целое число, значение которого увеличивается
    монотонно от 0 до значения 232-1 (4.294.967.295) и затем
    вновь возвращается в 0. </small></li>
  <li><small><a NAME="t253009"></a>Gauge (критерий). Неотрицательное
    целое число в диапазоне от 0 до 232-1, значение
    которого может увеличиваться или уменьшаться,
    однако изменения прекращаются по достижении
    максимального значения. Это означает, что если
    значение достигнет величины 232-1, критерий будет
    оставаться в этом значении до тех пор, пока не
    будет сброшен. Примером может служить переменная
    MIB tcpCurrEstab: это количество TCP соединений,
    находящихся в настоящий момент в состоянии <a NAME="t253010"></a>ESTABLISHED (установлено) или <a NAME="t253011"></a>CLOSE_WAIT
    (ожидание закрытия). </small></li>
  <li><small><a NAME="t253012"></a>TimeTicks (тики времени). Счетчик,
    который считает время в сотых долях секунды с
    какой-либо исходной точки. Различные переменные
    могут указывать начало счета с различных
    исходных точек, исходная точка используемая для
    каждой переменной этого типа и указывается,
    когда переменная объявляется в MIB. Например,
    переменная sysUpTime это количество сотых долей
    секунды, в течение которых агент был включен. </small></li>
  <li><small><a NAME="t253013"></a>SEQUENCE (последовательность).
    Напоминает структуру в языке программирования С.
    Например, мы рассмотрим, как в MIB определяется
    последовательность (SEQUENCE), которая называется
    UdpEntry и которая содержит информацию об активности
    конечных точек UDP агента. (Под словом
    &quot;активность&quot; мы подразумеваем порты,
    которые используются в настоящее время
    приложением.) В этой структуре есть две записи:</small></li>
</ul>

<dir>
  <ol>
    <li><small>udpLocalAddress, типа IpAddress, содержащая локальный IP
      адрес. </small></li>
    <li><small>udpLocalPort, типа INTEGER, в диапазоне от 0 до 65535,
      которая содержит локальный номер порта. </small></li>
  </ol>
</dir>

<ul>
  <li><small><a NAME="t253014"></a>SEQUENCE OF (последовательность
    чего). Это определение вектора со всеми
    элементами, которые имеют тот же самый тип
    данных. Если каждый элемент имеет простой тип
    данных, такой как целое, мы имеем простой вектор
    (одномерный массив). Однако мы увидим, что SNMP
    использует эти типы данных с каждым элементом
    вектора, который является последовательностью
    (SEQUENCE) (структура). Поэтому мы можем считать их
    двумерными массивами или таблицей. Например,
    таблица слушающих процессов (listener) UDP называется
    udpTable, и является последовательностью (SEQUENCE OF)
    2-элементной структуры (SEQUENCE) UdpEntry, которую мы
    только что описали. На рисунке 25.5 показан
    двумерный массив.<a NAME="t253015"></a></small></li>
</ul>


<p ALIGN="CENTER"><small><img SRC="t25_5000.jpg" WIDTH="463" HEIGHT="121"></small></p>


<p ALIGN="CENTER"><small>Рисунок 25.5 Таблица listener UDP (udpTable),
которая представлена как двумерный массив SNMP.</small></p>

<p>&nbsp;</p>

<p><small>Количество строк в этой таблице не
определяется SNMP, однако мы увидим, что менеджер,
используя оператор get-next (раздел <a HREF="#t257000">&quot;Простые
примеры&quot;</a> этой главы), может определить, что
получена последняя строка таблицы. Также, в
разделе <a HREF="#t256000">&quot;Примеры идентификации&quot;</a>
мы увидим, как менеджер указывает, какую строку
таблицы он хочет получить или установить.</small></p>
<u><b>

<p><a NAME="t254000"></a>Идентификаторы объектов</p>
</b></u>

<p><small>Идентификатор объекта это тип данных,
указывающий на полномочно названный объект. Под
словом &quot;полномочно&quot; мы подразумеваем, что
эти идентификаторы не назначаются случайным
образом, а назначаются некоторыми организациями,
которые несут ответственность за группу
идентификаторов. </small></p>

<p><small>Идентификатор объекта это
последовательность целых десятичных чисел,
разделенных точками. Эти целые числа
представляют собой древовидную структуру,
напоминающую DNS (<a HREF="tcp14.html#t142001">рисунок 14.1</a>) или
файловую систему Unix. В вершине, откуда начинается
дерево идентификаторов объектов, существует
корень без названия. </small></p>

<p><small>На рисунке 25.6 показана структура дерева.
Все переменные в MIB начинаются с идентификатора
объекта 1.3.6.1.2.1. </small></p>

<p><small>У каждого узла в дереве также существует
текстовое имя. Имя, соответствующее
идентификатору объекта 1.3.6.1.2.1, это
iso.org.dod.internet.mgmt.mib. Подобная форма записи имен
используется для удобства чтения. Имена
переменных MIB используемые при обмене пакетами
между менеджером и агентом (рисунок 25.2), это
цифровые идентификаторы объектов, начинающиеся
с 1.3.6.1.2.1.<a NAME="t254001"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t25_6000.jpg" WIDTH="531" HEIGHT="437"></small></p>


<p ALIGN="CENTER"><small>Рисунок 25.6 Идентификаторы объектов
в информационной базе управления.</small></p>

<p>&nbsp;</p>

<p><small>Помимо идентификаторов объектов mib,
приведенных на рисунке 25.6, мы также привели еще
один iso.org.dod.internet.private.enterprises (1.3.5.1.4.1). В этом месте
находится MIB различных производителей. В <a NAME="t254002"></a>Assigned Numbers RFC приведен список около 400
идентификаторов, зарегистрированных ниже этого
узла.</small></p>
<u><b>

<p><a NAME="t255000"></a>Введение в Информационную Базу
Управления (MIB)</p>
</b></u>

<p><small>Информационная база управления (<a NAME="t255001"></a>MIB
- Management Information Base) это информационная база данных,
которая обслуживается агентом, а менеджер может
запросить информацию из этой базы или записать
информацию в эту базу. Мы рассмотрим то, что
называется MIB-II и описано в RFC 1213 <a NAME="t255002"></a>[McCloghrie
and Rose 1991]. </small></p>

<p><small>Как показано на рисунке 25.6, MIB поделена на
группы: system, interfaces, at (трансляция адресов), ip и так
далее. </small></p>

<p><small>В этом разделе мы опишем только переменные,
находящиеся в группе UDP. Это простая группа с
небольшим количеством переменных и одной
таблицей. В следующих разделах, на примере этой
группы мы покажем, как осуществляется
идентификация, построение лексикографического
порядка и некоторые простые примеры этих
характеристик. После чего, в разделе <a HREF="#t258000">&quot;Информационная
база управления (продолжение)&quot;</a>, мы вернемся к
MIB и опишем некоторые другие группы в MIB. </small></p>

<p><small>На рисунке 25.6 мы показали группу под
названием udp, находящуюся ниже mib. На рисунке 25.7
показана структура группы UDP.<a NAME="t255003"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t25_7000.jpg" WIDTH="511" HEIGHT="251"></small></p>


<p ALIGN="CENTER"><small>Рисунок 25.7 Древовидная структура
таблицы IP адресов.</small></p>

<p>&nbsp;</p>

<p><small>Как мы говорили ранее, группа UDP содержит
четыре переменные, и одну таблицу из двух
переменных. На рисунке 25.8 приведены четыре
переменные.<a NAME="t255004"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="762">
  <tr>
    <td WIDTH="28%" VALIGN="MIDDLE" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Имя</small></td>
    <td WIDTH="14%" VALIGN="MIDDLE" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Тип
    данных</small></td>
    <td WIDTH="9%" VALIGN="MIDDLE" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>R/W</small></td>
    <td WIDTH="49%" VALIGN="MIDDLE" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Описание</small></td>
  </tr>
  <tr>
    <td WIDTH="28%" VALIGN="TOP"><small>udpInDatagrams</small></td>
    <td WIDTH="14%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="49%" VALIGN="TOP"><small>Количество UDP
    датаграмм, доставленных пользовательским
    процессам.</small></td>
  </tr>
  <tr>
    <td WIDTH="28%" VALIGN="TOP"><small>udpNoPorts</small></td>
    <td WIDTH="14%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="49%" VALIGN="TOP"><small>Количество
    доставленных UDP датаграмм, для которых не
    оказалось пользовательского процесса на порте
    назначения.</small></td>
  </tr>
  <tr>
    <td WIDTH="28%" VALIGN="TOP"><small>udpInErrors</small></td>
    <td WIDTH="14%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="49%" VALIGN="TOP"><small>Количество
    недоставленных UDP датаграмм не по причине того,
    что на порте назначения не оказалось приложения
    (например, ошибка контрольной суммы UDP).</small></td>
  </tr>
  <tr>
    <td WIDTH="28%" VALIGN="TOP"><small>udpOutDatagrams</small></td>
    <td WIDTH="14%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="49%" VALIGN="TOP"><small>Количество
    отправленных UDP датаграмм.</small></td>
  </tr>
</table>


<p><small>Рисунок 25.8 Переменные в группе udp. </small></p>

<p>&nbsp;</p>

<p><small>Мы будем использовать этот формат при
описании всех переменных MIB в этой главе. Колонка,
помеченная как &quot;R/W&quot;, пуста, если переменная
предназначена только для чтения или содержит
точку (╥), если
переменную можно читать и записывать. Мы всегда
будем включать эту колонку, даже если все
переменные в группе только для чтения (как мы
видели в группе udp), чтобы напомнить, что ни одна
из переменных не может быть установлена
менеджером. В случае если тип данных - INTEGER (целый)
с ограничением, мы будем указывать верхний и
нижний пределы, как сделано для номера порта UDP на
следующем рисунке. </small></p>

<p><small>На рисунке 25.9 описываются две переменные в
udpTable.<a NAME="t255005"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="838">
  <tr>
    <td VALIGN="TOP" COLSPAN="4" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Таблица
    слушающего процесса (listener) UDP, index =
    &lt;udpLocalAddress&gt;.&lt;udpLocalPort&gt;</small></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Имя</small></td>
    <td WIDTH="16%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Тип
    данных</small></td>
    <td WIDTH="7%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>R/W</small></td>
    <td WIDTH="41%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Описание</small></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><small>udpLocalAddress</small></td>
    <td WIDTH="16%" VALIGN="TOP"><small>IpAddress</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="41%" VALIGN="TOP"><small>Локальный IP адрес
    слушающего процесса. 0.0.0.0 указывает, что
    слушающий процесс воспринимает датаграммы с
    любого интерфейса.</small></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><small>udpLocalPort</small></td>
    <td WIDTH="16%" VALIGN="TOP"><small>[0..65535]</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="41%" VALIGN="TOP"><small>Локальный номер
    порта слушающего процесса.</small></td>
  </tr>
</table>


<p><small>Рисунок 25.9 Переменные в udpTable.</small></p>

<p>&nbsp;</p>

<p><small>Каждый раз, когда мы описываем переменные в
SNMP таблице, первая строка рисунка содержит
значение &quot;index&quot;, используемое для обращения к
каждой строке таблицы. Мы покажем некоторые
примеры того, как это делается, в следующем
разделе.</small></p>
<i><b>

<p>Диаграммы зависимостей</p>
</b></i>

<p><small>Здесь приводится взаимосвязь между первыми
тремя счетчиками, описанными на рисунке 25.8.
Диаграммы зависимостей <a NAME="t255006"></a>[Case and Partridge
1989] иллюстрируют взаимосвязь между различными MIB
переменными в заданной группе. На рисунке 25.10
показана диаграмма зависимостей для UDP группы.<a NAME="t255008"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t25_1001.jpg" WIDTH="395" HEIGHT="144"></small></p>


<p ALIGN="CENTER"><small>Рисунок 25.10 Диаграмма зависимостей
для группы UDP.</small></p>

<p>&nbsp;</p>

<p><small><a NAME="t255009"></a>Эта диаграмма показывает, что
количество UDP датаграмм, доставленных приложению
(udpInDatagrams), можно получить как количество UDP
датаграмм, доставленных от IP к UDP, минус udpInErrors,
минус udpNoPorts. Количество UDP датаграмм,
доставленных в IP (udpOutDatagrams), это количество,
переданное в UDP от приложения. Можно сделать
вывод, что udpInDatagrams не включает в себя udpInErrors или
udpNoPorts. </small></p>

<p><small>Эти диаграммы были использованы в процессе
разработки MIB, для проверки того, что все пути
данных для пакета были учтены. [<a NAME="t255010"></a>Rose 1994]
показывает диаграммы зависимостей для всех
групп в MIB.</small></p>
<u><b>

<p><a NAME="t256000"></a>Примеры идентификации</p>
</b></u>

<p><small>Каждая переменная в <a NAME="t256001"></a>MIB должна
быть идентифицирована, когда SNMP обращается к ней,
чтобы получить или установить ее значение.
Во-первых, обращение осуществляется только к
листовым узлам (листовой узел в древовидной
структуре - любой самый удаленный элемент от
корня). SNMP не работает с целыми рядами или
колонками таблицы. Возвращаясь к рисунку 25.7, мы
видим, что листовыми узлами дерева, являются те
четыре, что мы описали на рисунке 25.8, и два на
рисунке 25.9. Узлы mib, udp, udpTable и udpEntry не являются
листовыми узлами. </small></p>
<i><b>

<p><a NAME="t256002"></a>Простые переменные</p>
</b></i>

<p><small>На то, что эта переменная простая, указывает
&quot;.0&quot;, добавленный к идентификатору объекта
переменной. Например, к счетчику udpInDatagrams
показанному на рисунке 25.8, c идентификатором
объекта 1.3.6.1.2.1.7.1, можно обратиться как 1.3.6.1.2.1.7.1.0.
Текстовое имя при подобном обращении будет
iso.org.dod.internet.mgmt.mib.udp.udpInDatagrams.0. </small></p>

<p><small>Однако обращения к этой переменной обычно
делаются в сокращенном виде, udpInDatagrams.0, мы
повторим, что name (имя) переменной, которое
появляется в сообщении SNMP (рисунок 25.2), это
идентификатор объекта 1.3.6.1.2.1.7.1.0.</small></p>
<i><b>

<p><a NAME="t256003"></a>Таблицы</p>
</b></i>

<p><small>Рассмотрим идентификацию пунктов таблицы
более подробно. Давайте вернемся к таблице
слушающего процесса UDP (рисунок 25.7). </small></p>

<p><small>Для каждой таблицы в MIB указан один или
несколько индексов. Для таблицы слушающего
процесса UDP, MIB определяет индекс как комбинацию
двух переменных udpLocalAddress (локальный IP адрес) и
udpLocalPort (локальный UDP порт), индекс в данном случае
- целое число. (Мы показали этот индекс в верхней
строке на рисунке 25.9.) </small></p>

<p><small>Представьте себе, что в таблице слушающего
процесса UDP есть три строки: первая для IP адреса
0.0.0.0 и порта 67, вторая для 0.0.0.0 и порта 161 и третья
для 0.0.0.0 и порта 520. На рисунке 25.11 показана эта
таблица.<a NAME="t256004"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="360">
  <tr>
    <td WIDTH="59%" VALIGN="TOP"><p ALIGN="CENTER"><small>udpLocalAddress</small></td>
    <td WIDTH="41%" VALIGN="TOP"><p ALIGN="CENTER"><small>udpLocalPort</small></td>
  </tr>
  <tr>
    <td WIDTH="59%" VALIGN="TOP"><p ALIGN="CENTER"><small>0.0.0.0</small></td>
    <td WIDTH="41%" VALIGN="TOP"><p ALIGN="CENTER"><small>67</small></td>
  </tr>
  <tr>
    <td WIDTH="59%" VALIGN="TOP"><p ALIGN="CENTER"><small>0.0.0.0</small></td>
    <td WIDTH="41%" VALIGN="TOP"><p ALIGN="CENTER"><small>161</small></td>
  </tr>
  <tr>
    <td WIDTH="59%" VALIGN="TOP"><p ALIGN="CENTER"><small>0.0.0.0</small></td>
    <td WIDTH="41%" VALIGN="TOP"><p ALIGN="CENTER"><small>520</small></td>
  </tr>
</table>


<p><small>Рисунок 25.11 Простая таблица слушающего
процесса UDP.</small></p>

<p>&nbsp;</p>

<p><small>Из таблицы видно, что система готова
принимать UDP датаграммы с любого интерфейса для
портов 67 (BOOTP сервер), 161 (SNMP) и 520 (RIP). К трем строкам
в таблице можно обратиться, как показано на
рисунке 25.12.</small></p>
<i><b>

<p><a NAME="t256005"></a>Лексикографический порядок</p>
</b></i>

<p><small>Порядок в MIB основан на расположении
идентификаторов объектов. Все записи в MIB таблице
расположены в лексикографическом порядке в
соответствии с их идентификаторами объектов. Это
означает, что шесть переменных, приведенных на
рисунке 25.12, расставлены в MIB так, как это показано
на рисунке 25.13. В результате можно декларировать
два правила.<a NAME="t256006"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="811">
  <tr>
    <td WIDTH="10%" VALIGN="MIDDLE" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Строка (ряд)</small></td>
    <td WIDTH="35%" VALIGN="MIDDLE" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Идентификатор
    объекта</small></td>
    <td WIDTH="42%" VALIGN="MIDDLE" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Сокращенное
    имя</small></td>
    <td WIDTH="13%" VALIGN="MIDDLE" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Значение</small></td>
  </tr>
  <tr>
    <td WIDTH="10%" VALIGN="MIDDLE"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="35%" VALIGN="TOP"><small>1.3.6.1.2.1.7.5.1.1.0.0.0.0.67<br>
    1.3.6.1.2.1.7.5.1.2.0.0.0.0.67</small></td>
    <td WIDTH="42%" VALIGN="TOP"><small>udpLocalAddress.0.0.0.0.67<br>
    udpLocalPort.0.0.0.0.67</small></td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>0.0.0.0<br>
    67</small></td>
  </tr>
  <tr>
    <td WIDTH="10%" VALIGN="MIDDLE"><p ALIGN="CENTER"><small>2</small></td>
    <td WIDTH="35%" VALIGN="TOP"><small>1.3.6.1.2.1.7.5.1.1.0.0.0.0.161<br>
    1.3.6.1.2.1.7.5.1.2.0.0.0.0.161</small></td>
    <td WIDTH="42%" VALIGN="TOP"><small>udpLocalAddress.0.0.0.0.161<br>
    udpLocalPort.0.0.0.0.161</small></td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>0.0.0.0<br>
    161</small></td>
  </tr>
  <tr>
    <td WIDTH="10%" VALIGN="MIDDLE"><p ALIGN="CENTER"><small>3</small></td>
    <td WIDTH="35%" VALIGN="TOP"><small>1.3.6.1.2.1.7.5.1.1.0.0.0.0.520<br>
    1.3.6.1.2.1.7.5.1.2.0.0.0.0.520</small></td>
    <td WIDTH="42%" VALIGN="TOP"><small>udpLocalAddress.0.0.0.0.520<br>
    udpLocalPort.0.0.0.0.520</small></td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>0.0.0.0<br>
    520</small></td>
  </tr>
</table>


<p><small>Рисунок 25.12 Пример идентификации строк в
таблице слушающего процесса UDP.</small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="817">
  <tr>
    <td WIDTH="11%" VALIGN="MIDDLE" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Колонка</small></td>
    <td WIDTH="36%" VALIGN="MIDDLE" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Идентификатор
    объекта (в лексикографическом порядке)</small></td>
    <td WIDTH="41%" VALIGN="MIDDLE" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Сокращенное
    имя</small></td>
    <td WIDTH="12%" VALIGN="MIDDLE" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Значение</small></td>
  </tr>
  <tr>
    <td WIDTH="11%" VALIGN="MIDDLE"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="36%" VALIGN="TOP"><small>1.3.6.1.2.1.7.5.1.1.0.0.0.0.67<br>
    1.3.6.1.2.1.7.5.1.1.0.0.0.0.161<br>
    1.3.6.1.2.1.7.5.1.1.0.0.0.0.520</small></td>
    <td WIDTH="41%" VALIGN="TOP"><small>udpLocalAddress.0.0.0.0.67<br>
    udpLocalAddress.0.0.0.0.161<br>
    udpLocalAddress.0.0.0.0.520</small></td>
    <td WIDTH="12%" VALIGN="TOP"><p ALIGN="CENTER"><small>0.0.0.0<br>
    0.0.0.0<br>
    0.0.0.0</small></td>
  </tr>
  <tr>
    <td WIDTH="11%" VALIGN="MIDDLE"><p ALIGN="CENTER"><small>2</small></td>
    <td WIDTH="36%" VALIGN="TOP"><small>1.3.6.1.2.1.7.5.1.2.0.0.0.0.67<br>
    1.3.6.1.2.1.7.5.1.2.0.0.0.0.161<br>
    1.3.6.1.2.1.7.5.1.2.0.0.0.0.520</small></td>
    <td WIDTH="41%" VALIGN="TOP"><small>udpLocalPort.0.0.0.0.67<br>
    udpLocalPort.0.0.0.0.161<br>
    udpLocalPort.0.0.0.0.520</small></td>
    <td WIDTH="12%" VALIGN="TOP"><p ALIGN="CENTER"><small>67<br>
    161<br>
    520</small></td>
  </tr>
</table>


<p><small>Рисунок 25.13 Лексикографический порядок
таблицы слушающего процесса UDP.</small></p>

<p><small>&nbsp;</small> 

<ol>
  <li><small>Так переменная udpLocalAddress всегда появляется
    перед появлением в этой же таблице следующей
    переменной (udpLocalPort), это означает, что доступ к
    таблице осуществляется в порядке колонка-строка.
    Это является результатом лексикографического
    упорядочивания идентификаторов объектов, а не
    имен, предназначенных для чтения человеком.</small></li>
  <li><small>Порядок расположения строк в таблице
    зависит от значений индексов для таблицы. На
    рисунке 25.13, 67 лексикографически меньше чем 161,
    который, в свою очередь, лексикографически
    меньше чем 520.</small></li>
</ol>

<p><small>На рисунке 25.14 показан порядок
колонка-строка для нашего примера таблицы
слушающего процесса UDP.<a NAME="t256007"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t25_1400.jpg" WIDTH="216" HEIGHT="82"></small></p>


<p ALIGN="CENTER"><small>Рисунок 25.14 Таблица слушающего
процесса UDP, показанная в порядке колонка-ряд.</small></p>

<p>&nbsp;</p>

<p><small>Мы еще увидим этот порядок колонка-строка,
когда будем использовать оператор get-next в
следующем разделе.</small></p>
<u><b>

<p><a NAME="t257000"></a>Простые примеры</p>
</b></u>

<p><small>В этой главе мы покажем некоторые простые
примеры того, как можно получить значения
переменных от SNMP агента. Программное
обеспечение, используемое для опроса агента,
называется <a NAME="t257001"></a>snmpi и взято из системы <a NAME="t257002"></a>ISODE. Оба кратко описаны в [<a NAME="t257003"></a>Rose
1994].</small></p>
<i><b>

<p>Простые переменные</p>
</b></i>

<p><small>Мы запрашиваем маршрутизатор на предмет
двух простых переменных из UDP группы:</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>snmpi -a gateway -c secret</b><br>
<br>
snmpi&gt; <b>get udpInDatagrams.0 udpNoPorts.0</b><br>
udpInDatagrams.0=616168 udpInDatagrams.0=616168<br>
udpNoPorts.0=33<br>
<br>
snmpi&gt; <b>quit</b><br>
</p>

<p>&nbsp;</p>


<p><small>Опция <a NAME="t257004"></a>-a указывает на агента, с
которым мы хотим пообщаться, а опция <a NAME="t257005"></a>-c
указывает SNMP <a NAME="t257006"></a>сообщество. Это пароль,
устанавливаемый клиентом (snmpi в данном случае), и
если сервер (агент на системе gateway) распознает имя
сообщества, он ответит на запрос менеджера. Агент
может позволить клиентам, принадлежащим к одному
сообществу, только чтение своих переменных, а
клиентам из другого сообщества чтение и запись. </small></p>

<p><small>Программа выводит приглашение snmpi&gt;, после
чего мы можем, например, ввести команду get,
которая будет преобразована в SNMP сообщение <a NAME="t257007"></a>get-request. Затем мы вводим quit. (Во всех
следующих примерах последняя команда quit
удалена.) На рисунке 25.15 показаны две строки
вывода tcpdump для этого примера.<a NAME="t257008"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.1024
&gt; gateway.161: GetRequest (42) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.3.6.1.2.1.7.1.0
1.3.6.1.2.1.7.2.0<br>
<br>
2&nbsp; 0.348875 (0.3489)&nbsp;&nbsp;&nbsp; gateway.161 &gt; sun.1024: GetResponse (46) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.3.6.1.2.1.7.1.0=616168
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.3.6.1.2.1.7.2.0=33<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 25.15 Вывод tcpdump для простого запроса
SNMP. </small></p>

<p>&nbsp;</p>

<p><small>Запрос о двух переменных посылается в одной
UDP датаграмме, отклик также прибывает в одной UDP
датаграмме. </small></p>

<p><small>Мы показали переменные в виде
соответствующих им идентификаторов объектов,
потому что именно это было отправлено в SNMP
сообщениях. Мы должны были указать эти две
переменные как 0. Обратите внимание на то, что в
отклике всегда возвращается имя переменной
(идентификатора объекта). Ниже мы увидим, что это
необходимо для работы оператора get-next.</small></p>
<i><b>

<p>Оператор get-next</p>
</b></i>

<p><small>Функционирование оператора get-next основано
на лексикографическом порядке MIB. Мы начнем
следующий пример с запроса следующего
идентификатора объекта после udp (не указывая
объект, так как это не листовой объект). При этом
будет возвращен первый объект группы UDP. Затем мы
запросим следующую запись, будет возвращена
вторая запись. И наконец, мы повторим это еще раз,
чтобы получить третью запись:</small></p>

<p>&nbsp;</p>


<p>sun % <b>snmpi -a gateway -c secret<br>
<br>
</b>snmpi&gt; <b>next udp<br>
</b>udpInDatagrams.0=616318<br>
<br>
snmpi&gt; <b>next udpInDatagrams.0<br>
</b>udpNoPorts.0=33<br>
<br>
snmpi&gt; <b>next udpNoPorts.0<br>
</b>udpInErrors.0=0&nbsp;</p>

<p>&nbsp;</p>

<p><small>Этот пример показывает, почему оператор
get-next должен возвращать имя переменной: мы
спрашиваем агента о следующей переменной, и
агент возвращает ее имя и значение. </small></p>

<p><small>При использовании оператора get-next менеджер
осуществляет циклический опрос всех переменных,
поддерживаемых агентом (цикл стартует с начала
MIB). Другое использование этого оператора -
просмотр таблиц.</small></p>
<i><b>

<p><a NAME="t257009"></a>Доступ к таблице</p>
</b></i>

<p><small>Мы можем убедиться в том, что таблица имеет
организацию колонка-строка, воспользовавшись
программой, которая отправляет запросы, для того
чтобы пройти через таблицу слушающего процесса
UDP. Мы начнем с того, что спросим следующую
переменную после udpTable. Так как это не листовой
объект, мы не можем указать объект, однако
оператор get-next все равно возвращает следующий
объект в таблице. Затем мы продолжим движение по
таблице, так как агент возвращает следующую
переменную, в соответствии с порядком
столбец-строка:<a NAME="t257010"></a> </small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>snmpi -a gateway -c secret</b><br>
<br>
snmpi&gt; <b>next udpTable</b><br>
udpLocalAddress.0.0.0.0.67=0.0.0.0<br>
<br>
snmpi&gt; <b>next udpLocalAddress.0.0.0.0.67</b><br>
udpLocalAddress.0.0.0.0.161=0.0.0.0<br>
<br>
snmpi&gt; <b>next udpLocalAddress.0.0.0.0.161</b><br>
udpLocalAddress.0.0.0.0.520=0.0.0.0<br>
<br>
snmpi&gt; <b>next udpLocalAddress.0.0.0.0.520</b><br>
udpLocalPort.0.0.0.0.67=67<br>
<br>
snmpi&gt; <b>next udpLocalPort.0.0.0.0.67</b><br>
udpLocalPort.0.0.0.0.161=161<br>
<br>
snmpi&gt; <b>next udpLocalPort.0.0.0.0.161</b><br>
udpLocalPort.0.0.0.0.520=520<br>
<br>
snmpi&gt; <b>next udpLocalPort.0.0.0.0.520</b><br>
snmpInPkts.0=59
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; здесь мы
закончили просмотр таблицы слушающего процесса
UDP<br>
</p>

<p>&nbsp;</p>


<p><small>Мы видим, что порядок, возвращенный в данном
примере, соответствует порядку, приведенному на
рисунке 25.14. </small></p>

<p><small>Как менеджер может определить, что он
достиг конца таблицы? Так как ответ на оператор
get-next содержит имя следующего пункта в MIB после
таблицы, менеджер может сказать, когда имя
изменилось. В нашем примере последний пункт в
таблице слушающего процесса UDP следует за
переменной snmpInPkts.</small></p>
<u><b>

<p><a NAME="t258000"></a>Информационная база управления
(продолжение) </p>
</b></u>

<p><small>А сейчас мы вернемся к описанию <a NAME="t258001"></a>MIB.
Опишем следующие группы: system (идентификация
системы), if (интерфейсы), at (трансляция адресов), ip,
icmp и tcp. Также определены дополнительные группы.</small></p>
<i><b>

<p><a NAME="t258002"></a>Группа system</p>
</b></i>

<p><small>Группа system довольно проста; она состоит из
семи простых переменных (таблиц в этой группе
нет). На рисунке 25.16 приведены их имена, типы
данных и описания.<a NAME="t258003"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="785">
  <tr>
    <td WIDTH="20%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Имя</small></td>
    <td WIDTH="26%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Тип
    данных</small></td>
    <td WIDTH="8%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>R/W</small></td>
    <td WIDTH="46%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Описание</small></td>
  </tr>
  <tr>
    <td WIDTH="20%" VALIGN="TOP"><small>sysDescr</small></td>
    <td WIDTH="26%" VALIGN="TOP"><small>DisplayString</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="46%" VALIGN="TOP"><small>Текстовое описание
    пункта.</small></td>
  </tr>
  <tr>
    <td WIDTH="20%" VALIGN="TOP"><small>sysObjectID</small></td>
    <td WIDTH="26%" VALIGN="TOP"><small>ObjectID</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="46%" VALIGN="TOP"><small>Идентификатор
    поставщика в поддереве 1.3.6.1.4.1.</small></td>
  </tr>
  <tr>
    <td WIDTH="20%" VALIGN="TOP"><small>sysUpTime</small></td>
    <td WIDTH="26%" VALIGN="TOP"><small>TimeTicks</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="46%" VALIGN="TOP"><small>Время в сотых долях
    секунд с того момента, когда часть системы,
    отвечающая за управление сетевое, была
    перестартована.</small></td>
  </tr>
  <tr>
    <td WIDTH="20%" VALIGN="TOP"><small>sysContact</small></td>
    <td WIDTH="26%" VALIGN="TOP"><small>DisplayString</small></td>
    <td WIDTH="8%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="46%" VALIGN="TOP"><small>Имя человека, к
    которому необходимо обратиться, и как его можно
    найти.</small></td>
  </tr>
  <tr>
    <td WIDTH="20%" VALIGN="TOP"><small>sysName</small></td>
    <td WIDTH="26%" VALIGN="TOP"><small>DisplayString</small></td>
    <td WIDTH="8%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="46%" VALIGN="TOP"><small>Полное имя домена
    узла (<a NAME="t258004"></a>FQDN) .</small></td>
  </tr>
  <tr>
    <td WIDTH="20%" VALIGN="TOP"><small>sysLocation</small></td>
    <td WIDTH="26%" VALIGN="TOP"><small>DisplayString</small></td>
    <td WIDTH="8%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="46%" VALIGN="TOP"><small>Физическое
    расположение узла.</small></td>
  </tr>
  <tr>
    <td WIDTH="20%" VALIGN="TOP"><small>sysServices</small></td>
    <td WIDTH="26%" VALIGN="TOP"><small>[0..127]</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="46%" VALIGN="TOP"><small>Значение,
    указывающее на то, какие сервисы предоставляются
    узлом. Это сумма уровней OSI модели,
    поддерживаемых узлом. Следующие значения
    складываются вместе, в зависимости от того, какие
    сервисы поддерживаются: 0х01 (физический), 0х02
    (канальный), 0х04 (сетевой), 0х08 (точка-точка), 0х40
    (прикладной).</small></td>
  </tr>
</table>


<p><small>Рисунок 25.16 Простые переменные группы system.</small></p>

<p>&nbsp;</p>

<p><small>Мы можем отправить запрос маршрутизатору
netb, для того чтобы получить некоторые из этих
переменных:</small></p>

<p>&nbsp;</p>


<p>sun % <b>snmpi -a netb -c secret<br>
<br>
</b>snmpi&gt; <b>get sysDescr.0 sysObjectID.0 sysUpTime.0 sysServices.0<br>
</b>sysDescr.0=&quot;Epilogue Technology SNMP agent for Telebit NetBlazer&quot;<br>
sysObjectID.0=1.3.6.1.4.1.12.42.3.1<br>
sysUpTime.0=22 days, 11 hours, 23 minutes, 2 seconds (194178200 timeticks)<br>
sysServices.0=0xc&lt;internet, transport&gt;&nbsp;</p>

<p>&nbsp;</p>

<p><small>Идентификатор объекта системы находится в
группе internet.private.enterprises (1.3.6.1.4.1), в соответствии с
рисунком 25.6. Из <a NAME="t258005"></a>Assigned Numbers RFC мы можем
определить, что следующий идентификатор объекта
(12) назначен производителю (Epilogue). </small></p>

<p><small>Также мы можем видеть, что переменная sysServices
является суммой 4 и 8: этот элемент сети (netb)
поддерживает IP уровень (маршрутизация) и
транспортный уровень (точка-точка).</small></p>
<i><b>

<p><a NAME="t258006"></a>Группа interface</p>
</b></i>

<p><small>Только одна простая переменная определена
для этой группы: количество интерфейсов в
системе. Рисунок 25.17.<a NAME="t258007"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="739">
  <tr>
    <td WIDTH="16%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Имя</small></td>
    <td WIDTH="16%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Тип
    данных</small></td>
    <td WIDTH="8%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>R/W</small></td>
    <td WIDTH="60%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Описание</small></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><small>ifNumber</small></td>
    <td WIDTH="16%" VALIGN="TOP"><small>INTEGER</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="60%" VALIGN="TOP"><small>Количество сетевых
    интерфейсов в системе.</small></td>
  </tr>
</table>


<p><small>Рисунок 25.17 Простая переменная в группе if.</small></p>

<p>&nbsp;</p>

<p><small>В этой группе также определена таблица,
состоящая из 22 строк. Каждая строка в таблице
определяет характеристики каждого интерфейса,
как показано на рисунке 25.18.<a NAME="t258008"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="762">
  <tr>
    <td VALIGN="TOP" COLSPAN="4" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Таблица
    интерфейсов, индекс = &lt; IfIndex &gt;</small></td>
  </tr>
  <tr>
    <td WIDTH="29%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Имя</small></td>
    <td WIDTH="23%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Тип
    данных</small></td>
    <td WIDTH="9%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>R/W</small></td>
    <td WIDTH="39%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Описание</small></td>
  </tr>
  <tr>
    <td WIDTH="29%" VALIGN="TOP"><small>ifIndex</small></td>
    <td WIDTH="23%" VALIGN="TOP"><small>INTEGER</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP"><small>Индекс интерфейса,
    находится в диапазоне между единицей и ifNumber.</small></td>
  </tr>
  <tr>
    <td WIDTH="29%" VALIGN="TOP"><small>ifDescr</small></td>
    <td WIDTH="23%" VALIGN="TOP"><small>DisplayString</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP"><small>Текстовое описание
    интерфейса.</small></td>
  </tr>
  <tr>
    <td WIDTH="29%" VALIGN="TOP"><small>ifType</small></td>
    <td WIDTH="23%" VALIGN="TOP"><small>INTEGER</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP"><small>Тип, например: 6 =
    Ethernet, 7 = 802.3 Ethernet, 9 = 802.5 Token ring, 23 = PPP, 28 = SLIP и многие
    другие переменные.</small></td>
  </tr>
  <tr>
    <td WIDTH="29%" VALIGN="TOP"><small>ifMtu</small></td>
    <td WIDTH="23%" VALIGN="TOP"><small>INTEGER</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP"><small>MTU интерфейса
    (максимальный блок передачи).</small></td>
  </tr>
  <tr>
    <td WIDTH="29%" VALIGN="TOP"><small>ifSpeed</small></td>
    <td WIDTH="23%" VALIGN="TOP"><small>Gauge</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP"><small>Скорость в битах в
    секунду.</small></td>
  </tr>
  <tr>
    <td WIDTH="29%" VALIGN="TOP"><small>ifPhysAddress</small></td>
    <td WIDTH="23%" VALIGN="TOP"><small>PhysAddress</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP"><small>Физический адрес
    или строка нулевой длины для интерфейсов без
    физического адреса (например, последовательные
    каналы).</small></td>
  </tr>
  <tr>
    <td WIDTH="29%" VALIGN="TOP"><small>ifAdminStatus</small></td>
    <td WIDTH="23%" VALIGN="TOP"><small>[1..3]</small></td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="39%" VALIGN="TOP"><small>Желательное
    состояние интерфейса: 1 = активен, 2 = выключен, 3 =
    тестируется.</small></td>
  </tr>
  <tr>
    <td WIDTH="29%" VALIGN="TOP"><small>ifOperStatus</small></td>
    <td WIDTH="23%" VALIGN="TOP"><small>[1..3]</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP"><small>Текущее состояние
    интерфейса: 1 = активен, 2 = выключен, 3 =
    тестируется.</small></td>
  </tr>
  <tr>
    <td WIDTH="29%" VALIGN="TOP"><small>ifLastChange</small></td>
    <td WIDTH="23%" VALIGN="TOP"><small>TimeTicks</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP"><small>Значение sysUpTime на
    момент, когда интерфейс вошел в текущее
    состояние функционирования.</small></td>
  </tr>
  <tr>
    <td WIDTH="29%" VALIGN="TOP"><small>ifInOctets</small></td>
    <td WIDTH="23%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP"><small>Полное количество
    принятых байтов, включая символы построения
    фреймов.</small></td>
  </tr>
  <tr>
    <td WIDTH="29%" VALIGN="TOP"><small>ifInUcastPkts</small></td>
    <td WIDTH="23%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP"><small>Количество
    персональных пакетов, доставленных к верхним
    уровням.</small></td>
  </tr>
  <tr>
    <td WIDTH="29%" VALIGN="TOP"><small>ifInNUcastPkts</small></td>
    <td WIDTH="23%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP"><small>Количество
    неперсональных (широковещательных или
    групповых) пакетов, доставленных к верхним
    уровням.</small></td>
  </tr>
  <tr>
    <td WIDTH="29%" VALIGN="TOP"><small>ifInDiscards</small></td>
    <td WIDTH="23%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP"><small>Количество
    принятых и отброшенных пакетов, даже если в
    пакете не была обнаружена ошибка (переполнение
    буферов).</small></td>
  </tr>
  <tr>
    <td WIDTH="29%" VALIGN="TOP"><small>ifInErrors</small></td>
    <td WIDTH="23%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP"><small>Количество пакетов
    принятых и отброшенных по причине ошибок.</small></td>
  </tr>
  <tr>
    <td WIDTH="29%" VALIGN="TOP"><small>ifInUnknownProtos</small></td>
    <td WIDTH="23%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP"><small>Количество
    принятых и отброшенных пакетов по причине того,
    что они принадлежали неизвестному протоколу.</small></td>
  </tr>
  <tr>
    <td WIDTH="29%" VALIGN="TOP"><small>ifOutOctets</small></td>
    <td WIDTH="23%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP"><small>Количество
    переданных байт, включая символы построения
    фреймов.</small></td>
  </tr>
  <tr>
    <td WIDTH="29%" VALIGN="TOP"><small>ifOutUcastPkts</small></td>
    <td WIDTH="23%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP"><small>Количество
    персональных пакетов, принятых от верхних
    уровней.</small></td>
  </tr>
  <tr>
    <td WIDTH="29%" VALIGN="TOP"><small>ifOutNUcastPkts</small></td>
    <td WIDTH="23%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP"><small>Количество
    неперсональных (широковещательных или
    групповых) пакетов, принятых от верхних уровней.</small></td>
  </tr>
  <tr>
    <td WIDTH="29%" VALIGN="TOP"><small>ifOutDiscards</small></td>
    <td WIDTH="23%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP"><small>Количество
    исходящих пакетов, которые были отброшены, даже
    если в пакетах не была обнаружена ошибка
    (переполнение буферов).</small></td>
  </tr>
  <tr>
    <td WIDTH="29%" VALIGN="TOP"><small>ifOutErrors</small></td>
    <td WIDTH="23%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP"><small>Количество
    исходящих пакетов, отброшенных по причине
    ошибок.</small></td>
  </tr>
  <tr>
    <td WIDTH="29%" VALIGN="TOP"><small>ifOutQLen</small></td>
    <td WIDTH="23%" VALIGN="TOP"><small>Gauge</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP"><small>Количество
    пакетов, находящихся в выходной очереди.</small></td>
  </tr>
  <tr>
    <td WIDTH="29%" VALIGN="TOP"><small>ifSpecific</small></td>
    <td WIDTH="23%" VALIGN="TOP"><small>ObjectID</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP"><small>Ссылка на
    определение MIB конкретно для этого типа среды
    передачи.</small></td>
  </tr>
</table>


<p><small>Рисунок 25.18 Переменные в таблице
интерфейсов: ifTable.</small></p>

<p>&nbsp;</p>

<p><small>Мы можем запросить хост sun на предмет
некоторых из этих переменных для всех его
интерфейсов. Мы ожидаем увидеть три интерфейса
(см. главу 3, раздел <a HREF="tcp03.html#t038000">&quot;Команда
ifconfig&quot;</a>), если активизирован SLIP интерфейс:</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>snmpi -a sun</b><br>
<br>
snmpi&gt; <b>next ifTable</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; во-первых, мы видим,
чему равен индекс первого интерфейса<br>
ifIndex.1=1<br>
<br>
snmpi&gt; <b>get ifDescr.1 ifType.1 ifMtu.1 ifSpeed.1 ifPhysAddress.1</b><br>
ifDescr.1=&quot;le0&quot;<br>
ifType.1=ethernet-csmacd (6)<br>
ifMtu.1=1500<br>
ifSpeed.1=10000000<br>
ifPhysAddress.1=0x08:00:20:03:f6:42<br>
<br>
snmpi&gt; <b>next ifDescr.1 ifType.1 ifMtu.1 ifSpeed.1 ifPhysAddress.1</b><br>
ifDescr.2=&quot;sl0&quot;<br>
ifType.2=propPointToPointSerial (22)<br>
ifMtu.2=552<br>
ifSpeed.2=0<br>
ifPhysAddress.2=0x00:00:00:00:00:00<br>
<br>
snmpi&gt; <b>next ifDescr.2 ifType.2 ifMtu.2 ifSpeed.2 ifPhysAddress.2</b><br>
ifDescr.3=&quot;lo0&quot;<br>
ifType.3=softwareLoopback (24)<br>
ifMtu.3=1536<br>
ifSpeed.3=0<br>
ifPhysAddress.3=0x00:00:00:00:00:00<br>
</p>


<p>&nbsp;</p>

<p><small>Во-первых, мы получили пять переменных для
первого интерфейса, используя оператор get, а
затем получили те же пять переменных для второго
интерфейса, используя оператор get-next. Последняя
команда получает эти же пять переменных для
третьего интерфейса и опять с использованием
команды get-next. </small></p>

<p><small>Тип интерфейса для SLIP канала сообщается как
последовательное соединение точка-точка, а не SLIP.
Также, не сообщается скорость SLIP канала. </small></p>

<p><small>Очень важно понять взаимосвязь между
оператором get-next и порядком расположения
информации в таблице, а именно колонка-строка.
Когда мы задаем next ifDescr.1, возвращается следующая
строка таблицы для этой переменной, а не
следующую переменную в этой же строке. Однако
если бы таблицы хранились в порядке
строка-колонка, мы могли подобным образом
перейти к следующему появлению заданной
переменной.</small></p>
<i><b>

<p><a NAME="t258009"></a>Группа at</p>
</b></i>

<p><small>Группа трансляции адресов поддерживается
во всех системах, однако ее ценность значительно
уменьшилась, после того как стала использоваться
MIB-II. С использованием MIB-II, каждая группа сетевых
протоколов (например, IP) содержит свою
собственную таблицу трансляции адресов. Для IP
это ipNetToMediaTable. </small></p>

<p><small>В группе at определена только одна таблица
из трех строк, как показано на рисунке 25.19. </small></p>

<p><small>Мы можем использовать новую команду,
существующую в программе snmpi, чтобы получить
содержимое таблицы в целом. Мы запросим
маршрутизатор с именем kinetics (который
предоставляет маршруты между TCP/IP сетью и сетью <a NAME="t258010"></a>AppleTalk), выдать полный <a NAME="t258011"></a>ARP кэш.
Этот вывод будет находиться в
лексикографическом порядке в виде пунктов,
находящихся в таблице:<a NAME="t258012"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="820">
  <tr>
    <td VALIGN="TOP" COLSPAN="4" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Таблица
    трансляции адресов, индекс =
    &lt;atIfIndex&gt;.1.&lt;atNetAddress&gt;</small></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Имя</small></td>
    <td WIDTH="24%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Тип
    данных</small></td>
    <td WIDTH="10%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>R/W</small></td>
    <td WIDTH="42%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Описание</small></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><small>atIfIndex</small></td>
    <td WIDTH="24%" VALIGN="TOP"><small>INTEGER</small></td>
    <td WIDTH="10%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="42%" VALIGN="TOP"><small>Номер интерфейса:
    ifIndex.</small></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><small>atPhysAddress</small></td>
    <td WIDTH="24%" VALIGN="TOP"><small>PhysAddress</small></td>
    <td WIDTH="10%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="42%" VALIGN="TOP"><small>Физический адрес.
    Установка этого параметра в строку с нулевой
    длиной приводит к тому, что пункт считается
    некорректным.</small></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><small>atNetAddress</small></td>
    <td WIDTH="24%" VALIGN="TOP"><small>NetworkAddress</small></td>
    <td WIDTH="10%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="42%" VALIGN="TOP"><small>IP адрес</small></td>
  </tr>
</table>


<p><small>Рисунок 25.19 Таблица трансляции адресов:
atTable.</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>snmpi -a kinetics -c secret dump at</b><br>
<br>
atIfIndex.1.1.140.252.1.4=1<br>
atIfIndex.1.1.140.252.1.22=1<br>
atIfIndex.1.1.140.252.1.183=1<br>
atIfIndex.2.1.140.252.6.4=2<br>
atIfIndex.2.1.140.252.6.6=2<br>
<br>
atPhysAddress.1.1.140.252.1.4=0xaa:00:04:00:f4:14<br>
atPhysAddress.1.1.140.252.1.22=0x08:00:20:0f:2d:38<br>
atPhysAddress.1.1.140.252.1.183=0x00:80:ad:03:6a:80<br>
atPhysAddress.2.1.140.252.6.4=0x00:02:16:48<br>
atPhysAddress.2.1.140.252.6.6=0x00:02:3c:48<br>
<br>
atNetAddress.1.1.140.252.1.4=140.252.1.4<br>
atNetAddress.1.1.140.252.1.22=140.252.1.22<br>
atNetAddress.1.1.140.252.1.183=140.252.1.183<br>
atNetAddress.2.1.140.252.6.4=140.252.6.4<br>
atNetAddress.2.1.140.252.6.6=140.252.6.6<br>
</p>

<p>&nbsp;</p>


<p><small>С использованием <a NAME="t258013"></a>tcpdump можно
увидеть следующее. Для того чтобы получить
полную таблицу, snmpi, во-первых, выдает get-next для
имени таблицы (at в данном примере), чтобы получить
первый пункт. Затем печатает первый пункт и
выдает get-next. Это продолжается до тех пор, пока не
будет получена вся таблица целиком. </small></p>

<p><small>На рисунке 25.20 показана подобная таблица.<a NAME="t258014"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="808">
  <tr>
    <td WIDTH="25%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>atIfIndex</small></td>
    <td WIDTH="33%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>AtPhysAddress</small></td>
    <td WIDTH="42%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>atNetAddress</small></td>
  </tr>
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="33%" VALIGN="TOP"><small>0xaa:00:04:00:f4:14</small></td>
    <td WIDTH="42%" VALIGN="TOP"><small>140.252.1.4</small></td>
  </tr>
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="33%" VALIGN="TOP"><small>0x08:00:20:0f:2d:38</small></td>
    <td WIDTH="42%" VALIGN="TOP"><small>140.252.1.22</small></td>
  </tr>
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="33%" VALIGN="TOP"><small>0x00:80:ad:03:6a:80</small></td>
    <td WIDTH="42%" VALIGN="TOP"><small>140.252.1.183</small></td>
  </tr>
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><p ALIGN="CENTER"><small>2</small></td>
    <td WIDTH="33%" VALIGN="TOP"><small>0x00:02:16:48</small></td>
    <td WIDTH="42%" VALIGN="TOP"><small>140.252.6.4</small></td>
  </tr>
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><p ALIGN="CENTER"><small>2</small></td>
    <td WIDTH="33%" VALIGN="TOP"><small>0x00:02:3c:48</small></td>
    <td WIDTH="42%" VALIGN="TOP"><small>140.252.6.6</small></td>
  </tr>
</table>


<p><small>Рисунок 25.20 Пример таблицы at (ARP кэш).</small></p>

<p>&nbsp;</p>

<p><small>Физические адреса <a NAME="t258015"></a>AppleTalk с
номером интерфейса - 2 имеют 32-битные значения, а
не 48-битные, как у привычных Ethernet адресов. Также
обратите внимание на то, что существуют запись
для нашего маршрутизатора (netb находится по
адресу 140.252.1.183), так как kinetics и netb находятся на
одном и том же Ethernet кабеле (140.252.1), и kinetics должен
использовать ARP, чтобы послать нам SNMP отклик.</small></p>
<i><b>

<p><a NAME="t258016"></a>Группа ip</p>
</b></i>

<p><small>Группа ip определяет большое количество
переменных и три таблицы. На рисунке 25.21
приведены простые переменные.<a NAME="t258017"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="796">
  <tr>
    <td WIDTH="31%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Имя</small></td>
    <td WIDTH="19%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Тип
    данных</small></td>
    <td WIDTH="7%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>R/W</small></td>
    <td WIDTH="43%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Описание</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>ipForwarding</small></td>
    <td WIDTH="19%" VALIGN="TOP"><small>[1..2]</small></td>
    <td WIDTH="7%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="43%" VALIGN="TOP"><small>1 означает, что
    система перенаправляет IP датаграммы, а 2
    означает, что не перенаправляет.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>ipDefaultTTL</small></td>
    <td WIDTH="19%" VALIGN="TOP"><small>INTEGER</small></td>
    <td WIDTH="7%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="43%" VALIGN="TOP"><small>Значение TTL по
    умолчанию, когда его не предоставляет
    транспортный уровень.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>ipInReceives</small></td>
    <td WIDTH="19%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="43%" VALIGN="TOP"><small>Полное количество
    IP датаграмм, полученных со всех интерфейсов.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>ipInHdrErrors</small></td>
    <td WIDTH="19%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="43%" VALIGN="TOP"><small>Количество IP
    датаграмм, отброшенных из-за ошибок в заголовке
    (например, ошибка <a NAME="t258018"></a>контрольной суммы,
    несовпадение номера версии, истечение TTL и так
    далее).</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>ipInAddrErrors</small></td>
    <td WIDTH="19%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="43%" VALIGN="TOP"><small>Количество IP
    датаграмм, отброшенных из-за неправильного
    адреса назначения.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>IpForwDatagrams</small></td>
    <td WIDTH="19%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="43%" VALIGN="TOP"><small>Количество IP
    датаграмм, для которых была сделана попытка
    перенаправить.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>ipInUnknownProtos</small></td>
    <td WIDTH="19%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="43%" VALIGN="TOP"><small>Количество
    локально адресованных IP датаграмм, у которых
    было неверное поле протокола.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>ipInDiscards</small></td>
    <td WIDTH="19%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="43%" VALIGN="TOP"><small>Количество
    принятых IP датаграмм, отброшенных из-за
    недостаточного размера буфера.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>ipInDelivers</small></td>
    <td WIDTH="19%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="43%" VALIGN="TOP"><small>Количество IP
    датаграмм, доставленных соответствующему модулю
    протокола.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>ipOutRequests</small></td>
    <td WIDTH="19%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="43%" VALIGN="TOP"><small>Полное количество
    IP датаграмм, переданных в IP уровень для передачи.
    Сюда не включены те, которые были посчитаны в
    ipForwDatagrams.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>ipOutDiscards</small></td>
    <td WIDTH="19%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="43%" VALIGN="TOP"><small>Количество
    исходящих IP датаграмм, которые были отброшены
    из-за отсутствия места в буфере.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>ipOutNoRoutes</small></td>
    <td WIDTH="19%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="43%" VALIGN="TOP"><small>Количество IP
    датаграмм, которые были отброшены из-за того, что
    не был найден маршрут.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>ipReasmTimeout</small></td>
    <td WIDTH="19%" VALIGN="TOP"><small>INTEGER</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="43%" VALIGN="TOP"><small>Максимальное
    количество секунд, в течение которого принятые
    фрагменты ждали повторной сборки.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>ipReasmReqds</small></td>
    <td WIDTH="19%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="43%" VALIGN="TOP"><small>Количество
    принятых IP фрагментов, которые должны быть
    собраны.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>ipReasmOKs</small></td>
    <td WIDTH="19%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="43%" VALIGN="TOP"><small>Количество успешно
    собранных IP датаграмм.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>ipReasmFails</small></td>
    <td WIDTH="19%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="43%" VALIGN="TOP"><small>Количество сбоев в
    алгоритме повторной сборки IP.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>ipFragOKs</small></td>
    <td WIDTH="19%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="43%" VALIGN="TOP"><small>Количество успешно
    фрагментированных IP датаграмм.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>ipFragFails</small></td>
    <td WIDTH="19%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="43%" VALIGN="TOP"><small>Количество IP
    датаграмм, которые необходимо фрагментировать,
    однако это не было сделано, потому что был
    установлен флаг &quot;не фрагментировать&quot;.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>ipFragCreates</small></td>
    <td WIDTH="19%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="43%" VALIGN="TOP"><small>Количество IP
    фрагментов, которые были получены при
    фрагментации.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>ipRoutingDiscards</small></td>
    <td WIDTH="19%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="43%" VALIGN="TOP"><small>Количество пунктов
    маршрутизации, выбранных для уничтожения, даже
    если они существовали и были верны.</small></td>
  </tr>
</table>


<p><small>Рисунок 25.21 Простые переменные группы ip.</small></p>

<p>&nbsp;</p>

<p><small>Первая таблица в группе ip это таблица IP
адресов. Она содержит по одной строке для каждого
IP адреса в системе. Каждая строка содержит пять
переменных, описанных на рисунке 25.22.<a NAME="t258019"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="785">
  <tr>
    <td VALIGN="TOP" COLSPAN="4" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Таблица
    IP адресов, индекс = &lt;ipAdEntAddr&gt;</small></td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Имя</small></td>
    <td WIDTH="20%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Тип
    данных</small></td>
    <td WIDTH="8%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>R/W</small></td>
    <td WIDTH="40%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Описание</small></td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><small>ipAdEntAddr</small></td>
    <td WIDTH="20%" VALIGN="TOP"><small>IpAddress</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="40%" VALIGN="TOP"><small>IP адрес для этой
    строки.</small></td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><small>ipAdEntIfIndex</small></td>
    <td WIDTH="20%" VALIGN="TOP"><small>INTEGER</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="40%" VALIGN="TOP"><small>Соответствующий
    номер интерфейса: ifIndex.</small></td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><small>ipAdEntNetMask</small></td>
    <td WIDTH="20%" VALIGN="TOP"><small>IpAddress</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="40%" VALIGN="TOP"><small>Маска подсети для
    этого IP адреса.</small></td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><small>ipAdEntBcastAddr</small></td>
    <td WIDTH="20%" VALIGN="TOP"><small>[0..1]</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="40%" VALIGN="TOP"><small>Значение младших
    битов в широковещательном IP адресе. Обычно равно
    1.</small></td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><small>ipAdEntReasmMaxSize</small></td>
    <td WIDTH="20%" VALIGN="TOP"><small>[0..65535]</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="40%" VALIGN="TOP"><small>Размер
    максимальной принятой IP датаграммы для этого
    интерфейса, которая может быть повторно собрана.</small></td>
  </tr>
</table>


<p><small>Рисунок 25.22 Таблица IP адресов: ipAddrTable.</small></p>

<p>&nbsp;</p>

<p><small>Мы можем запросить хост sun, чтобы получить
таблицу IP адресов:</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>snmpi -a sun dump ipAddrTable</b><br>
<br>
ipAdEntAddr.127.0.0.1=127.0.0.1<br>
ipAdEntAddr.140.252.1.29=140.252.1.29<br>
ipAdEntAddr.140.252.13.33=140.252.13.33<br>
<br>
ipAdEntIfIndex.127.0.0.1=3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loopback
интерфейс, lo0<br>
ipAdEntIfIndex.140.252.1.29=2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SLIP интерфейс,
sl0<br>
ipAdEntIfIndex.140.252.13.33=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ethernet интерфейс,
le0<br>
<br>
ipAdEntNetMask.127.0.0.1=255.0.0.0<br>
ipAdEntNetMask.140.252.1.29=255.255.255.0<br>
ipAdEntNetMask.140.252.13.33=255.255.255.224<br>
<br>
ipAdEntBcastAddr.127.0.0.1=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; все три
используют единичный бит <br>
ipAdEntBcastAddr.140.252.1.29=1&nbsp;&nbsp;&nbsp;&nbsp; для
широковещательного адреса<br>
ipAdEntBcastAddr.140.252.13.33=1<br>
<br>
ipAdEntReasmMaxSize.127.0.0.1=65535<br>
ipAdEntReasmMaxSize.140.252.1.29=65535<br>
ipAdEntReasmMaxSize.140.252.13.33=65535<br>
</p>


<p>&nbsp;</p>

<p><small>Номера интерфейсов можно сравнить с
выводом, полученным на рисунке 25.18, а IP адреса и
маски подсетей можно сравнить со значениями,
полученными в выводе команды <a NAME="t258020"></a>ifconfig в
разделе <a HREF="tcp03.html#t038000">&quot;Команда ifconfig&quot;</a>
главы 3. </small></p>

<p><small>Следующая таблица, приведенная на рисунке
25.23, это таблица IP маршрутизации. (Обратитесь к
описанию таблиц маршрутизации, приведенному в
разделе <a HREF="tcp09.html#t092000">&quot;Принципы
маршрутизации&quot;</a> главы 9.) В качестве индекса
для получения доступа к каждой строке таблицы,
используется IP адрес назначения. </small></p>

<p><small>На рисунке 25.24 приведена таблица
маршрутизации для хоста sun, полученная с помощью
команды dump ipRouteTable программы <a NAME="t258021"></a>snmpi. Мы
удалили все пять показателей маршрутизации, так
как все они равны -1, а в заголовках колонок
удалили префикс ipRoute для каждого имени
переменной.<a NAME="t258022"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="796">
  <tr>
    <td VALIGN="TOP" COLSPAN="4" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Таблица
    маршрутизации IP, индекс = &lt;ipRouteDest&gt;</small></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><p ALIGN="CENTER"><small>Имя</small></td>
    <td WIDTH="22%" VALIGN="TOP"><p ALIGN="CENTER"><small>Тип
    данных</small></td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>R/W</small></td>
    <td WIDTH="45%" VALIGN="TOP"><p ALIGN="CENTER"><small>Описание</small></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><small>ipRouteDest</small></td>
    <td WIDTH="22%" VALIGN="TOP"><small>IpAddress</small></td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="45%" VALIGN="TOP"><small>IP адрес назначения.
    Значение 0.0.0.0 указывает на пункт по умолчанию.</small></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><small>ipRouteIfIndex</small></td>
    <td WIDTH="22%" VALIGN="TOP"><small>INTEGER</small></td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="45%" VALIGN="TOP"><small>Номер интерфейса:
    ifIndex.</small></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><small>ipRouteMetric1</small></td>
    <td WIDTH="22%" VALIGN="TOP"><small>INTEGER</small></td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="45%" VALIGN="TOP"><small>Первичный
    показатель маршрута. Значение показателя
    зависит от протокола маршрутизации (ipRouteProto).
    Значение -1 означает, что маршрут не используется.</small></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><small>ipRouteMetric2</small></td>
    <td WIDTH="22%" VALIGN="TOP"><small>INTEGER</small></td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="45%" VALIGN="TOP"><small>Альтернативный
    показатель маршрута.</small></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><small>ipRouteMetric3</small></td>
    <td WIDTH="22%" VALIGN="TOP"><small>INTEGER</small></td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="45%" VALIGN="TOP"><small>Альтернативный
    показатель маршрута.</small></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><small>ipRouteMetric4</small></td>
    <td WIDTH="22%" VALIGN="TOP"><small>INTEGER</small></td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="45%" VALIGN="TOP"><small>Альтернативный
    показатель маршрута.</small></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><small>ipRouteNextHop</small></td>
    <td WIDTH="22%" VALIGN="TOP"><small>IpAddress</small></td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="45%" VALIGN="TOP"><small>IP адрес
    маршрутизатора следующей пересылки.</small></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><small>ipRouteType</small></td>
    <td WIDTH="22%" VALIGN="TOP"><small>INTEGER</small></td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="45%" VALIGN="TOP"><small>Тип маршрута:
    1=другой, 2=недействующий маршрут, 3=прямой,
    4=непрямой.</small></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><small>ipRouteProto</small></td>
    <td WIDTH="22%" VALIGN="TOP"><small>INTEGER</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="45%" VALIGN="TOP"><small>Протокол
    маршрутизации: 1=другой, 4=ICMP перенаправление, 8=RIP,
    13=OSPF, 14=BGP и другие.</small></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><small>ipRouteAge</small></td>
    <td WIDTH="22%" VALIGN="TOP"><small>INTEGER</small></td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="45%" VALIGN="TOP"><small>Количество секунд,
    которое прошло с того момента, когда маршрут был
    последний раз обновлен или определен как
    корректный.</small></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><small>ipRouteMask</small></td>
    <td WIDTH="22%" VALIGN="TOP"><small>IpAddress</small></td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="45%" VALIGN="TOP"><small>Маска, которая
    должна быть добавлена по логическому И к IP адресу
    назначения, перед тем как она будет сравнена с
    ipRouteDest.</small></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><small>ipRouteMetric5</small></td>
    <td WIDTH="22%" VALIGN="TOP"><small>INTEGER</small></td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="45%" VALIGN="TOP"><small>Альтернативный
    показатель маршрута.</small></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><small>ipRouteInfo</small></td>
    <td WIDTH="22%" VALIGN="TOP"><small>ObjectID</small></td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="45%" VALIGN="TOP"><small>Ссылка на
    конкретное определение MIB для этого протокола
    маршрутизации.</small></td>
  </tr>
</table>


<p><small>Рисунок 25.23 Таблица IP маршрутизации:
ipRouteTable.&nbsp;</small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="809">
  <tr>
    <td WIDTH="18%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Dest</small></td>
    <td WIDTH="12%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>IfIndex</small></td>
    <td WIDTH="18%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>NextHop</small></td>
    <td WIDTH="16%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Type</small></td>
    <td WIDTH="14%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Proto</small></td>
    <td WIDTH="21%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Mask</small></td>
  </tr>
  <tr>
    <td WIDTH="18%" VALIGN="TOP"><small>0.0.0.0</small></td>
    <td WIDTH="12%" VALIGN="TOP"><p ALIGN="CENTER"><small>2</small></td>
    <td WIDTH="18%" VALIGN="TOP"><small>140.252.1.183</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>непрямой
    (4)</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>другой (1)</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>0.0.0.0</small></td>
  </tr>
  <tr>
    <td WIDTH="18%" VALIGN="TOP"><small>127.0.0.1</small></td>
    <td WIDTH="12%" VALIGN="TOP"><p ALIGN="CENTER"><small>3</small></td>
    <td WIDTH="18%" VALIGN="TOP"><small>127.0.0.1</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>прямой (3)</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>другой (1)</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>255.255.255.255</small></td>
  </tr>
  <tr>
    <td WIDTH="18%" VALIGN="TOP"><small>140.252.1.183</small></td>
    <td WIDTH="12%" VALIGN="TOP"><p ALIGN="CENTER"><small>2</small></td>
    <td WIDTH="18%" VALIGN="TOP"><small>140.252.1.29</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>прямой (3)</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>другой (1)</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>255.255.255.255</small></td>
  </tr>
  <tr>
    <td WIDTH="18%" VALIGN="TOP"><small>140.252.13.32</small></td>
    <td WIDTH="12%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="18%" VALIGN="TOP"><small>140.252.13.33</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>прямой (3)</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>другой (1)</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>255.255.0.0</small></td>
  </tr>
  <tr>
    <td WIDTH="18%" VALIGN="TOP"><small>140.252.13.65</small></td>
    <td WIDTH="12%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="18%" VALIGN="TOP"><small>140.252.13.35</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>непрямой
    (4)</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>другой (1)</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>255.255.255.255</small></td>
  </tr>
</table>


<p><small>Рисунок 25.24 Таблица IP маршрутизации
маршрутизатора sun.</small></p>

<p>&nbsp;</p>

<p><small>Для сравнения здесь приводится таблица
маршрутизации IP в формате вывода команды <a NAME="t258023"></a>netstat (см. главу 9, раздел <a HREF="tcp09.html#t092000">&quot;Принципы
маршрутизации&quot;</a>). На рисунке 25.24 таблица
маршрутизации приводится в лексикографическом
порядке:</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>netstat -rn</b><br>
Routing tables<br>
Destination&nbsp;&nbsp;&nbsp;&nbsp; Gateway
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Flags&nbsp;&nbsp; Refcnt&nbsp;&nbsp; Use
&nbsp;&nbsp;&nbsp; Interface<br>
140.252.13.65&nbsp;&nbsp; 140.252.13.35&nbsp;&nbsp; UGH&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 115&nbsp;&nbsp;&nbsp; le0<br>
127.0.0.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 127.0.0.1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1107&nbsp;&nbsp; lo0<br>
140.252.1.183&nbsp;&nbsp; 140.252.1.29&nbsp;&nbsp;&nbsp; UH
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 86
&nbsp;&nbsp;&nbsp;&nbsp; sl0<br>
default&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 140.252.1.183&nbsp;&nbsp; UG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1628
&nbsp;&nbsp; sl0<br>
140.252.13.32&nbsp;&nbsp; 140.252.13.33&nbsp;&nbsp; U
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 68359
&nbsp; le0<br>
</p>


<p>&nbsp;</p>

<p><small>И последняя таблица для группы ip это
таблица трансляции адресов, приведенная на
рисунке 25.25. Как мы говорили раньше, группа at в
настоящее время практически не используется (как
устаревшая), и эта таблица заменяет ее.<a NAME="t258024"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="825">
  <tr>
    <td VALIGN="TOP" COLSPAN="4" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Таблица
    трансляции IP адресов, индекс =
    &lt;ipNetToMediaIfIndex&gt;.&lt;ipNetToMediaNetAddress&gt;</small></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP" BGCOLOR="#ffffff"><small>Имя</small></td>
    <td WIDTH="21%" VALIGN="TOP" BGCOLOR="#ffffff"><small>Тип
    данных </small></td>
    <td WIDTH="6%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>R/W</small></td>
    <td WIDTH="37%" VALIGN="TOP" BGCOLOR="#ffffff"><small>Описание</small></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><small>ipNetToMediaIfIndex</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>INTEGER</small></td>
    <td WIDTH="6%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="37%" VALIGN="TOP"><small>Соответствующий
    интерфейс: ifIndex.</small></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><small>ipNetToMediaPhysAddress</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>PhysAddress</small></td>
    <td WIDTH="6%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="37%" VALIGN="TOP"><small>Физический адрес.</small></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><small>ipNetToMediaNetAddress</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>IpAddress</small></td>
    <td WIDTH="6%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="37%" VALIGN="TOP"><small>IP адрес.</small></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><small>ipNetToMediaType</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>[1..4]</small></td>
    <td WIDTH="6%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="37%" VALIGN="TOP"><small>Тип сопоставления:
    1=другой, 2=неиспользуемый, 3=динамический,
    4=статический.</small></td>
  </tr>
</table>


<p><small>Рисунок 25.25 Таблица трансляции IP адресов:
ipNetToMediaTable.</small></p>

<p>&nbsp;</p>

<p><small>Здесь мы приводим <a NAME="t258025"></a>ARP кэш системы
sun:</small></p>

<p>&nbsp;</p>


<p>sun % <b>arp -a<br>
</b>svr4 (140.252.13.34) at 0:0:c0:c2:9b:26<br>
bsdi (140.252.13.35) at 0:0:c0:6f:2d:40&nbsp;</p>

<p>&nbsp;</p>

<p><small>и соответствующий SNMP вывод:</small></p>

<p>&nbsp;</p>


<p>sun % <b>snmpi -a sun dump ipNetToMediaTable<br>
<br>
</b>ipNetToMediaIfIndex.1.140.252.13.34=1<br>
ipNetToMediaIfIndex.1.140.252.13.35=1<br>
ipNetToMediaPhysAddress.1.140.252.13.34=0x00:00:c0:c2:9b:26<br>
ipNetToMediaPhysAddress.1.140.252.13.35=0x00:00:c0:6f:2d:40<br>
ipNetToMediaNetAddress.1.140.252.13.34=140.252.13.34<br>
ipNetToMediaNetAddress.1.140.252.13.35=140.252.13.35<br>
ipNetToMediaType.1.140.252.13.34=dynamic(3)<br>
ipNetToMediaType.1.140.252.13.35=dynamic(3)&nbsp;</p>

<p>&nbsp;</p>
<i><b>

<p><a NAME="t258026"></a>Группа icmp</p>
</b></i>

<p><small>Группа icmp состоит из четырех общих
счетчиков (общее количество входящих и исходящих
ICMP сообщений и количество входящих и исходящих
ICMP сообщений с ошибками) и 22-х счетчиков для
различных типов ICMP сообщений: 11 счетчиков на
входящие сообщения и 11 счетчиков на исходящие
сообщения. Это показано на рисунке 25.26. </small></p>

<p><small>Для ICMP сообщений с дополнительными кодами
(обратитесь к <a HREF="tcp06.html#t062001">рисунку 6.3</a>, на
котором приведены 15 различных кодов для
сообщения о недостижимости пункта назначения)
отдельный счетчик для каждого SNMP кода не
поддерживается.</small></p>
<i><b>

<p><a NAME="t258027"></a>Группа tcp</p>
</b></i>

<p><small>На рисунке 25.27 описаны простые переменные
группы tcp. Многие из них соответствуют состояниям
TCP, которые показаны на <a HREF="tcp18.html#t186001">рисунке
18.12</a>.<a NAME="t258028"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="826">
  <tr>
    <td WIDTH="31%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Имя</small></td>
    <td WIDTH="17%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Тип
    данных</small></td>
    <td WIDTH="7%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>R/W</small></td>
    <td WIDTH="44%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Описание</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpInMsgs</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Полное количество
    принятых ICMP сообщений.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpInErrors</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Количество
    принятых ICMP сообщений с ошибками (например,
    ошибочная <a NAME="t258029"></a>контрольная сумма ICMP).</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpInDestUnreachs</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Количество
    принятых ICMP сообщений о недоступности источника.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpInTimeExcds</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Количество
    принятых ICMP сообщений об истечении времени.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpInParmProbs</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Количество
    принятых ICMP сообщений о проблемах с параметром.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpInSrcQuenchs</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Количество
    принятых ICMP сообщений о подавлении источника.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpInRedirects</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Количество
    принятых ICMP сообщений о перенаправлении.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpInEchos</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Количество
    принятых ICMP сообщений с эхо запросом.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpInEchoReps</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Количество
    принятых ICMP сообщений с эхо откликом.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpInTimestamps</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Количество
    принятых ICMP сообщений с запросом временной
    марки.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpInTimestampReps</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Количество
    принятых ICMP сообщений с откликом временной
    марки.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpInAddrMasks</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Количество
    принятых ICMP сообщений с запросом маски адреса.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpInAddrMaskReps</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Количество
    принятых ICMP сообщений с откликом маски адреса.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpOutMsgs</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Полное количество
    исходящих ICMP сообщений.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpOutErrors</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Количество ICMP
    сообщений, которые не были отправлены из-за
    проблем внутри ICMP (переполнение буферов).</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpOutDestUnreachs</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Количество
    посланных ICMP сообщений о недоступности пункта
    назначения.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpOutTimeExcds</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Количество
    посланных ICMP сообщений об истечении времени.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpOutParmProbs</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Количество
    посланных ICMP сообщений о проблемах с параметром.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpOutSrcQuenchs</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Количество
    посланных ICMP сообщений о подавлении источника.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpOutRedirects</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Количество
    посланных ICMP сообщений о перенаправлении.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpOutEchos</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Количество
    посланных ICMP сообщений с эхо запросом. </small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpOutEchoReps</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Количество
    посланных ICMP сообщений с эхо откликом.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpOutTimestamps</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Количество
    посланных ICMP сообщений с запросом временной
    марки.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpOutTimestampReps</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Количество
    посланных ICMP сообщений с откликом временной
    марки.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpOutAddrMasks</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Количество
    посланных ICMP сообщений с запросом маски адреса.</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>icmpOutAddrMaskReps</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="44%" VALIGN="TOP"><small>Количество
    посланных ICMP сообщений с откликом маски адреса.</small></td>
  </tr>
</table>


<p><small>Рисунок 25.26 Простые переменные группы icmp.</small></p>

<p>&nbsp;</p>

<p><small>Мы можем запросить некоторые из этих
переменных для системы sun:</small></p>

<p>&nbsp;</p>


<p>sun % <b>snmpi -a sun<br>
<br>
</b>snmpi&gt; <b>get tcpRtoAlgorithm.0 tcpRtoMin.0 tcpRtoMax.0 tcpMaxConn.0<br>
</b>tcpRtoAlgorithm.0=vanj(4)<br>
tcpRtoMin.0=200<br>
tcpRtoMax.0=12800<br>
tcpMaxConn.0=-1&nbsp;</p>

<p>&nbsp;</p>

<p><small>Система <a NAME="t258030"></a>SunOS 4.1.3 использует
алгоритм тайм-аута и повторной передачи,
разработанный <a NAME="t258031"></a>Van Jacobson, при этом
используемые тайм-ауты находятся в диапазоне от
200 миллисекунд до 12,8 секунд, и не существует
фиксированного предела для количества TCP
соединений. (Верхняя граница диапазона,
составляющая 12,8 секунды, неверна, так как
большинство реализаций используют верхний
предел в 64 секунды, как мы видели в <a HREF="tcp21.html">главе
21</a>.) </small></p>

<p><small>Группа tcp имеет одну таблицу, таблицу TCP
соединений, показанную на рисунке 25.28. Она
содержит по одной строке для каждого соединения.
Каждая строка содержит пять переменных:
состояние соединения, локальный IP адрес,
локальный номер порта, удаленный IP адрес и
удаленный номер порта.<a NAME="t258032"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="702">
  <tr>
    <td WIDTH="32%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Имя</small></td>
    <td WIDTH="24%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Тип
    данных</small></td>
    <td WIDTH="8%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>R/W</small></td>
    <td WIDTH="36%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Описание</small></td>
  </tr>
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><small>tcpRtoAlgorithm</small></td>
    <td WIDTH="24%" VALIGN="TOP"><small>INTEGER</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="36%" VALIGN="TOP"><small>Алгоритм,
    используемый для расчета величин тайм-аутов и
    повторных передач: 1=нет, 2=постоянный RTO, 3=MIL-STD-1778 (<a HREF="tcp_b.html">приложение B</a>), 4=алгоритм Van Jacobson.</small></td>
  </tr>
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><small>tcpRtoMin</small></td>
    <td WIDTH="24%" VALIGN="TOP"><small>INTEGER</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="36%" VALIGN="TOP"><small>Минимальное
    значение тайм-аута повторной передачи, в
    миллисекундах.</small></td>
  </tr>
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><small>tcpRtoMax</small></td>
    <td WIDTH="24%" VALIGN="TOP"><small>INTEGER</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="36%" VALIGN="TOP"><small>Максимальное
    значение тайм-аута повторной передачи, в
    миллисекундах.</small></td>
  </tr>
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><small>tcpMaxConn</small></td>
    <td WIDTH="24%" VALIGN="TOP"><small>INTEGER</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="36%" VALIGN="TOP"><small>Максимальное
    количество TCP соединений. Значение -1 обозначает,
    что эта величина определяется динамически.</small></td>
  </tr>
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><small>tcpActiveOpens</small></td>
    <td WIDTH="24%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="36%" VALIGN="TOP"><small>Количество
    переходов от состояния <a NAME="t258033"></a>CLOSED к
    состоянию SYN_SENT.</small></td>
  </tr>
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><small>tcpPassiveOpens</small></td>
    <td WIDTH="24%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="36%" VALIGN="TOP"><small>Количество
    переходов от состояния <a NAME="t258034"></a>LISTEN к
    состоянию SYN_RCVD.</small></td>
  </tr>
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><small>tcpAttemptFails</small></td>
    <td WIDTH="24%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="36%" VALIGN="TOP"><small>Количество
    переходов от состояния SYN_SENT или SYN_RCVD к состоянию
    CLOSED, плюс количество переходов от состояния SYN_RCVD
    к состоянию LISTEN.</small></td>
  </tr>
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><small>tcpEstabResets</small></td>
    <td WIDTH="24%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="36%" VALIGN="TOP"><small>Количество
    переходов от состояния ESTABLISHED или <a NAME="t258035"></a>CLOSE_WAIT
    к состоянию CLOSED.</small></td>
  </tr>
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><small>tcpCurrEstab</small></td>
    <td WIDTH="24%" VALIGN="TOP"><small>Gauge</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="36%" VALIGN="TOP"><small>Количество
    соединений, находящихся в настоящее время в
    состоянии ESTABLISHED или CLOSE_WAIT.</small></td>
  </tr>
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><small>tcpInSegs</small></td>
    <td WIDTH="24%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="36%" VALIGN="TOP"><small>Полное количество
    принятых сегментов.</small></td>
  </tr>
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><small>tcpOutSegs</small></td>
    <td WIDTH="24%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="36%" VALIGN="TOP"><small>Полное количество
    отправленных сегментов, за исключением тех,
    которые содержали только повторно передаваемые
    байты.</small></td>
  </tr>
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><small>tcpRetransSegs</small></td>
    <td WIDTH="24%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="36%" VALIGN="TOP"><small>Полное количество
    повторно переданных сегментов.</small></td>
  </tr>
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><small>tcpInErrs</small></td>
    <td WIDTH="24%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="36%" VALIGN="TOP"><small>Полное количество
    сегментов, принятых с ошибками (например,
    неверная <a NAME="t258036"></a>контрольная сумма).</small></td>
  </tr>
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><small>tcpOutRsts</small></td>
    <td WIDTH="24%" VALIGN="TOP"><small>Counter</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="36%" VALIGN="TOP"><small>Полное количество
    сегментов, посланных с установленным флагом RST.</small></td>
  </tr>
</table>


<p><small>Рисунок 25.27 Простые переменные в группе tcp. </small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="838">
  <tr>
    <td VALIGN="TOP" COLSPAN="4" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>индекс
    =
    &lt;tcpConnLocalAddress&gt;.&lt;tcpConnLocalPort&gt;.&lt;tcpConnRemAddress&gt;.&lt;tcpConnRemPort&gt;</small></td>
  </tr>
  <tr>
    <td WIDTH="30%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Имя</small></td>
    <td WIDTH="21%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Тип
    данных</small></td>
    <td WIDTH="7%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>R/W</small></td>
    <td WIDTH="42%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Описание</small></td>
  </tr>
  <tr>
    <td WIDTH="30%" VALIGN="TOP"><small>tcpConnState</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>[1..12]</small></td>
    <td WIDTH="7%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="42%" VALIGN="TOP"><small>Состояние
    соединения: 1=CLOSED, 2=LISTEN, 3=<a NAME="t258037"></a>SYN_SENT, 4=<a NAME="t258038"></a>SYN_RCVD, 5=<a NAME="t258039"></a>ESTABLISHED, 6=<a NAME="t258040"></a>FIN_WAIT_1,
    7=<a NAME="t258041"></a>FIN_WAIT_2, 8=CLOSE_WAIT, 9=<a NAME="t258042"></a>LAST_ACK, 10=<a NAME="t258043"></a>CLOSING, 11=<a NAME="t258044"></a>TIME_WAIT, 12=удаление TCB.
    Единственное значение, которое может установить
    менеджер, это значение 12 (немедленное
    прекращение соединения).</small></td>
  </tr>
  <tr>
    <td WIDTH="30%" VALIGN="TOP"><small>tcpConnLocalAddress</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>IpAddress</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="42%" VALIGN="TOP"><small>Локальный IP адрес.
    0.0.0.0 указывает на то, что слушающий процесс готов
    принять соединение с любого интерфейса.</small></td>
  </tr>
  <tr>
    <td WIDTH="30%" VALIGN="TOP"><small>tcpConnLocalPort</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>[0..65535]</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="42%" VALIGN="TOP"><small>Локальный номер
    порта.</small></td>
  </tr>
  <tr>
    <td WIDTH="30%" VALIGN="TOP"><small>tcpConnRemAddress</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>IpAddress</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="42%" VALIGN="TOP"><small>Удаленный IP адрес.</small></td>
  </tr>
  <tr>
    <td WIDTH="30%" VALIGN="TOP"><small>tcpConnRemPort</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>[0..65535]</small></td>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="42%" VALIGN="TOP"><small>Удаленный номер
    порта.</small></td>
  </tr>
</table>


<p><small>Рисунок 25.28 Таблица TCP соединений: tcpConnTable. </small></p>

<p>&nbsp;</p>

<p><small>Давайте посмотрим эту таблицу на системе sun.
Мы показали только часть таблицы, так как очень
много серверов (в данном случае слушающие
процессы) слушает запросы на соединения. Перед
тем как получить таблицу, было установлено два TCP
соединения:</small></p>

<p>&nbsp;</p>


<p>sun % <b>rlogin gemini </b>IP адрес gemini равен 140.252.1.11</p>


<p>&nbsp;</p>

<p><small>и</small></p>

<p>&nbsp;</p>


<p>sun % <b>telnet localhost </b>IP адрес должен быть 127.0.0.1</p>


<p>&nbsp;</p>

<p><small>Единственный слушающий сервер, как мы
показали, это FTP сервер на порте 21:</small></p>

<p>&nbsp;</p>


<p>sun % <b>snmpi -a sun dump tcpConnTable<br>
<br>
</b>tcpConnState.0.0.0.0.21.0.0.0.0.0=listen(2)<br>
tcpConnState.127.0.0.1.23.127.0.0.1.1415=established(5)<br>
tcpConnState.127.0.0.1.1415.127.0.0.1.23=established(5)<br>
tcpConnState.140.252.1.29.1023.140.252.1.11.513=established(5)<br>
<br>
tcpConnLocalAddress.0.0.0.0.21.0.0.0.0.0=0.0.0.0<br>
tcpConnLocalAddress.127.0.0.1.23.127.0.0.1.1415=127.0.0.1<br>
tcpConnLocalAddress.127.0.0.1.1415.127.0.0.1.23=127.0.0.1<br>
tcpConnLocalAddress.140.252.1.29.1023.140.252.1.11.513=140.252.1.29<br>
<br>
tcpConnLocalPort.0.0.0.0.21.0.0.0.0.0=21<br>
tcpConnLocalPort.127.0.0.1.23.127.0.0.1.1415=23<br>
tcpConnLocalPort.127.0.0.1.1415.127.0.0.1.23=1415<br>
tcpConnLocalPort.140.252.1.29.1023.140.252.1.11.513=1023<br>
<br>
tcpConnRemAddress.0.0.0.0.21.0.0.0.0.0=0.0.0.0<br>
tcpConnRemAddress.127.0.0.1.23.127.0.0.1.1415=127.0.0.1<br>
tcpConnRemAddress.127.0.0.1.1415.127.0.0.1.23=127.0.0.1<br>
tcpConnRemAddress.140.252.1.29.1023.140.252.1.11.513=140.252.1.11<br>
<br>
tcpConnRemPort.0.0.0.0.21.0.0.0.0.0=0<br>
tcpConnRemPort.127.0.0.1.23.127.0.0.1.1415=1415<br>
tcpConnRemPort.127.0.0.1.1415.127.0.0.1.23=23<br>
tcpConnRemPort.140.252.1.29.1023.140.252.1.11.513=513&nbsp;</p>

<p>&nbsp;</p>

<p><small>Для команды rlogin на хост gemini присутствует
только один пункт, так как gemini это удаленный хост.
Мы видим только клиентскую часть соединения
(локальный порт 1023), однако показаны оба конца Telnet
соединения (порт клиента 1415 и порт сервера 23), так
как соединение проходит через <a NAME="t258045"></a>loopback
интерфейс. Также мы можем видеть, что слушающий FTP
сервер имеет локальный IP адрес 0.0.0.0, что
указывает на то, что он примет соединение с
любого интерфейса.</small></p>
<u><b>

<p><a NAME="t259000"></a>Дополнительные примеры</p>
</b></u>

<p><small>Сейчас мы вернемся к некоторым проблемам,
которые были рассмотрены раньше в этой книге, и
попробуем использовать SNMP, для того чтобы понять,
что все-таки произошло.</small></p>
<i><b>

<p>MTU интерфейса</p>
</b></i>

<p><small>Вернемся к нашему эксперименту, описанному
в разделе <a HREF="tcp11.html#t116000">&quot;ICMP ошибки о
недоступности&quot;</a> главы 11, в котором мы
пытались определить MTU SLIP канала от netb к sun. Сейчас
мы можем использовать SNMP, чтобы получить этот MTU.
Во-первых, мы получим номер интерфейса (ipRouteIfIndex)
для SLIP канала (140.252.1.29) из таблицы IP маршрутизации.
Для этого, мы попадаем в таблицу интерфейсов и
получаем MTU (вместе с описанием и типом) канала SLIP:</small></p>

<p>&nbsp;</p>


<p>sun % <b>snmpi -a netb -c secret<br>
<br>
</b>snmpi&gt; <b>get ipRouteIfIndex.140.252.1.29<br>
</b>ipRouteIfIndex.140.252.1.29=12<br>
snmpi&gt; <b>get ifDescr.12 ifType.12 ifMtu.12<br>
</b>ifDescr.12=&quot;Telebit NetBlazer dynamic dial virtual interface&quot;<br>
ifType.12=other(1)<br>
ifMtu.12=1500&nbsp;</p>

<p>&nbsp;</p>

<p><small>Мы видим, что даже для канала, который
является SLIP, MTU установлено в Ethernet значение
равное 1500, возможно для того, чтобы избежать
фрагментации.</small></p>
<i><b>

<p><a NAME="t259001"></a>Таблицы маршрутизации</p>
</b></i>

<p><small>Давайте обратимся к нашему обсуждению
сортировки адресов, которая осуществляется DNS,
приведенному в разделе <a HREF="tcp14.html#t144000">&quot;Простой
пример&quot;</a> главы 14. Мы показали, как первый IP
адрес, возвращенный DNS сервером, был одним из тех,
что принадлежат к той же подсети, что и клиент.
Также мы упомянули, что использование другого IP
адреса, вполне возможно, будет работать, однако в
этом случае все будет менее эффективно. Давайте
посмотрим, что произойдет при использовании
альтернативного IP адреса. Мы будем использовать
SNMP, чтобы посмотреть пункты в таблице
маршрутизации, и попробуем объединить вместе
несколько концепций, о которых мы рассказывали в
предыдущих главах и которые имели отношение к IP
маршрутизации. </small></p>

<p><small>Хост gemini имеет <a NAME="t259002"></a>несколько
интерфейсов, два из которых Ethernet интерфейсы.
Во-первых, убедимся, что можем получить
соединение Telnet на оба адреса:</small></p>

<p>&nbsp;</p>


<p>sun % <b>telnet 140.252.1.11 daytime<br>
</b>Trying 140.252.1.11 ...<br>
Connected to 140.252.1.11.<br>
Escape character is '^]'.<br>
Sat Mar 27 09:37:24 1993<br>
Connection closed by foreign host.<br>
<br>
sun % <b>telnet 140.252.3.54 daytime<br>
</b>Trying 140.252.3.54 ...<br>
Connected to 140.252.3.54.<br>
Escape character is '^]'.<br>
Sat Mar 27 09:37:35 1993<br>
Connection closed by foreign host.</p>


<p>&nbsp;</p>

<p><small>Мы видим, что нет никакой разницы в
соединениях между двумя адресами. Сейчас
воспользуемся traceroute, чтобы посмотреть,
используются ли различные маршруты к каждому
адресу:</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>traceroute 140.252.1.11</b><br>
traceroute to 140.252.1.11 (140.252.1.11), 30 hops max, 40 byte packets<br>
&nbsp;&nbsp; 1 netb (140.252.1.183) 299 ms 234 ms 233 ms<br>
&nbsp;&nbsp; 2 gemini (140.252.1.11) 233 ms 228 ms 234 ms<br>
<br>
sun % <b>traceroute 140.252.3.54</b><br>
traceroute to 140.252.3.54 (140.252.3.54), 30 hops max, 40 byte packets<br>
&nbsp;&nbsp; 1 netb (140.252.1.183) 245 ms 212 ms 234 ms<br>
&nbsp;&nbsp; 2 swnrt (140.252.1.6) 233 ms 229 ms 234 ms<br>
&nbsp;&nbsp; 3 gemini (140.252.3.54) 234 ms 233 ms 234 ms<br>
</p>


<p>&nbsp;</p>

<p><small>Мы видим, что при использовании адреса
подсети 140.252.3 появляется дополнительная
пересылка (маршрутизатор swnrt - это R3 на <a HREF="tcp03.html#t034001">рисунке 3.6</a>). Давайте посмотрим,
почему осуществляется эта дополнительная
пересылка. </small></p>

<p><small>На рисунке 25.29 показаны настройки систем. На
основе вывода команды traceroute мы можем сказать, что
хост gemini и маршрутизатор swnrt оба подсоединены к
двум сетям: 140.252.1 и 140.252.3.<a NAME="t259003"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t25_2900.jpg" WIDTH="245" HEIGHT="279"></small></p>


<p ALIGN="CENTER"><small>Рисунок 25.29 Топология систем,
которые используются в примере.</small></p>

<p>&nbsp;</p>

<p><small>Обратитесь к <a HREF="tcp04.html#t046001">рисунку 4.6</a>,
где мы объясняли, как маршрутизатор netb
использует уполномоченного агента ARP, для того
чтобы создалось впечатление, как будто sun
непосредственно подключен к Ethernet 140.252.1. В наших
рассуждениях мы не принимаем во внимание модемы,
которые включены в SLIP канал между sun и netb, так как
это не влияет на наши рассуждения. </small></p>

<p><small>На рисунке 25.29 мы показали путь Telnet данных с
использованием пунктирных стрелок, в том случае,
когда был указан адрес 140.252.3.54. Как мы можем
узнать, что возвращающиеся пакеты проходят
непосредственно от gemini к netb, а не возвращаются
тем же самым путем, по которому они пришли?
Воспользуемся версией команды <a NAME="t259004"></a>traceroute
со свободной <a NAME="t259005"></a>маршрутизацией от
источника, которая описана в разделе <a HREF="tcp08.html#t085000">&quot;Опция IP маршрутизации от
источника&quot;</a> главы 8:</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>traceroute <a NAME="t259006"></a>-g 140.252.3.54 sun</b><br>
traceroute to sun (140.252.13.33), 30 hops max, 40 byte packets<br>
&nbsp;&nbsp; 1 netb (140.252.1.183) 244 ms 256 ms 234 ms<br>
&nbsp;&nbsp; 2 * * *<br>
&nbsp;&nbsp; 3 gemini (140.252.3.54) 285 ms 227 ms 234 ms<br>
&nbsp;&nbsp; 4 netb (140.252.1.183) 263 ms 259 ms 294 ms<br>
&nbsp;&nbsp; 5 sun (140.252.13.33) 534 ms 498 ms 504 ms<br>
</p>


<p>&nbsp;</p>

<p><small>Когда используется свободная
маршрутизация от источника, маршрутизатор swnrt
никогда не отвечает. Если посмотреть на ранний
вывод команды traceroute, без маршрутизации от
источника, мы увидим, что swnrt является второй
пересылкой. Причиной этого может являться то, что
маршрутизатор не генерирует <a NAME="t259007"></a>ICMP
ошибки об истечении времени, когда в датаграмме
установлена свободная маршрутизация от
источника. Мы видим из этого вывода команды
traceroute, что путь возврата от gemini (TTL 3, 4 и 5) проходит
непосредственно к netb, а не проходит через
маршрутизатор swnrt. </small></p>

<p><small>Вопрос, на который нам должен помочь
ответить SNMP, заключается в том, что делает пункт
таблицы маршрутизации в netb таким, что сеть
назначения установлена в 140.252.3? Все дело в том,
что netb отправляет пакеты к swnrt, а не
непосредственно к gemini. Мы используем команду get,
чтобы получить значение <a NAME="t259008"></a>маршрутизатора
следующей пересылки для этого пункта назначения:</small></p>

<p>&nbsp;</p>


<p>sun % <b>snmpi -a netb -c secret get
ipRouteNextHop.140.252.3.0<br>
<br>
</b>ipRouteNextHop.140.252.3.0=140.252.1.6&nbsp;</p>

<p>&nbsp;</p>

<p><small>Пункт таблицы маршрутизации говорит netb
послать пакеты на swnrt, что, как мы видим, и
происходит. </small></p>

<p><small>Почему gemini отправляет пакеты назад
непосредственно через netb? Потому что адрес
назначения для пакетов, возвращающихся от gemini,
установлен в 140.252.1.29, а сеть 140.252.1 подключена
непосредственно. </small></p>

<p><small>То, что мы видим в этом примере, является
результатом политических решений о
маршрутизации. Маршрут по умолчанию к сети 140.252.3
проходит через маршрутизатор swnrt, потому что gemini
является просто хостом с несколькими
интерфейсами, но не выполняет функции
маршрутизатора. <a NAME="t259009"></a>Это как раз пример
хоста с несколькими интерфейсами, который не
хочет быть маршрутизатором.</small></p>
<u><b>

<p><a NAME="t25A000"></a>Ловушки (Traps) </p>
</b></u>

<p><small>Все примеры, которые мы рассмотрели в этой
главе, иллюстрируют передачу информации от
менеджера к агенту. Однако у агента существует
способ сообщить менеджеру о возникновении
какого-либо события, о котором менеджер должен
знать (см. рисунок 25.1). В этом случае агент
посылает менеджеру ловушки (trap). Ловушки
отправляются на UDP порт 162 менеджера. </small></p>

<p><small>На рисунке 25.2 мы показали формат ловушки PDU.
Мы просмотрим все поля в этом сообщении, когда
ниже будем рассматривать вывод команды <a NAME="t25A001"></a>tcpdump.
</small></p>

<p><small>Определены шесть ловушек, седьмая
используется производителем, чтобы установить
собственную ловушку. На рисунке 25.30 описываются
значения типа ловушки (trap type) в сообщении ловушки
(рисунок 25.2).<a NAME="t25A002"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="815">
  <tr>
    <td WIDTH="12%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>тип
    ловушки</small></td>
    <td WIDTH="37%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Имя</small></td>
    <td WIDTH="52%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Описание</small></td>
  </tr>
  <tr>
    <td WIDTH="12%" VALIGN="TOP"><small>0</small></td>
    <td WIDTH="37%" VALIGN="TOP"><small>coldStart</small></td>
    <td WIDTH="52%" VALIGN="TOP"><small>Агент
    инициализировал себя сам.</small></td>
  </tr>
  <tr>
    <td WIDTH="12%" VALIGN="TOP"><small>1</small></td>
    <td WIDTH="37%" VALIGN="TOP"><small>warmStart</small></td>
    <td WIDTH="52%" VALIGN="TOP"><small>Агент повторно
    инициализировал себя сам.</small></td>
  </tr>
  <tr>
    <td WIDTH="12%" VALIGN="TOP"><small>2</small></td>
    <td WIDTH="37%" VALIGN="TOP"><small>linkDown</small></td>
    <td WIDTH="52%" VALIGN="TOP"><small>Состояние
    интерфейса изменилось с &quot;активизировано&quot; на
    &quot;выключено&quot; (рисунок 25.18). Первая переменная
    в сообщении указывает на интерфейс.</small></td>
  </tr>
  <tr>
    <td WIDTH="12%" VALIGN="TOP"><small>3</small></td>
    <td WIDTH="37%" VALIGN="TOP"><small>linkUp</small></td>
    <td WIDTH="52%" VALIGN="TOP"><small>Состояние
    интерфейса изменилось с состояния
    &quot;выключено&quot; на состояние
    &quot;активизировано&quot; (рисунок 25.18). Первая
    переменная в сообщении указывает на интерфейс.</small></td>
  </tr>
  <tr>
    <td WIDTH="12%" VALIGN="TOP"><small>4</small></td>
    <td WIDTH="37%" VALIGN="TOP"><small>authenticationFailure</small></td>
    <td WIDTH="52%" VALIGN="TOP"><small>Сообщение было
    получено от SNMP менеджера из неверного
    сообщества.</small></td>
  </tr>
  <tr>
    <td WIDTH="12%" VALIGN="TOP"><small>5</small></td>
    <td WIDTH="37%" VALIGN="TOP"><small>egpNeighborLoss</small></td>
    <td WIDTH="52%" VALIGN="TOP"><small>EGP узел изменил
    свое состояние на &quot;выключено&quot;. Первая
    переменная в сообщении содержит IP адрес узла.</small></td>
  </tr>
  <tr>
    <td WIDTH="12%" VALIGN="TOP"><small>6</small></td>
    <td WIDTH="37%" VALIGN="TOP"><small>enterpriseSpecific</small></td>
    <td WIDTH="52%" VALIGN="TOP"><small>Обратитесь к полю
    специализированных кодов за информацией об этой
    ловушке.</small></td>
  </tr>
</table>


<p><small>Рисунок 25.30 Типы ловушек.</small></p>

<p>&nbsp;</p>

<p><small>Мы можем увидеть некоторые ловушки с
помощью <a NAME="t25A003"></a>tcpdump. Стартуем SNMP агента на
системе sun и посмотрим, как он генерирует ловушку
coldStart. (Агент знает о необходимости посылать
ловушки на хост bsdi. Однако на bsdi не стартован
менеджер для обработки ловушек, вместо него
запущен tcpdump, что позволяет увидеть генерируемые
пакеты. Обратитесь к рисунку 25.1, откуда видно, что
ловушки посылаются от агента к менеджеру, однако
менеджер не посылает подтверждений, поэтому нет
необходимости, чтобы менеджер обрабатывал
ловушки.) Затем, с использованием программы <a NAME="t25A004"></a>snmpi, мы посылаем запрос, в котором
указано неверное имя сообщества. В ответ на это
должна быть сгенерирована ловушка authenticationFailure.
На рисунке 25.31 показан вывод.<a NAME="t25A005"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.snmp
&gt; bsdi.snmp-trap: C=traps Trap(28) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E:unix.1.2.5
[140.252.13.33] coldStart 20<br>
<br>
2&nbsp; 18.86 (18.86)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.snmp &gt; bsdi.snmp-trap:
C=traps Trap(29) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E:unix.1.2.5
[140.252.13.33] authenticationFailure 1907<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 25.31 Вывод команды tcpdump,
соответствующий генерации ловушек SNMP агентом.</small></p>

<p>&nbsp;</p>

<p><small>Во-первых, необходимо обратить внимание на
то, что обе UDP датаграммы, отправленные от SNMP
агента (порт 161, печатается как имя snmp), имеют порт
назначения 162 (печатается как имя snmp-trap). </small></p>

<p><small>Выражение C=traps это имя сообщества в
сообщении ловушки. Это опция конфигурации,
которая используется агентом в случае <a NAME="t25A006"></a>ISODE
SNMP. </small></p>

<p><small>Следующее выражение, Trap(28) в строке 1 и Trap(29) в
строке 2, это тип PDU (PDU type) и длина. </small></p>

<p><small>Следующее поле вывода для обеих строк -
E:unix.1.2.5. Это <a NAME="t25A007"></a>enterprise: идентификатор
системы объекта (sysObjectID). Он находится под узлом
1.3.6.1.4.1 в дереве, приведенном на рисунке 25.6
(iso.org.dod.internet.private.enterprises), таким образом,
идентификатор объекта агента равен 1.3.6.1.4.1.4.1.2.5.
Его сокращенное имя unix.agents.fourBSD-isode.5. Последняя
цифра (5) это номер версии релиза агента ISODE. Это
значение указывает на то, какое программное
обеспечение агента сгенерировало ловушку. </small></p>

<p><small>Следующее поле вывода команды <a NAME="t25A008"></a>tcpdump
это IP адрес агента (140.252.13.33). </small></p>

<p><small>Тип ловушки печатается как coldStart в строке 1 и
как authenticationFailure в строке 2. Они соответствуют
значениям типа ловушки равным 0 и 4
соответственно (рисунок 25.30). Так как эти ловушки
не являются специализированными (enterprise),
специфичный код (specific code) должен быть равен 0 и
поэтому не печатается. </small></p>

<p><small>Далее следует поле временной марки (timestamp),
которое печатается как 20 и 1907. Это значение TimeTicks,
соответствующее количеству сотых долей секунд с
момента инициализации агента. В случае ловушки
холодного старта, она генерируется через 200
миллисекунд после того, как агент
инициализирован. Вывод tcpdump указывает на то, что
вторая ловушка появилась через 18,86 секунды после
первой, чему соответствует напечатанное
значение 1907 сотых долей секунд минус 200
миллисекунд. </small></p>

<p><small>Из рисунка 25.2 видно, что сообщение ловушки
может содержать переменные, которые агенты хотят
отправить менеджеру, однако в наших примерах они
не присутствуют.</small></p>
<u><b>

<p><a NAME="t25B000"></a>ASN.1 и BER</p>
</b></u>

<p><small>Формальная спецификация SNMP использует
абстрактную форму записи (<a NAME="t25B001"></a>ASN.1 - Abstract
Syntax Notation 1), и кодирование бит в SNMP сообщениях
(рисунок 25.2) на основе основных правил
кодирования (<a NAME="t25B002"></a>BER - Basic Encoding Rules). В
отличие от большинства публикаций, описывающих
SNMP, мы специально оставили обсуждение ASN.1 и BER на
самый конец. Если рассказать о них в самом начале,
читатель может неправильно понять реальное
назначение SNMP - управление сетью. В этом разделе
мы дадим только краткий обзор этих двух тем.
Глава 8 [<a NAME="t25B003"></a>Rose 1990] описывает ASN.1 и BER более
подробно. </small></p>

<p><small>ASN.1 это формальный язык, который описывает
данные и характеристики данных. Он не определяет
то, как эти данные хранятся или кодируются. Все
поля в MIB и SNMP сообщениях описываются с
использованием ASN.1. Например, ASN.1 определение
типа данных IpAddress из SMI выглядит следующим
образом:</small></p>

<p>&nbsp;</p>


<p><br>
IpAddress ::=<br>
&nbsp;&nbsp;&nbsp;&nbsp; [APPLICATION 0] -- in network-byte order<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPLICIT OCTET STRING (SIZE(4))<br>
</p>


<p>&nbsp;</p>

<p><small>Точно так же, в MIB мы находим следующее
определение простых переменных:</small></p>

<p>&nbsp;</p>


<p><br>
udpNoPorts OBJECT-TYPE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SYNTAX
Counter<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACCESS
read-only<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STATUS
mandatory<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DESCRIPTION<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;The
total number of received UDP datagrams for which there <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; was
no application at the destination port.&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=
{ udp 2 }<br>
</p>


<p>&nbsp;</p>

<p><small>Определение таблиц, использующих SEQUENCE и
SEQUENCE OF, более сложное. </small></p>

<p><small>С использованием подобных ASN.1 определений
существует множество способов закодировать
данные в поток битов при передаче. SNMP использует
BER. Для представления маленьких целых чисел,
таких как 64, с использованием BER требуется 3 байта.
Один байт содержит значение целого, следующий
байт говорит, сколько байтов используется, чтобы
хранить целое (1), и последний байт содержит
двоичное значение. </small></p>

<p><small>К счастью, подробности ASN.1 и BER важны только
для разработчиков SNMP. Они не обязательны для
понимания того, как осуществляется управление
сетью.</small></p>
<u><b>

<p><a NAME="t25C000"></a>SNMP версии 2 (SNMP Version 2) </p>
</b></u>

<p><small>В течение 1993 года было опубликовано 11 RFC,
которые определяли новые стандарты SNMP. Первый из
них, RFC 1441 [<a NAME="t25C001"></a>Case et al. 1993], является
введением в SNMP версии 2 (SNMPv2). Две книги также
описывают SNMPv2 <a NAME="t25C002"></a>[Stallings 1993; Rose 1994]. В
настоящее время существуют две доступные
реализации (см. приложение В.3 публикации [<a NAME="t25C003"></a>Rose 1994]), однако коммерческие
реализации, возможно, не будут широко доступны до
1994 года. </small></p>

<p><small>В этом разделе мы опишем основные отличия
SNMPv1 от SNMPv2.</small></p>

<p><small>Новый тип пакетов <a NAME="t25C004"></a>get-bulk-request
позволяет менеджеру эффективно обрабатывать
большие блоки данных. Еще один новый тип пакетов <a NAME="t25C005"></a>inform-request позволяет одному менеджеру
посылать информацию другому менеджеру.
Определены два новых MIB: MIB SNMPv2 и MIB SNMPv2-M2M
(менеджер-менеджер). SNMPv2 предоставляет
улучшенную секретность по сравнению с SNMPv1. В SNMPv1
имя сообщества передается от менеджера к агенту <a NAME="t25C006"></a>в виде открытого пароля. SNMPv2
предоставляет аутентификацию и расширенную
секретность.</small></p>

<p><small>Все производители начинают реализовывать
агентов, совместимых с SNMPv2, а также появляются
управляющие станции, которые могут использовать
оба стандарта. [<a NAME="t25C007"></a>Routhier 1993] описывает
расширения и улучшения SNMPv1, которые призваны
обеспечить совместимость и поддержку SNMPv2.</small></p>
<u><b>

<p><a NAME="t25D000"></a>Краткие выводы</p>
</b></u>

<p><small>SNMP это простой протокол, основанный на
запросах и откликах, предназначенный для обмена
между SNMP менеджером и SNMP агентом. Информационная
база данных управления (MIB) определяет
переменные, которые обслуживаются агентом,
которые, в свою очередь, менеджер может либо
запросить, либо установить. Для определения
переменных используется ограниченное
количество типов данных. </small></p>

<p><small>Все переменные идентифицируются
идентификаторами объекта, используется
иерархическая схема присвоения имен, которая
состоит из длинных строк чисел, которые обычно
сокращаются в простые имена, для простоты чтения.
Конкретные переменные строятся с помощью
добавления переменной к идентификатору объекта. </small></p>

<p><small>Большинство SNMP переменных содержится в
таблицах, с фиксированными номерами колонок,
однако с переменными номерами строк.
Фундаментальным для SNMP является схема
идентификации, используемая для того, чтобы
идентифицировать каждую строку в таблице (в том
случае, когда мы не знаем, сколько строк
содержится в таблице), и <a NAME="t25D002"></a>лексикографический
порядок (порядок колонка-строка). SNMP оператор
get-next является основным для любого SNMP менеджера. </small></p>

<p><small>Мы описали следующие группы SNMP переменных:
система, интерфейс, трансляция адресов, IP, ICMP, TCP и
UDP. Затем показали два примера, один из которых
позволил определить MTU интерфейса, а другой -
просмотреть таблицу маршрутизации
маршрутизатора. </small></p>

<p><small>Мы завершили главу рассмотрением SNMP
ловушек. Это способ, предоставляющий агенту
возможность уведомить менеджера о том, что
произошло какое-либо событие, которое будет
интересно менеджеру. Здесь же кратко описаны ASN.1
и BER. Две последние темы, скорее всего, являются
наиболее сложными аспектами SNMP, однако они
необходимы только для разработчиков.</small></p>
<i><b>

<p><a NAME="t25D001"></a>Упражнения</b></i> 

<ol>
  <li>Мы сказали, что использование двух
    различных портов (161 и 162) позволяет системе
    запускать как менеджера, так и агента. Что
    произойдет, если будет использоваться один и тот
    же порт?</li>
  <li>Как Вы можете получить полный список таблицы
    маршрутизации с использованием get-next?</li>
</ol>

<hr>

</body>
</html>

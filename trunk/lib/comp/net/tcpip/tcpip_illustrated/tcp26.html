<html>

<head>
<title>Telnet и Rlogin: удаленный терминал</title>

<meta http-equiv="Content-type" content="text/html; charset=koi8-r">
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>


<b>

<p><a NAME="t260000"></a>Глава 26 Telnet и Rlogin: удаленный
терминал</p>
<u>

<p><a NAME="t261000"></a>Введение</p>
</u></b>

<p><small>Приложения, позволяющие осуществить заход
удаленным терминалом, очень популярны в Internet.
Отпадает необходимость иметь аппаратный
терминал к каждому хосту, можно зайти терминалом
на один хост, затем удаленным терминалом по сети
на любой другой хост (в том случае, если на этом
хосте существует открытый бюджет). </small></p>

<p><small>В сетях TCP/IP существуют два приложения,
позволяющие осуществить терминальный заход.</small>

<ol>
  <li><small>Telnet - стандартное приложение, которое
    присутствует практически в каждой реализации
    TCP/IP. Оно может быть использовано для связи между
    хостами, работающими пол управлением различных
    операционных систем. Telnet использует
    согласование опций клиента и сервера, чтобы
    определить, какие характеристики присутствуют с
    той и с другой стороны.</small></li>
  <li><small>Программа Rlogin происходит из Berkeley Unix и была
    разработана для того, чтобы работать только
    между Unix системами, однако впоследствии эта
    программа была перенесена и на другие
    операционные системы.</small></li>
</ol>

<p><small>В этой главе рассматривается и Telnet, и Rlogin. Мы
начнем с Rlogin, потому что это приложение работает
проще.</small></p>

<p>&nbsp;</p>


<p>Telnet это одно из
старейших приложений Internet. Оно появилось в 1969
году в <a NAME="t261001"></a>ARPANET. Имя этого приложения
является сокращением от &quot;сетевой
коммуникационный протокол&quot; (telecommmunications network
protocol).</p>


<p>&nbsp;</p>

<p><small>Приложения удаленного терминала
используют стандарт клиент-сервер. На рисунке 26.1
показано типичное общение Telnet клиента и Telnet
сервера. (Точно такой же рисунок можно нарисовать
для Rlogin клиента и Rlogin сервера.)<a NAME="t261002"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t26_1000.jpg" WIDTH="516" HEIGHT="189"></small></p>


<p ALIGN="CENTER"><small>Рисунок 26.1 Описание работы Telnet
клиент-сервер.</small></p>

<p>&nbsp;</p>

<p><small>Существует несколько моментов, на которые
необходимо обратить внимание на этом рисунке.</small>

<ul>
  <li><small>Клиент Telnet взаимодействует и с
    пользователем, находящимся за терминалом, и с
    протоколами TCP/IP. Обычно, все что пользователь
    вводит с клавиатуры отправляется по TCP
    соединению, а все что приходит по соединению
    попадает на терминал. </small></li>
  <li><small>Сервер Telnet обычно взаимодействует с так
    называемыми <a NAME="t261003"></a>псевдотерминальными
    устройствами (pseudo-terminal), по крайней мере в Unix
    системах. Это делает его похожим на командный
    интерпритатор (shell), который запускается на
    сервере, или на любую программу, которая
    запускается из shellа, так как именно они общаются с
    терминальными устройствами. Некоторые
    приложения, например, полноэкранные редакторы,
    считают, что они общаются с терминальным
    устройством. И действительно, заставить shell на
    сервере считать, что он общается с терминалом,
    является наиболее сложным аспектом в
    программировании сервера удаленного терминала. </small></li>
  <li><small>Устанавливается только одно TCP соединение.
    Так как существуют моменты, когда Telnet клиент
    должен общаться с Telnet сервером (и наоборот),
    должны существовать способы, позволяющие
    отделить команды, которые посылаются по
    соединению, от пользовательских данных. Ниже мы
    рассмотрим, как Telnet и Rlogin справляются с этой
    задачей. </small></li>
  <li><small>На рисунке 26.1, квадратиками нарисованными
    пунктирными линиями, показаны терминал и
    псевдотерминальные драйверы, вместе с
    реализацией TCP/IP, которые обычно являются частью
    ядра операционной системы. Однако, Telnet клиент и
    сервер - это, как правило, пользовательские
    приложения. </small></li>
  <li><small>На хосте сервера, показан командный
    интерпретатор, который запускается при входе
    пользователя в систему (login shell). Это необходимо
    для получения терминального захода на сервер.
    Необходимо иметь открытый бюджет на этой
    системе, чтобы получить терминальный заход, с
    использованием Telnet или Rlogin. </small></li>
</ul>

<p><small>Интересно будет сравнить сложность Telnet и
Rlogin, основываясь на количестве строк в исходных
текстах программ, клиента и сервера каждого
приложения. На рисунке 26.2 показаны размеры
стандартных Telnet и Rlogin клиентов и серверов, так,
как они распространяются в различных версиях
Berkeley (<a HREF="tcp01.html#t01E001">рисунок 1.10</a>).<a NAME="t261004"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t26_2000.jpg" WIDTH="473" HEIGHT="240"></small></p>


<p ALIGN="CENTER"><small>Рисунок 26.2 Сравнение размеров
исходных текстов Telnet/Rlogin/клиент/сервер.</small></p>

<p>&nbsp;</p>

<p><small>Надо отметить, что из-за появления новых
опций, реализация Telnet постоянно растет, тогда как
Rlogin остается простым и стабильным. </small></p>

<p><small>При заходе удаленным терминалом не
предусматривается передача большого количества
данных. Как мы уже упоминали ранее, по соединению
между двумя конечными системами обычно
передается очень много маленьких пакетов. В
соответствии с [<a NAME="t261005"></a>Paxson 1993] соотношение
байт, отправленных клиентам (пользовательский
ввод с терминала), к количеству байт,
отправленных назад серверам, составляет
примерно 1:20. Такое соотношение получается из-за
того, что мы вводим короткие команды, которые, в
свою очередь, могут генерировать очень большой
вывод.</small></p>
<u><b>

<p><a NAME="t262000"></a>Протокол Rlogin</p>
</b></u>

<p><small>Rlogin появился в <a NAME="t262001"></a>4.2BSD и был
предназначен для захода удаленным терминалом
между Unix хостами. Поэтому Rlogin проще, чем Telnet, так
как он не требует определение параметров,
которые для одной и той же операционной системы
известны заранее и для клиента, и для сервера.
Через несколько лет Rlogin был перенесен на не-Unix
системы. </small></p>

<p><small>RFC 1282 [<a NAME="t262002"></a>Kantor 1991] содержит
спецификацию протокола Rlogin. Однако, как и в
случае с RFC посвященным RIP (Routing Information Protocol), он был
написан после того, как Rlogin уже использовался в
течении нескольких лет. Глава 15 [Stevens 1990]
описывает программирование клиента и сервера
удаленного терминала и предоставляет полные
исходные тексты Rlogin клиента и сервера. Главы 25 и 26
<a NAME="t262003"></a>[Comer and Stevens 1993] сдержат подробности
разработки и исходные тексты Telnet клиента.</small></p>
<i><b>

<p>Запуск приложения</p>
</b></i>

<p><small>Rlogin использует одно TCP соединение между
клиентом и сервером. После того как TCP соединение
установлено, между клиентом и сервером
осуществляется следующая последовательность
действий.</small></p>

<p><small>&nbsp;</small> 

<ol>
  <li><small>Клиент отправляет серверу четыре строки: (a)
    нулевой байт, (b) имя пользователя на хосте
    клиента, заканчивающееся нулевым байтом, (с) имя
    пользователя на хосте сервера, заканчивающееся
    нулевым байтом, (d) тип терминала пользователя, за
    которым следует слэш (/), затем следует скорость
    терминала, и все это заканчивается нулевым
    байтом. Необходимо отправить именно два имени
    пользователя, потому что пользователи не обязаны
    иметь одинаковые имена на разных хостах. </small><p><small>Тип
    терминала передается от клиента к серверу,
    потому что эта информация необходима для
    большинства полноэкранных приложений. Скорость
    терминала передается, потому что некоторые
    приложения работают по-разному в зависимости от
    скорости. Например, редактор vi работает с
    меньшими окнами, когда работает с меньшими
    скоростями, при этом он не должен постоянно
    перерисовывать окно.</small></p>
  </li>
  <li><small>Сервер отвечает нулевым байтом.</small></li>
  <li><small><a NAME="t262004"></a>У сервера есть опция, с помощью
    которой он просит ввести пароль. Это
    осуществляется как обычный обмен данными по Rlogin
    соединению - специальные протоколы не
    применяются. Сервер отправляет клиенту строку
    (которую клиент отображает на терминале), чаще
    всего эта строка выглядит как Password:. Если клиент
    не вводит пароль в течение определенного времени
    (обычно 60 секунд), сервер закрывает соединение. В
    домашней директории на сервере можно создать
    файл (который называется <a NAME="t262005"></a>.rhosts) в
    котором будут содержаться имя хоста и имя
    пользователя. Если зайти терминалом с указанного
    хоста с указанным именем пользователя, то не
    выдается приглашение ввести пароль. В некоторых
    публикациях, посвященных безопасности
    компьютерных систем, как, например, [<a NAME="t262006"></a>Curry
    1992], очень не рекомендуют пользоваться этой
    характеристикой, потому что в этом случае в
    секретности появляется порядочная брешь. Все что
    вводится в ответ на приглашение сервера ввести
    пароль, передается в виде открытого текста.
    Символы введенного пароля посылаются так, как
    они есть. Каждый, кто может прочитать пакеты в
    сети, может прочитать любой пароль. Последние
    реализации Rlogin клиента, например в <a NAME="t262007"></a>4.4BSD,
    используют <a NAME="t262008"></a>Kerberos для шифрации при
    передаче по сети. Естественно требуются, чтобы и
    сервер поддерживал Kerberos. ([Curry 1992] описывает Kerberos
    более подробно.)</small></li>
  <li><small>Сервер обычно отправляет запрос клиенту,
    спрашивая размер окна терминала (это будет
    описано позже).</small></li>
</ol>

<p>&nbsp;</p>

<p><small>Клиент посылает за один раз серверу 1 байт,
каждый байт сервер отражает эхо-откликом. Мы это
видели в разделе <a HREF="tcp19.html#t192000">&quot;Интерактивный
ввод&quot;</a> главы 19. Обычно используется алгоритм
Нагла (глава 19, раздел <a HREF="tcp19.html#t194000">&quot;Алгоритм
Нагла&quot;</a>), поэтому несколько входных байтов
отправляются по медленным сетям как один TCP
сегмент. Функционально все довольно просто: то,
что вводит пользователь, отправляется на сервер,
а то, что сервер отправляет клиенту, отображается
на терминале. </small></p>

<p><small>Существуют команды, которые могут быть
отправлены от клиента к серверу и от сервера к
клиенту. Давайте, во-первых, опишем сценарий, по
которому работают эти команды.</small></p>
<i><b>

<p><a NAME="t262009"></a>Управление потоком</p>
</b></i>

<p><small>По умолчанию управление потоком обычно
осуществляет Rlogin клиент. Клиент распознает ASCII
символы STOP и START (Control-S и Control-Q), которые вводятся
пользователем, и останавливает или стартует
вывод на терминал. </small></p>

<p><small>Если это не сделано, каждый раз, когда мы
вводим Control-S, чтобы остановить вывод на терминал,
символ Control-S отправляется по сети к серверу, и
сервер прекращает писать в сеть, однако данные
(размер данных может достигать размера окна)
могут быть уже выданы сервером в сеть и будут
отображены на терминале, перед тем как вывод
будет остановлен. Сотни или тысячи байт данных
могут прокрутиться на экране, перед тем как вывод
будет остановлен. На рисунке&nbsp;26.3 показан
подобный сценарий.<a NAME="t262010"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t26_3000.jpg" WIDTH="520" HEIGHT="42"></small></p>


<p ALIGN="CENTER"><small>Рисунок 26.3 Функционирование Rlogin
соединения в случае, если сервер поддерживает
обмен STOP/START.</small></p>

<p>&nbsp;</p>

<p><small>Для интерактивных пользователей подобная
задержка отклика на ввод символа Control-S
нежелательна. </small></p>

<p><small>Однако, иногда приложения, запущенные на
сервере, должны интерпретировать каждый байт
ввода, и они не хотят, чтобы клиент использовал
символы Control-S и Control-Q каким-то особенным образом.
(Редактор <a NAME="t262011"></a>emacs является примером
приложения, которое использует эти два символа
как свои собственные команды.) В подобном случае
сервер может сообщить клиенту, поддерживает ли
он контроль потока данных или нет.</small></p>
<i><b>

<p><a NAME="t262012"></a>Прерывание от клиента</p>
</b></i>

<p><small>Проблема, напоминающая управление потоком
данных, возникает, когда пользователь вводит
символ прерывания (обычно DELETE или Control-C), чтобы
прекратить процесс, запущенный на сервере.
Сценарий подобен тому, который мы показали на
рисунке 26.3. В этом случае также одно полное окно
данных в канале между сервером и клиентом будет
передано клиенту, до тех пор пока символ
прерывания проделает свой путь по соединению в
другом направлении. Мы хотим, чтобы символ
прерывания остановил или прервал вывод данных на
экран так быстро, как это возможно. </small></p>

<p><small>Достаточно редко поток данных от клиента к
серверу может быть остановлен контролем потока
данных. В этом направлении передаются только
вводимые с клавитуры символы. Поэтому нет
необходимости отправлять эти специальные
символы (Control-S или прерывание) от клиента к
серверу с использованием <a NAME="t262013"></a>режима
срочности TCP. </small></p>
<i><b>

<p><a NAME="t262014"></a>Изменения размера окна</p>
</b></i>

<p><small>Если существует возможность поделить
дисплей на окна, мы можем динамически менять
размер окна, в процессе работы приложения.
Некоторые приложения (обычно те, которые
манипулируют с целыми окнами, такие как
полноэкранные редакторы) должны знать об этих
изменениях. Большинство Unix систем каким-либо
образом сообщают приложению об изменении
размера окна. </small></p>

<p><small>В случае захода удаленным терминалом,
изменения размера окна происходят на компьютере
клиента, и об этом необходимо сообщить
приложению, которое работает на сервере. Клиенту
Rlogin необходима некоторая форма уведомления, для
того чтобы сообщить серверу об изменении размера
окна и о том, чему теперь равен новый размер окна.</small></p>
<i><b>

<p><a NAME="t262015"></a>Команды от сервера к клиенту</p>
</b></i>

<p><small>Давайте кратко рассмотрим четыре команды,
которые сервер Rlogin может отправить клиенту по TCP
соединению. Проблема заключается в том, что
используется одно TCP соединение, поэтому сервер
должен пометить байты команд так, чтобы клиент
интерпретировал их именно как команды, а не
отображал эти байты на терминале. Для этого
используется режим срочности TCP (глава 20, раздел <a HREF="tcp20.html#t208000">&quot;Режим срочности (Urgent Mode)&quot;</a>). </small></p>

<p><small>Когда сервер отправляет команду клиенту, он
входит в режим срочности, при этом последний байт
срочных данных это и есть байт команды от
сервера. Когда клиент получает уведомление о
режиме срочности, он читает из соединения и
сохраняет данные до тех пор, пока не будет
получен байт с командой (последний байт срочных
данных). Данные, которые сохранил клиент, могут
быть выданы на терминал или проигнорированы, в
зависимости от команды. На рисунке 26.4
описываются четыре командных байта.<a NAME="t262016"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="626">
  <tr>
    <td WIDTH="19%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Байт</small></td>
    <td WIDTH="81%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Описание</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><p ALIGN="CENTER"><small>0х02</small></td>
    <td WIDTH="81%" VALIGN="TOP"><small>Сбросить вывод.
    Клиент отбрасывает все данные, принятые от
    сервера, до командного байта (последний байт
    срочных данных). Клиент также отбрасывает все
    данные, сбуферизированные и предназначенные для
    вывода на терминал. Сервер посылает эту команду,
    когда пользователь ввел символ прерывания.</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><p ALIGN="CENTER"><small>0х10</small></td>
    <td WIDTH="81%" VALIGN="TOP"><small>Клиент прекращает
    контролировать поток данных.</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><p ALIGN="CENTER"><small>0х20</small></td>
    <td WIDTH="81%" VALIGN="TOP"><small>Клиент
    возобновляет контроль потока данных.</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><p ALIGN="CENTER"><small>0х80</small></td>
    <td WIDTH="81%" VALIGN="TOP"><small>Клиент немедленно
    отвечает отправкой серверу текущего размера
    окна и уведомляет сервер, если в будущем размер
    окна изменится. Сервер обычно отправляет эта
    команду немедленно после установления
    соединения.</small></td>
  </tr>
</table>


<p><small>Рисунок 26.4 Команды Rlogin, передаваемые от
сервера клиенту.</small></p>

<p>&nbsp;</p>

<p><small>Одна из причин, по которой описанные выше
команды посылаются с использованием режима
срочности TCP, заключается в том, что первая
команда (flush output) должна быть отправлена клиенту,
даже если поток данных от сервера к клиенту
остановлен контролем потока данных TCP. Ситуация
когда передача информации от сервера к клиенту
остановлена управлением потоком данных может
возникнуть, так как процессы, запущенные на
сервере, обычно генерируют вывод быстрее, чем
этот он может быть отображен на терминале
клиента. Однако, достаточно редко может
возникнуть ситуация, когда передача информациии
от клиента к серверу будет остановлена
управлением потоком данных, так как в этом
направлении поток данных содержит только
символы, вводимые пользователем. </small></p>

<p><small>Обратитесь к <a HREF="tcp20.html#t208001">рисунку 20.14</a>,
где показано, что уведомление о срочности
проходит по соединению, даже если размер окна был
установлен в 0. (Мы увидим еще один пример этого в
следующем разделе.) Оставшиеся три команды не
критичны по времени, однако они используют ту же
технику для упрощения реализации.</small></p>
<i><b>

<p><a NAME="t262017"></a>Команды от клиента к серверу</p>
</b></i>

<p><small>В настоящее время определена только одна
команда, передаваемая от клиента к серверу: это
отправка серверу текущего размера окна.
Изменение размера окна не отправляется серверу
пока клиент не получит от сервера команду 0x80
(рисунок 26.4). </small></p>

<p><small>И снова, так как используется одно TCP
соединение, клиент должен иметь возможность
пометить свои команды, чтобы они не были переданы
приложению, запущенному на сервере. Клиент
помечает команды с помощью отправки 2-х байт
равных 0xff, за которыми следуют два специальных
флаговых байта. </small></p>

<p><small>Для команды, управляющей размером окна, два
флаговых байта это ASCII символы s. Затем следуют
четыре 16-битных значения (в порядке сетевых
байтов): количество символов в строке (обычно 25),
количество символов в столбце (обычно&nbsp;80),
количество пикселей по оси X и количество
пикселей по оси Y. Часто два последних 16-битных
значения равны 0, так как большинство приложений,
запускаемых Rlogin сервером, определяют размер
экрана в символах, а не в пикселях. </small></p>

<p><small>Подобная форма представления команд
называется <a NAME="t262018"></a>командами в полосе (in-band
signaling), так как командные байты передаются в
обычном потоке данных. Байты, выделяющие команды
из потока данных (0xff) выбраны таким образом,
нажатие какой-либо клавиши не могло
сгенерировать подобные байты. Естественно у
подобной формы представления команд есть свои
недостатки. Если мы сможем сгенерировать два
последовательных байта равных 0xff с клавиатуры,
за которыми будут следовать два ASCII символа s,
следующие 8 введенных байт будут восприняты как
размеры окна. </small></p>

<p><small>Команды Rlogin от сервера к клиенту,
показанные на рисунке 26.4, называются <a NAME="t262019"></a>командами,
выходящими за полосу (out-of-band signaling), именно так эта
техника называется в большинстве API. Обратитесь к
режиму срочности TCP (глава 20, раздел <a HREF="tcp20.html#t208000">&quot;Режим срочности (Urgent Mode)&quot;</a>).
Режим срочности не имеет отношения к данным,
выходящим за полосу, так как командные байты
передаются в обычном потоке данных, при этом их
местоположение в потоке данных определяется с
использованием указателя срочности. </small></p>

<p><small>Так как команды в полосе (in-band signaling)
передаются от клиента к серверу, сервер должен
просматривать каждый байт, принятый от клиента, в
поисках двух последовательных байтов 0xff. В
случае команд выходящих за полосу (out-of-band signaling) ,
которые передаются от сервера к клиенту, клиенту
нет необходимости просматривать данные, которые
он получает от сервера, до тех пор пока сервер не
перейдет в <a NAME="t262020"></a>режим срочности. Даже в
режиме срочности клиенту необходимо только
просмотреть байт, на который указывает указатель
срочности. Так как соотношение количества байт,
передаваемых в двух направлениях (от клиента к
серверу и от сервера к клиенту), составляет
примерно 1:20, то возникает необходимость
использовать <a NAME="t262021"></a>команды в полосе (in-band
signaling) для небольшого потока данных (от клиента к
серверу), и <a NAME="t262022"></a>команды, выходящие за
полосу (out-of-band signaling), для более загруженного
потока данных (от сервера к клиенту).</small></p>
<i><b>

<p>Способы прекращения работы клиента</p>
</b></i>

<p><small>Обычно, все, что вводит пользователь Rlogin,
отправляется на сервер. Однако иногда возникает
необходимость пообщаться непосредственно с
программой клиента Rlogin. При этом серверу
отправлять ничего не нужно. <a NAME="t262023"></a>Это
делается путем ввода символа тильда (~) в первой
позиции строки, за которым может следовать один
из следующих четырех символов:</small></p>

<p><small>&nbsp;</small> 

<ol>
  <li><small>Точка прекращает работу клиента. </small></li>
  <li><small>Символ конца файла (обычно Control-D) прекращает
    работу клиента. </small></li>
  <li><small>Символ подавления (в управлении задачами
    обычно Control-Z) приостанавливает работу клиента. </small></li>
  <li><small>Символ задержанного подавления (в
    управлении задачами обычно Control-Y) задерживает
    только ввод клиента. Все вводимое с клавиатуры
    интерпретируется программой, запущенной на
    хосте клиента, однако все отправленное Rlogin
    сервером клиенту появляется на терминале. Это
    может быть использовано, когда на сервере
    запущено задание, которое займет много времени, и
    необходимо знать, когда и что оно выдаст, однако
    на клиенте необходимо запустить другую
    программу. </small></li>
</ol>

<p>&nbsp;</p>

<p><small>Две последние команды поддерживаются,
только если клиент является Unix системой, которая
поддерживает управление работами.</small></p>
<u><b>

<p><a NAME="t263000"></a>Примеры Rlogin</p>
</b></u>

<p><small>Мы рассмотрим два примера: первый
показывает протокол клиент-сервер в начале Rlogin
сессии, а второй показывает, что произойдет при
вводе клавиши прерывания, для того чтобы
остановить процесс, работающий на сервере и
генерирующий много вывода. На <a HREF="tcp19.html#t192001">рисунке
19.2</a> показан обычный поток данных по Rlogin сессии.</small></p>
<i><b>

<p>Исходный протокол клиент-сервер</p>
</b></i>

<p><small>На рисунке 26.5 показана временная диаграмма
для Rlogin соединения от хоста bsdi к серверу svr4. (Мы
удалили все связанное с установлением TCP
соединения, объявлением окна, а также информацию
о типе сервисов.) </small></p>

<p><small>Протокол, описанный в предыдущих разделах,
можно увидеть в сегментах 1-9. Клиент отправляет
один нулевой байт (сегмент 1), за которым следуют
три строки (сегмент 3). В этом примере три строки
это: rstevens (имя клиента), rstevens (имя на сервере) и
ibmpc3/9600 (тип терминала и скорость). Сервер
проверяет полномочность этой информации и
отвечает нулевым байтом (сегмент 5). </small></p>

<p><small>Затем сервер отправляет команду с запросом
окна (сегмент 7). Эта команда отправляется с
использованием режима срочности TCP. Здесь мы
видим реализацию (<a NAME="t263001"></a>SVR4), которая
использует старую, однако более
распространенную интерпретацию, когда указатель
срочности указывает на номер последовательности
последнего байта срочных данных плюс один.
Клиент отвечает 12 байтами данных: 2 байта 0xff, 2
байта s и четыре 16-битных значения. </small></p>

<p><small>Следующие четыре сегмента от сервера (10, 12, 14
и 16) это приветствие операционной системы. За
ними следует 7-байтное приглашение от shellа:
&quot;svr4%&quot; (сегмент 18). </small></p>

<p><small>Данные, которые вводит клиент, отправляются
по 1 байту за один раз, как показано на <a HREF="tcp19.html#t192001">рисунке 19.2</a>. Соединение может
быть закрыто с любой стороны. Если мы введем
команду, которая заставит shell, запущенный на
сервере, прекратить свою работу, сервер со своей
стороны осуществит активное закрытие. Если мы
введем escape последовательность Rlogin клиенту
(обычно тильда), за которой следует точка или
символ конца файла, клиент осуществит активное
закрытие. </small></p>

<p>&nbsp;</p>


<p>Номер порта клиента на рисунке 26.5 равен 1023, это
значение находится внутри диапазона, который
управляется <a NAME="t263002"></a>IANA (глава 1, раздел <a HREF="tcp01.html#t019000">&quot;Номера портов&quot;</a>). Протокол
Rlogin требует, чтобы клиент имел номер порта меньше
чем 1024, эти порты называются <a NAME="t263003"></a>зарезервированные
порты. В Unix системах клиент не может получить
зарезервированный порт, если только процесс не
имеет привилегии суперпользователя. Это
является частью определения полномочий между
клиентом и сервером, что позволяет пользователю
получить доступ к системе, не вводя пароль. [Stevens
1990] обсуждает эти зарезервированные порты и
полномочия, используемые между клиентом и
сервером, более подробно.<a NAME="t263004"></a></p>


<p ALIGN="CENTER"><small><img SRC="t26_5000.jpg" WIDTH="523" HEIGHT="770"></small></p>


<p ALIGN="CENTER"><small>Рисунок 26.5 Временная диаграмма Rlogin
соединения.</small></p>
<i><b>

<p>Кнопка прерывания клиента</p>
</b></i>

<p><small>Давайте рассмотрим еще один пример, в
котором TCP использует <a NAME="t263005"></a>режим
срочности, когда поток данных остановлен с
помощью символа прерывания. В этом примере
сведены вместе несколько алгоритмов TCP, которые
мы обсуждали ранее: режим срочности,
предотвращение &quot;глупого&quot; окна, управление
потоком данных с помощью окон и устойчивого
таймера. Мы стартовали клиента на хосте sun. Затем
зашли терминалом на bsdi, вывели на терминал
большой текстовый файл, а затем остановили вывод,
нажав Control-S. Когда вывод остановлен, мы нажали
клавишу прерывания (DELETE), чтобы завершить работу
программы:</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>rlogin bsdi</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; приветствие
от операционной системы<br>
bsdi % <b>cat /usr/share/misc/termcap</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вывод большого
файла на терминал<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; большой
вывод на терминал<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; мы
печатаем Control-S, чтобы остановить вывод,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; и
ожидаем до тех пор, пока вывод не остановится<br>
<br>
^<b>? </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим
символ прерывания, он отображается эхом<br>
bsdi %
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; затем
появляется приглашение<br>
</p>


<p>&nbsp;</p>

<p><small>Ниже описаны состояния клиента, сервера и
соединения.</small></p>

<p><small>&nbsp;</small> 

<ol>
  <li><small>Вывод на терминал остановлен путем ввода
    Control-S. </small></li>
  <li><small>Rlogin клиент приостановил вывод на терминал,
    однако выходной буфер терминала будет заполнен. </small></li>
  <li><small>Rlogin клиент не может читать из сети, так как <a NAME="t263006"></a>приемный буфер TCP клиента полон. </small></li>
  <li><small>TCP клиент объявляет размер окна равный 0,
    чтобы остановить отправителя (TCP модуль Rlogin
    сервера), когда приемный буфер полон. </small></li>
  <li><small>TCP модуль сервера отправляет сообщение о
    заполнении буфера, когда его вывод остановлен
    сообщением от клиента о том, что размер окна
    равен 0. </small></li>
  <li><small>Сервер Rlogin остановлен, так как <a NAME="t263007"></a>отправляющий
    буфер полон. Таким образом, сервер Rlogin не может
    читать данные от приложения, которое запущено на
    сервере (cat). </small></li>
  <li><small>Приложение cat останавливается, когда его
    выходной буфер наполняется. </small></li>
  <li><small>Затем мы вводим символ прерывания, чтобы
    остановить работу приложения cat на сервере. Это
    отправляется от TCP клиента к TCP серверу, потому
    что поток данных в этом направлении не
    остановлен с помощью контроля потока данных. </small></li>
  <li><small>Приложение cat получает символ прерывания и
    прекращает свою работу. При этом его выходной
    буфер (из которого читал сервер Rlogin) очищается,
    после чего &quot;просыпается&quot; сервер Rlogin. Сервер
    Rlogin входит в режим срочности и посылает клиенту
    команду &quot;очистить вывод&quot; (0x02). </small></li>
</ol>

<p>&nbsp;</p>

<p><small>На рисунке 26.6 показан поток данных от
сервера к клиенту. (Номера последовательности
взяты из временной диаграммы, которую мы покажем
чуть ниже.)<a NAME="t263008"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t26_6000.jpg" WIDTH="519" HEIGHT="197"></small></p>


<p ALIGN="CENTER"><small>Рисунок 26.6 Поток данных от сервера
к клиенту в примере Rlogin.</small></p>

<p>&nbsp;</p>

<p><small>Затемненная часть отправляющего буфера это
неиспользуемая часть буфера размером в 4096 байт.
На рисунке 26.7 приведена временная диаграмма для
этого примера. </small></p>

<p><small>В сегментах 1-3 сервер отправляет клиенту
сегменты полного размера. Подтверждение (ACK) в
сегменте 4 всего лишь объявляет окно равное 1024,
потому что вывод остановлен: так как клиент не
может писать на терминал, он не может читать из
сети. Сегмент 5 не полного размера, а ACK в сегменте
6 объявляет только оставшееся пространство в
приемном буфере, размер премного буфера
составляет 4096 байт. Клиент должен объявить окно
размером 349 байт, потому что если он объявит окно
равное 0 (как мы ожидаем, основываясь на алгоритме
избежания &quot;глупого окна&quot;, глава 22, раздел <a HREF="tcp22.html#t223000">&quot;Синдром &quot;глупого&quot; окна&quot;</a>),
это приведет к тому, что правая граница окна
сдвинется влево, что не должно произойти (глава 20,
раздел <a HREF="tcp20.html#t203000">&quot;Изменение размера
окна&quot;</a>). Так как сервер не может отправить
буфер полного размера, когда он принимает
сегмент 6, он прибегает к алгоритму
предотвращения &quot;глупого окна&quot;, не посылая
ничего, при этом устанавливается <a NAME="t263009"></a>устойчивый
таймер (5 секунд). Когда таймер истекает,
отправляется 349 байт (сегмент 7), и так как вывод
клиента все еще остановлен, подтверждение в
сегменте 8 объявляет <a NAME="t263010"></a>окно равное 0. </small></p>

<p><small>В этот момент мы вводим символ прерывания,
который передается в сегменте 9. Все еще
объявлено окно равное 0. Когда Rlogin сервер
получает символ прерывания, он передает его
приложению (<a NAME="t263011"></a>cat), и приложение
прекращает свою работу. Так как приложение было
остановлено вводом символа прерывания с
терминала, его вывод сбрасывается и это
передается серверу Rlogin. Это заставляет сервер
посылать команду &quot;очистить вывод&quot; клиенту с
использованием режима срочности TCP. Мы видим это
в сегменте&nbsp;10. Обратите внимание, что командный
байт 0x02 имеет номер последовательности 30146
(указатель срочности минус один). Перед командным
байтом находится 3419 байт (номера
последовательности 26727:30145), они буферизированы
сервером и сервер собирается их отправить. </small></p>

<p><small>Сегмент 10, с уведомлением срочности,
содержит следующий байт данных, который
передается от сервера клиенту (номер
последовательности 26727). Он не содержит командный
байт &quot;очистить вывод&quot;. Сервер может послать
этот единственный байт в сегменте 10 (глава 22,
раздел <a HREF="tcp22.html#t222000">&quot;Пример&quot;</a>), так как
отправитель всегда может проверить, закрыто ли
окно, отправив 1 байт данных. TCP модуль клиента
немедленно отвечает сегментом 11 с нулевым окном,
однако прием уведомления о срочности в сегменте
10 заставляет TCP модуль клиента уведомить Rlogin
клиента, что удаленный конец соединения вошел в
режим срочности.<a NAME="t263012"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t26_7000.jpg" WIDTH="520" HEIGHT="773"></small></p>


<p ALIGN="CENTER"><small>Рисунок 26.7 Пример Rlogin, когда клиент
останавливает вывод и затем прерывает работу
программы на сервере.</small></p>

<p>&nbsp;</p>

<p><small>Как только Rlogin клиент получает уведомление
о срочности от своего TCP, он начинает считывание
данных, которые уже ожидают этого, окно
открывается (сегмент 13). Данные, буферизированные
сервером, отправляются (сегменты 14, 15, 17 и 18).
Последний сегмент содержит последний байт
срочных данных (номер последовательности 30146),
который содержит командный байт, передаваемый от
сервера клиенту. Когда клиент считывает этот
байт, он отбрасывает все данные, которые он
прочитал в сегментах 14, 15, 17 и 18, и очищает свою
выходную очередь на терминал. Следующие 2 байта в
сегменте 19 содержат эхо символа прерывания:
&quot;^?&quot;. Последний сегмент, который мы показали
(21), содержит приглашение shellа от клиента. </small></p>

<p><small>Этот пример показывает, как данные могут
быть буферизированы на обоих концах соединения,
когда клиент вводит символ прерывания. Если
сброшено будет только 3419 байт, буферизированных
на сервере, при этом 4096 байт у клиента сброшено не
будет, эти 4096 байт данных вместе с тем, что было
буферизировано в выходной очереди терминала у
клиента, появятся в выводе.</small></p>
<u><b>

<p><a NAME="t264000"></a>Протокол Telnet</p>
</b></u>

<p><small>Telnet был разработан, для того чтобы работать
между хостами работающими под управлениием
любых операционных систем, а также с любыми
терминалами. Его спецификация, приведенная в RFC 854
<a NAME="t264001"></a>[Postel and Reynolds 1983a], определяет терминал,
который может являться наиболее общим, и который
называется виртуальным сетевым терминалом (<a NAME="t264002"></a>NVT - network virtual terminal). NVT это воображаемое
устройство, находящееся на обоих концах
соединения, у клиента и сервера, с помощью
которого устанавливается соответствие между их
реальными терминалами. Таким образом,
операционная система клиента должна определять
соответствие между тем типом терминала, за
которым работает пользователь, с NVT. В свою
очередь, сервер должен устанавливать
соответствие между NVT и теми типами терминалов,
которые он (сервер) поддерживает. </small></p>

<p><small>NVT это символьное устройство с клавиатурой
и принтером. Данные, введенные пользователем с
клавиатуры, отправляются серверу, а данные,
полученные от сервера, поступают на принтер. По
умолчанию клиент отражает эхом на принтер все,
что ввел пользователь, однако, ниже мы увидим что,
существуют опции, которые позволяют изменить
подобное поведение.</small></p>
<i><b>

<p><a NAME="t264003"></a>NVT ASCII</p>
</b></i>

<p><small>Термин NVT ASCII означает 7-битный вариант U.S. ASCII
набора символов, который используется в
семействе протоколов Internet. Каждый 7-битный символ
отправляется как 8-битный байт со старшим битом
установленным в 0. </small></p>

<p><small>Конец строки передается как двухсимвольная
последовательность - CR (возврат каретки - carriage
return), затем следует LF (пропуск строки - linefeed). Мы
показываем это как \r\n. Возврат каретки
передается как двухсимвольная
последовательность CR, за которой следует NUL
(нулевой байт). Мы показываем это как \r\0. </small></p>

<p><small>В следующих главах мы увидим, что FTP, SMTP, Finger
и Whois используют NVT ASCII для ввода команд клиента и
откликов сервера.</small></p>
<i><b>

<p><a NAME="t264004"></a>Команды Telnet</p>
</b></i>

<p><small>Telnet использует команды в полосе (in-band signaling)
в обоих направлениях. Байт 0xff (255 десятичный)
называется IAC, &quot;интерпретировать как
команду&quot;. Следующий байт является командным
байтом. Для того чтобы послать байт данных равный
255, отправляются два последовательных байта
равных 255. (В предыдущем параграфе мы сказали, что
поток данных имеет формат NVT ASCII, то есть
используются 7-битные значения, а это означает,
что байт данных равный 255 не может быть отправлен
посредством Telnet. Существует двоичная опция Telnet,
описанная в RFC 856 [Postel and Reynolds 1983b], которая,
позволяет передавать 8-битные данные.) На рисунке
26.8 приведены команды Telnet.<a NAME="t264005"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="9" WIDTH="862">
  <tr>
    <td WIDTH="14%" VALIGN="TOP" HEIGHT="2"><p ALIGN="CENTER"><small>Имя</small></td>
    <td WIDTH="27%" VALIGN="TOP" HEIGHT="2"><p ALIGN="CENTER"><small>Код
    (десятичный)</small></td>
    <td WIDTH="59%" VALIGN="TOP" HEIGHT="2"><p ALIGN="CENTER"><small>Описание</small></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP" HEIGHT="1"><small>EOF</small></td>
    <td WIDTH="27%" VALIGN="TOP" HEIGHT="1"><p ALIGN="CENTER"><small>236</small></td>
    <td WIDTH="59%" VALIGN="TOP" HEIGHT="1"><small>конец файла</small></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP" HEIGHT="1"><small>SUSP</small></td>
    <td WIDTH="27%" VALIGN="TOP" HEIGHT="1"><p ALIGN="CENTER"><small>237</small></td>
    <td WIDTH="59%" VALIGN="TOP" HEIGHT="1"><small>подавить
    текущий процесс (управление задачами)</small></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP" HEIGHT="1"><small>ABORT</small></td>
    <td WIDTH="27%" VALIGN="TOP" HEIGHT="1"><p ALIGN="CENTER"><small>238</small></td>
    <td WIDTH="59%" VALIGN="TOP" HEIGHT="1"><small>прекратить
    процесс</small></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP" HEIGHT="1"><small>EOR</small></td>
    <td WIDTH="27%" VALIGN="TOP" HEIGHT="1"><p ALIGN="CENTER"><small>239</small></td>
    <td WIDTH="59%" VALIGN="TOP" HEIGHT="1"><small>конец записи</small></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP" HEIGHT="1"><small>SE</small></td>
    <td WIDTH="27%" VALIGN="TOP" HEIGHT="1"><p ALIGN="CENTER"><small>240</small></td>
    <td WIDTH="59%" VALIGN="TOP" HEIGHT="1"><small>конец
    подопции</small></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP" HEIGHT="1"><small><a NAME="t264006"></a>NOP</small></td>
    <td WIDTH="27%" VALIGN="TOP" HEIGHT="1"><p ALIGN="CENTER"><small>241</small></td>
    <td WIDTH="59%" VALIGN="TOP" HEIGHT="1"><small>пустая
    операция</small></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP" HEIGHT="1"><small>DM</small></td>
    <td WIDTH="27%" VALIGN="TOP" HEIGHT="1"><p ALIGN="CENTER"><small>242</small></td>
    <td WIDTH="59%" VALIGN="TOP" HEIGHT="1"><small>маркер
    данных</small></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP" HEIGHT="1"><small>BRK</small></td>
    <td WIDTH="27%" VALIGN="TOP" HEIGHT="1"><p ALIGN="CENTER"><small>243</small></td>
    <td WIDTH="59%" VALIGN="TOP" HEIGHT="1"><small>прерывание</small></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP" HEIGHT="1"><small>IP</small></td>
    <td WIDTH="27%" VALIGN="TOP" HEIGHT="1"><p ALIGN="CENTER"><small>244</small></td>
    <td WIDTH="59%" VALIGN="TOP" HEIGHT="1"><small>прервать
    процесс</small></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP" HEIGHT="1"><small>AO</small></td>
    <td WIDTH="27%" VALIGN="TOP" HEIGHT="1"><p ALIGN="CENTER"><small>245</small></td>
    <td WIDTH="59%" VALIGN="TOP" HEIGHT="1"><small>прекратить
    вывод</small></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP" HEIGHT="1"><small>AYT</small></td>
    <td WIDTH="27%" VALIGN="TOP" HEIGHT="1"><p ALIGN="CENTER"><small>246</small></td>
    <td WIDTH="59%" VALIGN="TOP" HEIGHT="1"><small>вы здесь?</small></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP" HEIGHT="1"><small>EC</small></td>
    <td WIDTH="27%" VALIGN="TOP" HEIGHT="1"><p ALIGN="CENTER"><small>247</small></td>
    <td WIDTH="59%" VALIGN="TOP" HEIGHT="1"><small>escape символ</small></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP" HEIGHT="1"><small>EL</small></td>
    <td WIDTH="27%" VALIGN="TOP" HEIGHT="1"><p ALIGN="CENTER"><small>248</small></td>
    <td WIDTH="59%" VALIGN="TOP" HEIGHT="1"><small>стереть
    строку</small></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP" HEIGHT="1"><small>GA</small></td>
    <td WIDTH="27%" VALIGN="TOP" HEIGHT="1"><p ALIGN="CENTER"><small>249</small></td>
    <td WIDTH="59%" VALIGN="TOP" HEIGHT="1"><small>идем дальше</small></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP" HEIGHT="1"><small>SB</small></td>
    <td WIDTH="27%" VALIGN="TOP" HEIGHT="1"><p ALIGN="CENTER"><small>250</small></td>
    <td WIDTH="59%" VALIGN="TOP" HEIGHT="1"><small>начало
    подопции</small></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP" HEIGHT="1"><small>WILL</small></td>
    <td WIDTH="27%" VALIGN="TOP" HEIGHT="1"><p ALIGN="CENTER"><small>251</small></td>
    <td WIDTH="59%" VALIGN="TOP" HEIGHT="1"><small>обсуждение
    опции (рисунок 26.9)</small></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP" HEIGHT="1"><small>WONT</small></td>
    <td WIDTH="27%" VALIGN="TOP" HEIGHT="1"><p ALIGN="CENTER"><small>252</small></td>
    <td WIDTH="59%" VALIGN="TOP" HEIGHT="1"><small>обсуждение
    опции</small></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP" HEIGHT="1"><small>DO</small></td>
    <td WIDTH="27%" VALIGN="TOP" HEIGHT="1"><p ALIGN="CENTER"><small>253</small></td>
    <td WIDTH="59%" VALIGN="TOP" HEIGHT="1"><small>обсуждение
    опции</small></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP" HEIGHT="1"><small>DONT</small></td>
    <td WIDTH="27%" VALIGN="TOP" HEIGHT="1"><p ALIGN="CENTER"><small>254</small></td>
    <td WIDTH="59%" VALIGN="TOP" HEIGHT="1"><small>обсуждение
    опции</small></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP" HEIGHT="1"><small>IAC</small></td>
    <td WIDTH="27%" VALIGN="TOP" HEIGHT="1"><p ALIGN="CENTER"><small>255</small></td>
    <td WIDTH="59%" VALIGN="TOP" HEIGHT="1"><small>байт данных
    255</small></td>
  </tr>
</table>


<p><small>Рисунок 26.8 Команды Telnet, предваряемые IAC (255). </small></p>

<p>&nbsp;</p>

<p><small>Так как большинство из этих команд
используется достаточно редко, мы опишем их по
мере того, как они будут встречаться в тексте или
в примерах.</small></p>
<i><b>

<p><a NAME="t264007"></a>Обсуждение опций</p>
</b></i>

<p><small>Несмотря на то, что при начале работы Telnet
подразумевается, что на каждом конце находится
NVT, первый обмен данными, который происходит по
Telnet соединению, являет собой обсуждение опций.
Обсуждение опций это симметричный процесс -
каждая сторона может послать запрос другой. </small></p>

<p><small>Каждая сторона может послать один из
четырех различных запросов для любой заданной
опции.</small></p>

<p><small>&nbsp;</small> 

<ol>
  <li><small>WILL. Отправитель хочет включить эту опцию для
    себя. </small></li>
  <li><small>DO. Отправитель хочет, чтобы получатель
    включил эту опцию. </small></li>
  <li><small>WONT. Отправитель хочет выключить эту опцию
    для себя. </small></li>
  <li><small>DONT. Отправитель хочет, чтобы получатель
    выключил опцию. </small></li>
</ol>

<p>&nbsp;</p>

<p><small>Так как правила Telnet позволяют стороне
принять или отклонить запрос на включение опции
(случаи 1 и 2), однако требуют, чтобы она всегда
удовлетворяла запрос на выключение опции (случаи
3 и 4), из этих четырех возможных случаев может
получиться шесть комбинаций, которые приведены
на рисунке 26.9.<a NAME="t264008"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="940">
  <tr>
    <td WIDTH="4%" VALIGN="TOP" BGCOLOR="#ffffff">&nbsp;</td>
    <td WIDTH="15%" VALIGN="TOP" BGCOLOR="#ffffff"><small>Отправитель</small></td>
    <td WIDTH="7%" VALIGN="TOP" BGCOLOR="#ffffff">&nbsp;</td>
    <td WIDTH="15%" VALIGN="TOP" BGCOLOR="#ffffff"><small>Получатель</small></td>
    <td WIDTH="59%" VALIGN="TOP" BGCOLOR="#ffffff"><small>Описание</small></td>
  </tr>
  <tr>
    <td WIDTH="4%" VALIGN="TOP"><small>1.</small></td>
    <td WIDTH="15%" VALIGN="TOP"><small>WILL</small></td>
    <td WIDTH="7%" VALIGN="TOP"><small>╝ <br>
    ╛ </small></td>
    <td WIDTH="15%" VALIGN="TOP"><small>&nbsp;<br>
    DO</small></td>
    <td WIDTH="59%" VALIGN="TOP"><small>отправитель хочет
    включить опцию<br>
    получатель говорит ДА</small></td>
  </tr>
  <tr>
    <td WIDTH="4%" VALIGN="TOP"><small>2.</small></td>
    <td WIDTH="15%" VALIGN="TOP"><small>WILL</small></td>
    <td WIDTH="7%" VALIGN="TOP"><small>╝ <br>
    ╛ </small></td>
    <td WIDTH="15%" VALIGN="TOP"><small>&nbsp;<br>
    DONT</small></td>
    <td WIDTH="59%" VALIGN="TOP"><small>отправитель хочет
    включить опцию<br>
    получатель говорит НЕТ</small></td>
  </tr>
  <tr>
    <td WIDTH="4%" VALIGN="TOP"><small>3.</small></td>
    <td WIDTH="15%" VALIGN="TOP"><small>DO</small></td>
    <td WIDTH="7%" VALIGN="TOP"><small>╝ <br>
    ╛ </small></td>
    <td WIDTH="15%" VALIGN="TOP"><small>&nbsp;<br>
    WILL</small></td>
    <td WIDTH="59%" VALIGN="TOP"><small>отправитель хочет,
    чтобы получатель включил опцию<br>
    получатель говорит ДА</small></td>
  </tr>
  <tr>
    <td WIDTH="4%" VALIGN="TOP"><small>4.</small></td>
    <td WIDTH="15%" VALIGN="TOP"><small>DO</small></td>
    <td WIDTH="7%" VALIGN="TOP"><small>╝ <br>
    ╛ </small></td>
    <td WIDTH="15%" VALIGN="TOP"><small>&nbsp;<br>
    WONT</small></td>
    <td WIDTH="59%" VALIGN="TOP"><small>отправитель хочет,
    чтобы получатель включил опцию<br>
    получатель говорит НЕТ</small></td>
  </tr>
  <tr>
    <td WIDTH="4%" VALIGN="TOP"><small>5.</small></td>
    <td WIDTH="15%" VALIGN="TOP"><small>WONT</small></td>
    <td WIDTH="7%" VALIGN="TOP"><small>╝ <br>
    ╛ </small></td>
    <td WIDTH="15%" VALIGN="TOP"><small>&nbsp;<br>
    DONT</small></td>
    <td WIDTH="59%" VALIGN="TOP"><small>отправитель хочет
    выключить опцию<br>
    получатель должен сказать ДА</small></td>
  </tr>
  <tr>
    <td WIDTH="4%" VALIGN="TOP"><small>6.</small></td>
    <td WIDTH="15%" VALIGN="TOP"><small>DONT</small></td>
    <td WIDTH="7%" VALIGN="TOP"><small>╝ <br>
    ╛ </small></td>
    <td WIDTH="15%" VALIGN="TOP"><small>&nbsp;<br>
    WONT</small></td>
    <td WIDTH="59%" VALIGN="TOP"><small>отправитель хочет,
    чтобы получатель выключил опцию<br>
    получатель должен сказать ДА</small></td>
  </tr>
</table>


<p><small>Рисунок 26.9 Шесть сценариев обсуждения
опции Telnet.</small></p>

<p>&nbsp;</p>

<p><small>Обсуждение опции занимает 3 байта: IAC байт,
за которым следует байт WILL, DO, WONT или DONT, затем ID
байт, указывающий на ту опцию, которую необходимо
включить или выключить. В настоящее время, таким
образом, может быть обсуждено 40 опций. <a NAME="t264009"></a>Assigned
Numbers RFC содержат значения для байт опций, а
соответствующее RFC описывает сами опции. На
рисунке 26.10 показаны коды опций, которые мы
увидим в этой главе.<a NAME="t264010"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="9" WIDTH="789">
  <tr>
    <td WIDTH="19%" VALIGN="TOP" HEIGHT="4"><p ALIGN="CENTER"><small>ID
    опции (десятичный)</small></td>
    <td WIDTH="47%" VALIGN="TOP" HEIGHT="4"><p ALIGN="CENTER"><small>Имя</small></td>
    <td WIDTH="33%" VALIGN="TOP" HEIGHT="4"><p ALIGN="CENTER"><small>RFC</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP" HEIGHT="3"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="47%" VALIGN="TOP" HEIGHT="3"><small><a NAME="t264011"></a>эхо</small></td>
    <td WIDTH="33%" VALIGN="TOP" HEIGHT="3"><p ALIGN="CENTER"><small>857</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP" HEIGHT="3"><p ALIGN="CENTER"><small>3</small></td>
    <td WIDTH="47%" VALIGN="TOP" HEIGHT="3"><small>запрещение
    команды go ahead</small></td>
    <td WIDTH="33%" VALIGN="TOP" HEIGHT="3"><p ALIGN="CENTER"><small>858</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP" HEIGHT="3"><p ALIGN="CENTER"><small>5</small></td>
    <td WIDTH="47%" VALIGN="TOP" HEIGHT="3"><small><a NAME="t264012"></a>статус</small></td>
    <td WIDTH="33%" VALIGN="TOP" HEIGHT="3"><p ALIGN="CENTER"><small>859</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP" HEIGHT="3"><p ALIGN="CENTER"><small>6</small></td>
    <td WIDTH="47%" VALIGN="TOP" HEIGHT="3"><small><a NAME="t264013"></a>маркер
    времени</small></td>
    <td WIDTH="33%" VALIGN="TOP" HEIGHT="3"><p ALIGN="CENTER"><small>860</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP" HEIGHT="3"><p ALIGN="CENTER"><small>24</small></td>
    <td WIDTH="47%" VALIGN="TOP" HEIGHT="3"><small><a NAME="t264014"></a>тип
    терминала</small></td>
    <td WIDTH="33%" VALIGN="TOP" HEIGHT="3"><p ALIGN="CENTER"><small>1091</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP" HEIGHT="3"><p ALIGN="CENTER"><small>31</small></td>
    <td WIDTH="47%" VALIGN="TOP" HEIGHT="3"><small><a NAME="t264015"></a>размер
    окна</small></td>
    <td WIDTH="33%" VALIGN="TOP" HEIGHT="3"><p ALIGN="CENTER"><small>1073</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP" HEIGHT="3"><p ALIGN="CENTER"><small>32</small></td>
    <td WIDTH="47%" VALIGN="TOP" HEIGHT="3"><small><a NAME="t264016"></a>скорость
    терминала</small></td>
    <td WIDTH="33%" VALIGN="TOP" HEIGHT="3"><p ALIGN="CENTER"><small>1079</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP" HEIGHT="3"><p ALIGN="CENTER"><small>33</small></td>
    <td WIDTH="47%" VALIGN="TOP" HEIGHT="3"><small><a NAME="t264017"></a>удаленный
    контроль потоком данных</small></td>
    <td WIDTH="33%" VALIGN="TOP" HEIGHT="3"><p ALIGN="CENTER"><small>1372</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP" HEIGHT="3"><p ALIGN="CENTER"><small>34</small></td>
    <td WIDTH="47%" VALIGN="TOP" HEIGHT="3"><small><a NAME="t264018"></a>линейный
    режим (linemode)</small></td>
    <td WIDTH="33%" VALIGN="TOP" HEIGHT="3"><p ALIGN="CENTER"><small>1184</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP" HEIGHT="3"><p ALIGN="CENTER"><small>36</small></td>
    <td WIDTH="47%" VALIGN="TOP" HEIGHT="3"><small><a NAME="t264019"></a>переменные
    окружения</small></td>
    <td WIDTH="33%" VALIGN="TOP" HEIGHT="3"><p ALIGN="CENTER"><small>1408</small></td>
  </tr>
</table>


<p><small>Рисунок 26.10 Коды опций Telnet, обсуждаемые в
этой главе.</small></p>

<p>&nbsp;</p>

<p><small>Обсуждение опции Telnet, как и многое другое в
протоколе Telnet, процесс симметричный. Каждая
сторона может начать процесс обсуждения опции.
Однако заход удаленным терминалом не является
симметричным процессом. Клиент решает свои
задачи, а сервер свои. Мы увидим, что некоторые
опции Telnet применимы только к клиенту (например,
требование включить линейный режим (<a NAME="t264020"></a>linemode)),
а некоторые предназначены только для сервера. </small></p>
<i><b>

<p><a NAME="t264021"></a>Обсуждение подопций</p>
</b></i>

<p><small>Некоторые опции требуют большего
количества информации, нежели просто
&quot;включить&quot; (enable) или &quot;выключить&quot; (disable).
Например, установка типа терминала: для того
чтобы клиент мог идентифицировать тип терминала,
он должен отправить ASCII строку. Чтобы обработать
эти опции, применяется обсуждение подопций. </small></p>

<p><small>RFC 1091 [<a NAME="t264022"></a>VanBokkelen 1989] определяет
подопции, которые необходимо обсудить для
установки типа терминала. Во-первых, одна сторона
(обычно клиент) просит включить опцию, отправляя
3-байтовую последовательность</small></p>

<p>&nbsp;</p>

<p><small>&lt;IAC, WILL, 24&gt;</small></p>

<p>&nbsp;</p>

<p><small>где 24 (десятичное) это идентификатор опции
типа терминала. Если получатель (сервер) говорит
ДА, его ответ будет выглядеть как</small></p>

<p>&nbsp;</p>

<p><small>&lt;IAC, DO, 24&gt;</small></p>

<p>&nbsp;</p>

<p><small>Затем сервер посылает</small></p>

<p>&nbsp;</p>

<p><small>&lt;IAC, SB, 24, 1, IAC, SE&gt;</small></p>

<p>&nbsp;</p>

<p><small>спрашивая о типе терминала клиента. SB это
команда, которая сообщает о начале подопций
(suboption-begin). Следующий байт равный 24 указывает на
то, что это подопция типа терминала. (SB всегда
следует за номером опции, к которой относятся
подопции.) Следующий байт равный 1 означает
&quot;отправьте ваш тип терминала&quot;. Перед
командой конец подопций (suboption-end) должен опять
стоять IAC, так же как и перед командой SB. Клиент
отвечает командой</small></p>

<p>&nbsp;</p>

<p><small>&lt;IAC, SB, 24, 0, 'I', 'B', 'M', 'P', 'C', IAC, SE&gt;</small></p>

<p>&nbsp;</p>

<p><small>в случае, если его тип терминала ibmpc.
Четвертый байт равный 0 означает &quot;у меня
следующий тип терминала&quot;. (&quot;Официальный&quot;
список приемлемых типов терминалов находится в <a NAME="t264023"></a>Assigned Numbers RFC, однако для Unix систем
приемлем любой тип терминала, поддерживаемый
сервером. Обычно это терминалы, поддерживаемые
базами termcap или terminfo.) Типы терминалов,
указываемые в подопциях Telnet, пишутся большими
буквами и обычно преобразуются в маленькие буквы
уже сервером.<a NAME="t264024"></a></small></p>
<i><b>

<p>Полудуплексный, символ за один раз, строка за
один раз или линейный режим (Linemode)?</p>
</b></i>

<p><small>Существуют четыре режима, в которых
функционирует большинство Telnet клиентов и
серверов.</small></p>

<p><small>&nbsp;</small> 

<ol>
  <li><small>Полудуплексный.</small><p><small>Это режим по
    умолчанию, который, однако, редко используется в
    настоящее время. NVT по умолчанию это
    полудуплексное устройство, которое требует
    исполнения команды GO AHEAD (GA) от сервера, перед тем
    как будет принят ввод от пользователя. Ввод
    пользователя отображается локальным эхом от NVT
    клавиатуры на NVT принтер, таким образом, от
    клиента к серверу посылаются только полные
    строки.</small></p>
    <p><small>Таким образом, обеспечивается минимальная
    поддержка терминала, однако подобным образом
    невозможно обеспечить полнодуплексную связь с
    хостами, которые поддерживают полнодуплексную
    форму общения, что является нормой на
    сегодняшний день. RFC 857 <a NAME="t264025"></a>[Postel and Reynolds 1983c]
    определяет опцию ECHO (эхо), а RFC 858 [Postel and Reynolds 1983d]
    определяет опцию SUPPRESS GO AHEAD (запрещение команды go
    ahead). Комбинация этих двух опций предоставляет
    поддержку для следующего режима, символ за один
    раз, с удаленным эхом.</small></p>
  </li>
  <li><small><a NAME="t264026"></a>Символ за один раз.</small><p><small>Именно
    таким образом работает Rlogin. Каждый вводимый
    символ отправляется серверу отдельно от других.
    Сервер отражает эхом большинство символов, если
    только у приложения на сервере не отключено
    отражение эхом.</small></p>
    <p><small>Проблемы, связанные с этим режимом, в
    основном связаны с задержками, вызванными
    отражением эхом по медленным сетям, и с большим
    объемом сетевого траффика. Однако, мы увидим, что
    на сегодняшний день это наиболее
    распространенный режим и являющийся к тому же
    режимом по умолчанию.</small></p>
    <p><small>Для того чтобы сервер мог войти в этот
    режим, у него должна быть включена опция SUPPRESS GO
    AHEAD. Обсуждение этой опции осуществляется
    следующим образом: клиент посылает DO SUPPRESS GO AHEAD
    (требуя от сервера, чтобы тот включил опцию), или
    сервер посылает WILL SUPPRESS GO AHEAD клиенту (спрашивая о
    возможности включить эту опцию для самого себя).
    Затем сервер осуществляет WILL ECHO, спрашивая о
    возможности включить отражение эхом.</small></p>
  </li>
  <li><small><a NAME="t264027"></a>Строка за один раз.</small><p><small>Часто
    это называется &quot;kludge line mode&quot;, потому что его
    реализация приходит от чтения между строк в RFC 858.
    Этот RFC декларирует, что должны присутствовать
    обе опции ECHO и SUPPRESS GO AHEAD, чтобы обеспечить ввод
    символа за один раз с удаленным эхом. Таким
    образом, если какая-либо из этих опций не
    включена, Telnet находится в режиме строка за один
    раз. В следующем разделе мы увидим пример того,
    как происходит обсуждение этого режима, и как он
    может быть отключен, когда программе сервера
    необходимо читать каждое нажатие клавиши. (То
    есть когда программа должна читать каждый
    символ, введенный пользователем, а не целую
    строку символов.)</small></p>
  </li>
  <li><small><a NAME="t264028"></a>Линейный режим (linemode).</small><p><small>В
    данном случае этот термин означает реальную
    опцию linemode, определенную в RFC 1184 [<a NAME="t264029"></a>Borman
    1990]. Эта опция обсуждается клиентом и сервером и
    корректирует все недостатки в режиме строка за
    один раз. Новые реализации поддерживают эту
    опцию.</small></p>
  </li>
</ol>

<p>&nbsp;</p>

<p><small>На рисунке 26.11 показаны режимы
функционирования по умолчанию между различными
Telnet клиентами и серверами. Выражение &quot;char&quot;
означает символ за один раз, &quot;kludge&quot; означает
строка за один раз и <a NAME="t264030"></a>&quot;linemode&quot;
означает реальный линейный режим RFC 1184.<a NAME="t264031"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="805">
  <tr>
    <td WIDTH="16%" VALIGN="MIDDLE" ROWSPAN="2" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Клиент</small></p>
    <p>&nbsp;</td>
    <td WIDTH="84%" VALIGN="TOP" COLSPAN="6" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Сервер</small></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small><a NAME="t264032"></a>SunOS 4.1.3</small></td>
    <td WIDTH="13%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Solaris
    2.2</small></td>
    <td WIDTH="12%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>SVR4</small></td>
    <td WIDTH="13%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small><a NAME="t264033"></a>AIX 3.2.2</small></td>
    <td WIDTH="15%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>BSD/386</small></td>
    <td WIDTH="15%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>4.4BSD</small></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><small>SunOS 4.1.3</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>char</small></td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>char</small></td>
    <td WIDTH="12%" VALIGN="TOP"><p ALIGN="CENTER"><small>char</small></td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>char</small></td>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>kludge</small></td>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>kludge</small></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><small>Solaris 2.2</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>char</small></td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>char</small></td>
    <td WIDTH="12%" VALIGN="TOP"><p ALIGN="CENTER"><small>char</small></td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>char</small></td>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>kludge</small></td>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>kludge</small></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><small>SVR4</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>char</small></td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>char</small></td>
    <td WIDTH="12%" VALIGN="TOP"><p ALIGN="CENTER"><small>char</small></td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>char</small></td>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>kludge</small></td>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>kludge</small></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><small>AIX 3.2.2</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>char</small></td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>char</small></td>
    <td WIDTH="12%" VALIGN="TOP"><p ALIGN="CENTER"><small>char</small></td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>char</small></td>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>kludge</small></td>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>kludge</small></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><small>BSD/386</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>char</small></td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>char</small></td>
    <td WIDTH="12%" VALIGN="TOP"><p ALIGN="CENTER"><small>char</small></td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>char</small></td>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>linemode</small></td>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>linemode</small></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><small>4.4BSD</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>char</small></td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>char</small></td>
    <td WIDTH="12%" VALIGN="TOP"><p ALIGN="CENTER"><small>char</small></td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>char</small></td>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>linemode</small></td>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>linemode</small></td>
  </tr>
</table>


<p><small>Рисунок 26.11 Режимы функционирования по
умолчанию между различными Telnet клиентами и
серверами. </small></p>

<p>&nbsp;</p>

<p><small>Только две реализации на этом рисунке
поддерживают реальный линейный режим. Это <a NAME="t264034"></a>BSD/386 и <a NAME="t264035"></a>4.4BSD. Только эти два
сервера делают попытку обсудить режим передачи
строки за раз, если клиент не поддерживает
реальный линейный режим. Все клиенты и серверы,
показанные на этом рисунке, поддерживают режим
передачи строки за раз, однако они не выбирают
этот режим по умолчанию, если только этот режим
не предлагается сервером.</small></p>
<i><b>

<p><a NAME="t264036"></a>Сигнал синхронизации (Synch) </p>
</b></i>

<p><small>Telnet использует команду <a NAME="t264037"></a>Data Mark в
качестве сигнала синхронизации (DM на рисунке 26.8),
который передается в виде срочных данных TCP.
Команда DM это метка синхронизации в потоке
данных, которая сообщает принимающему о
необходимости вернуться в обычный режим работы.
Он может быть отправлен в любом направлении по
Telnet соединению. </small></p>

<p><small>Когда один конец принимает уведомление о
том, что другой конец вошел в <a NAME="t264038"></a>режим
срочности, он начинает читать из потока данных,
отбрасывая все данные кроме Telnet команд.
Последний байт срочных данных это DM байт.
Причина, по которой используется режим срочности
TCP, заключается в том, что он позволяет посылать
Telnet команды по соединению, даже если поток TCP
данных остановлен управлением потока данных TCP. </small></p>

<p><small>Мы увидим примеры использования сигнала
синхронизации Telnet в следующем разделе.</small></p>
<i><b>

<p>Управление клиентом</p>
</b></i>

<p><small>Как и в случае Rlogin клиента, Telnet клиент так же
позволяет пообщаться с ним, вместо того чтобы
отправлять пользовательский ввод серверу.
Стандартный символ, позволяющий осуществить
переход в режим управления клиентом (<a NAME="t264039"></a>escape),
это Control-] (control и правая квадратная скобка, что
обычно печатается как &quot;^]&quot;). При этом клиент
выводит приглашение, обычно выглядящее как
&quot;telnet&gt;&quot;. В ответ на это приглашение можно
вводить команды, что позволяет сменить
характеристики сессии или напечатать какую-либо
информацию. Команда help поддерживается
большинством Unix клиентов и отображает все
доступные команды. </small></p>

<p><small>Мы увидим примеры того, как можно управлять
клиентом, а также как стоит пользоваться
командами в следующем разделе.</small></p>
<u><b>

<p><a NAME="t265000"></a>Примеры Telnet</p>
</b></u>

<p><small>Сейчас мы рассмотрим обсуждение опций Telnet,
вместе с тремя различными режимами
функционирования: символ за один раз, реальный
линейный режим и режим передачи строки за один
раз. Также мы увидим, что происходит, когда
пользователь прекращает работу процесса на
сервере с использованием символа прерывания.</small></p>
<i><b>

<p><a NAME="t265001"></a>Режим символ за один раз</p>
</b></i>

<p><small>Мы начнем с основного режима символ за один
раз (character-at-a-time), который напоминает Rlogin. Каждый
символ, который мы вводим на терминале,
отправляется на сервер без каких-либо
модификаций, а сервер отражает этот символ эхом.
Однако если мы запустим более новую версию
клиента (<a NAME="t265002"></a>BSD/386), который старается
включить некоторые новые опции, то увидим, что
сервер, работающий под управлением <a NAME="t265003"></a>SVR4,
не позволит включить эти опции. </small></p>

<p><small>Для того чтобы увидеть, как происходит
обсуждение между клиентом и сервером, мы включим
опцию клиента, которая позволяет отобразить все
обсуждаемые опции, а также запустим tcpdump, чтобы
получить временную диаграмму обмена пакетами. На
рисунке 26.12 показана диалоговая сессия.<a NAME="t265004"></a></small></p>

<p>&nbsp;</p>


<p><br>
bsdi % <b>telnet </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; стартуем
клиента без опций в командной строке<br>
<br>
telnet&gt; <b>toggle options </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; сообщаем
клиенту о необходимости отобразить <br>
Will show option processing.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; всю
обработку опций<br>
<br>
telnet&gt; <b>open svr4 </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; сейчас
устанавливаем соединение с сервером<br>
Trying 140.252.13.34...<br>
Connected to svr4.<br>
Escape character is '^]'.<br>
<br>
SENT DO SUPPRESS GO AHEAD
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.
(номера строк, которые мы обсудим ниже)<br>
SENT WILL TERMINAL TYPE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.<br>
SENT WILL NAWS
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.<br>
SENT WILL TSPEED
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.<br>
SENT WILL LFLOW
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5.<br>
SENT WILL LINEMODE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6.<br>
SENT WILL ENVIRON
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7.<br>
SENT DO STATUS
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8.<br>
RCVD DO TERMINAL TYPE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9.<br>
RCVD WILL SUPPRESS GO AHEAD
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10.<br>
RCVD DONT NAWS
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11.<br>
RCVD DONT TSPEED
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12.<br>
RCVD DONT LFLOW
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13.<br>
RCVD DONT LINEMODE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14.<br>
RCVD DONT ENVIRON
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 15.<br>
RCVD WONT STATUS
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16.<br>
RCVD IAC SB TERMINAL-TYPE SEND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 17.<br>
SENT IAC SB TERMINAL-TYPE IS &quot;IBMPC3&quot;&nbsp;&nbsp; 18.<br>
RCVD WILL ECHO
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 19.<br>
SENT DO ECHO
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20.<br>
RCVD DO ECHO
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 21.<br>
SENT WONT ECHO
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 22.<br>
<br>
UNIX(r) System V Release 4.0 (svr4)<br>
<br>
RCVD DONT ECHO
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 23.<br>
login: <b>rstevens </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим
имя<br>
Password:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; и
пароль, который сервер не отображает эхом, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; после
чего появляется приветствие от <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; операционной
системы... <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; и
затем приглашение от shell<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 26.12 Начальное обсуждение опций Telnet
клиентом и сервером. </small></p>

<p>&nbsp;</p>

<p><small>Строки, в которых происходит обсуждение
опций, пронумерованы (они начинаются с SENT или RCVD).
Давайте рассмотрим обсуждение опций более
подробно.</small> 

<ol>
  <li><small>Клиент начинает с обсуждения опции <a NAME="t265005"></a>SUPPRESS GO AHEAD. Эта опция начинается с DO, так
    как команда GO AHEAD обычно отправляется от сервера
    клиенту, и клиент хочет, чтобы сервер включил
    опцию. (Это немного непонятно, так как включение
    опции исключает отправку команд GA.) Сервер
    соглашается на включение этой опции в строке 10. </small></li>
  <li><small>Клиент хочет отправить свой <a NAME="t265006"></a>тип
    терминала как указано в RFC 1091 [<a NAME="t265007"></a>VanBokkelen
    1989]. Это является обычным для Unix клиентов. Опция
    начинается с WILL, так как клиент хочет включить
    эту опцию для себя. </small></li>
  <li><small>NAWS означает &quot;обсуждение размера окна&quot;,
    как определено в RFC 1073 [<a NAME="t265008"></a>Waitzman 1988]. Если
    сервер согласен (чего не происходит в строке 11),
    клиент посылает подопцию с количеством строк и
    колонок своего терминала. Если размер окна
    изменяется, клиент пошлет эту подопцию позже. (То
    же самое мы видели в случае Rlogin с командой 0x80 на
    рисунке 26.4.) </small></li>
  <li><small>Опция <a NAME="t265009"></a>TSPEED позволяет отправителю
    (обычно клиенту) сообщить свою скорость
    терминала, как определено в RFC 1079 [<a NAME="t265010"></a>Hedrick
    1988b]. Если сервер согласен (чего не происходит в
    строке 12), то клиент отправляет подопцию, в
    которой сообщает свою скорость передачи и
    скорость приема. </small></li>
  <li><small><a NAME="t265011"></a>LFLOW обозначает &quot;локальное
    управление потоком данных&quot;, как определено в RFC
    1372 [Hedrick and Borman 1992]. Клиент отправляет эту опцию
    серверу, сообщая, хочет ли он включить или
    выключить <a NAME="t265012"></a>управление потоком данных.
    Если сервер согласен (чего не происходит в строке
    13), сервер посылает подопцию клиенту, в которой
    сообщается, что переключение между клиентом и
    сервером будет осуществляться с помощью Control-S и
    Control-Q. (Это напоминает то, что мы видели в случае
    Rlogin команд 0x10 и 0x20 на рисунке 26.4.) Как мы уже
    говорили, обсуждая Rlogin, пользователь получает
    лучшее управление потоком данных, когда оно
    осуществляется клиентом, а не сервером. </small></li>
  <li><small><a NAME="t265013"></a>LINEMODE это реальный линейный
    режим, о котором мы уже упоминали в разделе <a HREF="#t264000">&quot;Протокол Telnet&quot;</a>. Вся обработка
    символов введенных с терминала осуществляется
    Telnet клиентом (удалить символ, удалить строку и
    так далее), а серверу отправляются завешенные
    строки. Ниже мы увидим, как это делается. Эта
    опция отклонена в строке 14. </small></li>
  <li><small><a NAME="t265014"></a>Опция ENVIRON позволяет клиенту
    отправить переменные окружения серверу, как
    определено в RFC 1408 [<a NAME="t265015"></a>Borman 1993a]. При этом
    переменные окружения с хоста клиента могут быть
    автоматически установлены на хосте сервера.
    Сервер отказался активизировать эту опцию в
    строке 15. ( В соответствии с соглашением,
    переменные окружения в Unix - это имена из
    заглавных букв, после которых через знак равно,
    следует значение переменной, однако это всего
    лишь соглашение.) По умолчанию, Telnet клиент <a NAME="t265016"></a>BSD/386 посылает только две переменные, а
    именно <a NAME="t265017"></a>DISPLAY и <a NAME="t265018"></a>PRINTER, если
    они определены и если опция включена.
    Пользователь Telnet может указать дополнительные
    переменные окружения, которые необходимо
    отправить. </small></li>
  <li><small><a NAME="t265019"></a>Опция STATUS (RFC 859 <a NAME="t265020"></a>[Postel
    and Reynolds 1983e]) позволяет одному участнику обмена
    спросить другой о его текущем состоянии опций
    Telnet. В этом примере клиент просит сервер включить
    опцию (DO). Если сервер согласен (чего не
    происходит в строке 16), клиент может в подопции
    попросить сервер послать статус его опций. </small></li>
  <li><small>Это первый отклик от сервера. Сервер
    согласен включить опцию типа терминала. (Почти
    каждый Unix сервер поддерживает эту опцию.) Клиент,
    однако, не может послать свой тип терминала, пока
    сервер не попросит его об этом с помощью подопции
    (строка 17). </small></li>
  <li><small>Сервер согласен запретить отправку команды
    GO AHEAD. </small></li>
  <li><small>Сервер не позволяет клиенту отправить свой
    размер окна. </small></li>
  <li><small>Сервер не позволяет клиенту отправить свою
    скорость терминала. </small></li>
  <li><small>Сервер не позволяет клиенту осуществлять
    управление потоком данных. </small></li>
  <li><small>Сервер не позволяет клиенту включить опцию
    линейного режима. </small></li>
  <li><small>Сервер не позволяет клиенту послать
    переменные окружения. </small></li>
  <li><small>Сервер не будет посылать информацию о
    состоянии своих опций. </small></li>
  <li><small>Это подопция, с помощью которой сервер
    просит клиента послать тип терминала. </small></li>
  <li><small>Клиент посылает свой тип терминала в виде
    6-символьной строки IBMPC3. </small></li>
  <li><small>Сервер просит клиента позволить ему
    осуществлять отражение эхом. Это первый момент,
    когда сервер инициирует обсуждение опции. </small></li>
  <li><small>Клиент позволяет серверу осуществлять
    отражение эхом. </small></li>
  <li><small>Сервер просит клиента осуществлять
    отображение эхом. Эта команда может показаться
    лишней, так как подобное обсуждение было
    предпринято в двух предыдущих строках. Это всего
    лишь еще один способ, применяемый в большинстве
    Unix систем, с помощью которого Telnet сервер
    определяют, является ли их клиент хостом 4.2BSD или
    более поздним релизом BSD. Если клиент ответит WILL
    ECHO, он, возможно, является хостом с более поздним
    релизом чем 4.2BSD и не сможет корректно
    поддерживать <a NAME="t265021"></a>режим срочности TCP. (В
    этом случае режим срочности не используется.) </small></li>
  <li><small>Клиент отвечает WONT ECHO, из чего следует, что
    это хост не <a NAME="t265022"></a>4.2BSD.</small></li>
  <li><small>Сервер отвечает на принятое WONT ECHO с DONT ECHO. </small></li>
</ol>

<p><small>На рисунке 26.13 показана временная диаграмма
для этого обмена клиент-сервер. (Мы удалили все,
связанное с установлением соединения.) </small></p>

<p><small>В сегменте 1 содержатся строки 1-8 (рисунок
26.12). Каждая опция занимает 3 байта в сегменте,
состоящем из 24 байт. Обсуждение опций начинает
клиент. Мы видим, что в одном TCP сегменте может
находиться несколько Telnet опций. </small></p>

<p><small>Сегмент 3 соответствует строке 9 на рисунке
26.12, команда DO TERMINAL TYPE. Сегмент 5 содержит восемь
откликов от сервера на предложенные опции,
строки 10-17 (рисунок 26.12). Длина этого сегмента
составляет 27 байт, потому что строки 10-16 это
стандартные опции, каждая требует 3 байта вместе
с подопцией (строка 17), которая требует 6 байт. 12
байт в сегменте 6 соответствуют строке 18, клиент
посылает подопцию со своим типом терминала. </small></p>

<p><small>Сегмент 8 (53 байта) - это комбинация двух
команд Telnet с 47 байтами данных, которые выводятся
на терминал. Первые 6 байт - это две команды от
сервера: WILL ECHO и DO ECHO (строки 19 и 21). Следующие 47
байт выглядят так:</small></p>

<p>&nbsp;</p>


<p>\r\n\r\nUNIX(r) System V Release 4.0 (svr4) \r\n\r\0\r\n\r\0</p>


<p>&nbsp;</p>

<p><small>Первые 4 байта генерируют две пустые строки,
перед тем как эта строка появится в выводе.
2-байтовая последовательность \r\n - это символ
новой строки в Telnet. 2-байтовая последовательность
\r\0 соответствует символу возврата каретки. Этот
сегмент показывает, что данные и команды могут
находиться в одном и том же сегменте. Telnet клиент и
Telnet сервер должны просматривать каждый
полученный байт в поисках IAC байта и затем
обрабатывать то, что следует за этим байтом.<a NAME="t265023"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t26_1300.jpg" WIDTH="522" HEIGHT="639"></small></p>


<p ALIGN="CENTER"><small>Рисунок 26.13 Начальное обсуждение
опций Telnet клиентом и сервером.</small></p>

<p>&nbsp;</p>

<p><small>В сегменте 9 содержатся две последние опции
от клиента: строки 20 и 22. Отклик в сегменте 10
соответствует строке 23 - это последняя опция от
сервера. </small></p>

<p><small>С этого момента по соединению начинается
обмен данными. Ничего не мешает тому, чтобы
продолжить обсуждение опций, однако этого не
происходит. Сегмент&nbsp;12 содержит приглашение
login: от сервера. Сегмент 14 это первый символ,
который мы вводим в качестве нашего имени, его
эхо возвращается в сегменте 15. Подобный тип
интерактивного траффика мы видели в разделе <a HREF="tcp19.html#t192000">&quot;Интерактивный ввод&quot;</a> главы
19 в случае Rlogin: клиент посылает один символ за
один раз, а сервер осуществляет эхо.</small></p>

<p>&nbsp;</p>


<p>Обсуждение опций на
рисунке 26.12 инициировано клиентом, однако в нашей
книге мы не раз использовали Telnet клиента, чтобы
подсоединиться к стандартным серверам, таким как
сервер времени или эхо сервер, для того чтобы
продемонстрировать различные характеристики TCP.
Когда мы рассматривали обмен пакетами в этих
примерах, как, например, на <a HREF="tcp18.html#t182002">рисунке
18.1</a>, то никогда не видели, чтобы клиент
инициировал обсуждение опций. Почему? Unix Telnet
клиент никогда не начинает обсуждение опций,
если указан номер порта, отличный от
стандартного порта Telnet (23). Это позволяет Telnet
клиенту с использованием стандартного NVT
обмениваться данными с другими, не-Telnet серверами.
Мы пользовались этим с <a NAME="t265024"></a>daytime, <a NAME="t265025"></a>echo
и <a NAME="t265026"></a>discard серверами и будем использовать
это с FTP и SMTP серверами в следующих главах.</p>


<p>&nbsp;</p>
<i><b>

<p><a NAME="t265027"></a>Линейный режим (Linemode) </p>
</b></i>

<p><small>Чтобы увидеть опцию линейного режима Telnet в
действии, мы запустим клиента на хосте bsdi и
подключимся к серверу <a NAME="t265028"></a>4.4BSD на
vangogh.cs.berkeley.edu. И <a NAME="t265029"></a>BSD/386, и 4.4BSD
поддерживают эту опцию. </small></p>

<p><small>Мы не будем рассматривать все пакеты или
обсуждаемые опции и подопции, потому что оно
подобно тому, что мы привели в предыдущем
примере. Вместо этого рассмотрим особенности
обсуждения этой опции.</small></p>

<p><small>&nbsp;</small> 

<ol>
  <li><small>Сервер 4.4BSD поддерживает больше опций,
    доступных к обсуждению, чем BSD/386: размер окна,
    локальное управление потоком данных, состояние
    опций, прием переменных окружения и скорость
    терминала. </small></li>
  <li><small>Сервер 4.4BSD старается обсудить более новые
    опции, чем те, которые поддерживаются клиентом
    BSD/386: аутентификация (позволяет избежать
    отправки пользовательского <a NAME="t265030"></a>пароля в
    виде открытого текста по соединению). </small></li>
  <li><small>Клиент посылает опцию WILL LINEMODE, сервер
    отвечает DO LINEMODE, так как он поддерживает эту
    опцию. Клиент отправляет серверу 16 специальных
    символов в качестве подопции. Это текущие
    значения специальных символов терминала на
    хосте клиента: символ прерывания, символ конца
    файла и так далее. Сервер отправляет подопции
    клиенту, которые сообщают ему, как обрабатывать
    все входные строки и как осуществлять все
    функции редактирования (удаление символа,
    удаление строки и так далее). Клиент отправляет
    серверу только завершенные строки. Сервер также
    сообщает клиенту, как транслировать любые
    символы прерывания или сигнальные символы в
    соответствующие символы Telnet. Например, если
    символ прерывания - Control-C, и мы вводим Control-C, чтобы
    прервать текущий процесс на сервере, клиент
    посылает серверу Telnet команду &quot;прервать
    процесс&quot; (&lt;IAC, IP&gt;). </small></li>
  <li><small>Интересно посмотреть, что происходит, когда
    мы вводим пароль. В случае Rlogin или режима Telnet один
    символ за раз, когда сервер осуществляет эхо, он
    не отражает эхом символы пароля. В случае
    линейного режима, однако, эхо осуществляется
    самим клиентом. Он справляется с этой задачей с
    помощью следующего обмена: </small><dl>
      <dt><small>(a) </small></dt>
      <dd><small>Сервер отправляет WILL ECHO, сообщая клиенту,
        что сервер будет осуществлять отражение эхом. </small></dd>
      <dt><small>(b) </small></dt>
      <dd><small>Клиент отвечает DO ECHO. </small></dd>
      <dt><small>(c) </small></dt>
      <dd><small>Сервер отправляет строку Password: клиенту, а
        клиент выводит эту строку на терминал. </small></dd>
      <dt><small>(d) </small></dt>
      <dd><small>Мы вводим пароль, клиент посылает его
        серверу при нажатии клавиши RETURN. Пароль не
        отражается эхом, так как клиент считает, что это
        сделает сервер. </small></dd>
      <dt><small>(e) </small></dt>
      <dd><small>Сервер посылает 2-байтовую
        последовательность CR, LF, чтобы переместить
        курсор, так как символ RETURN, который завершил ввод
        пароля, не был отображен эхом. </small></dd>
      <dt><small>(f) </small></dt>
      <dd><small>Сервер посылает WONT ECHO. </small></dd>
      <dt><small>(g) </small></dt>
      <dd><small>Клиент отвечает DONT ECHO. Клиент
        восстанавливает отражение эхом. </small></dd>
    </dl>
  </li>
</ol>

<p>&nbsp;</p>

<p><small>После того как мы зашли удаленным
терминалом, клиент строит полные строки и
отправляет их серверу. Это и есть назначение
опции линейного режима. Она уменьшает количество
сегментов, которыми обмениваются клиент и
сервер, а также предоставляет более быстрый
отклик на введенные клиентом символы, (например,
эхо и редактирование). На рисунке 26.14 показан
обмен пакетами, при вводе команды</small></p>

<p>&nbsp;</p>


<p>vangogh % <b>date</p>
</b>

<p>&nbsp;</p>

<p><small>по Telnet соединению с использованием
линейного режима. (Мы удалили всю информацию о
типе сервиса и объявления окна.)<a NAME="t265031"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t26_1400.jpg" WIDTH="519" HEIGHT="346"></small></p>


<p ALIGN="CENTER"><small>Рисунок 26.14 Отправка команды от
клиента к серверу с использованием линейного
режима Telnet.</small></p>

<p>&nbsp;</p>

<p><small>Если мы сравним это с той же самой командой,
вводимой в Rlogin (<a HREF="tcp19.html#t192001">рисунок 19.2</a>), то
увидим, что линейный режим Telnetа использует два
сегмента (один с данными и один для
подтверждения, что в целом составляет 86 байт,
включая IP и TCP заголовки), тогда как Rlogin
использует 15 сегментов (5 с введенными данными, 5 с
отраженными эхом данными, 5 с подтверждениями,
всего 611 байт). Нетрудно догадаться, в чью пользу
это сравнение! </small></p>

<p><small>Что если на сервере мы запустим приложение,
которое требует использовать режим
единственного символа? (Например, редактор vi.) В
этом случае будет происходить следующее.</small></p>

<p><small>&nbsp;</small> 

<ol>
  <li><small>Когда приложение стартует на сервере и
    изменяет режим своего псевдотерминала, Telnet
    сервер уведомляется о том, что требуется режим
    единственного символа. Сервер посылает WILL ECHO
    клиенту вместе с подопцией линейного режима,
    которая сообщает клиенту о том, что не нужно
    составлять полные строки, а вместо этого
    необходимо посылать один символ за один раз. </small></li>
  <li><small>Клиент отвечает DO ECHO и подтверждает
    подопцию линейного режима. </small></li>
  <li><small>Приложение запускается на сервере. Каждый
    символ, который мы печатаем, отправляется
    серверу сам по себе (естественно используется
    алгоритм Нагла), при этом сервер не требует
    отражения эхом. </small></li>
  <li><small>Когда приложение завершает работу и
    восстанавливает режим псевдотерминала, об этом
    уведомляется Telnet сервер. Сервер отправляет WONT ECHO
    клиенту вместе с подопцией линейного режима,
    которая сообщает клиенту о необходимости снова
    составлять полные строки. </small></li>
  <li><small>Клиент отвечает DONT ECHO и подтверждает
    подопцию линейного режима. </small></li>
</ol>

<p>&nbsp;</p>

<p><small>Отличие этого сценария от того, который
реализуется при вводе пароля, показывает, что
функция отражения эхом и символ за один раз, а
также строка за один раз, это независимые
характеристики. Когда мы вводим пароль, эхо
должно быть отключено, при этом активизирован
режим строка за один раз. Для полноэкранных
приложений, таких как редакторы, эхо отключается
и требуется режим символ за один раз. </small></p>

<p><small>На рисунке 26.15 показаны различные режимы,
которые мы видели для Telnet и Rlogin.<a NAME="t265032"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="794">
  <tr>
    <td WIDTH="31%" VALIGN="MIDDLE" ROWSPAN="2" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Приложение</small></td>
    <td WIDTH="38%" VALIGN="MIDDLE" COLSPAN="2" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Клиент посылает</small></td>
    <td WIDTH="7%" VALIGN="MIDDLE" ROWSPAN="2" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Эхо клиента?</small></td>
    <td WIDTH="24%" VALIGN="MIDDLE" ROWSPAN="2" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Пример</small></td>
  </tr>
  <tr>
    <td WIDTH="17%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>символ
    за раз</small></td>
    <td WIDTH="21%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>строка
    за раз</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>Rlogin</small></td>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="21%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="7%" VALIGN="TOP"><p ALIGN="CENTER"><small>нет</small></td>
    <td WIDTH="24%" VALIGN="TOP">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>Telnet, символ за раз</small></td>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="21%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="7%" VALIGN="TOP"><p ALIGN="CENTER"><small>нет</small></td>
    <td WIDTH="24%" VALIGN="TOP">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>Telnet, линейный режим</small></td>
    <td WIDTH="17%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="21%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="7%" VALIGN="TOP"><p ALIGN="CENTER"><small>да</small></td>
    <td WIDTH="24%" VALIGN="TOP"><small>обычные команды</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>Telnet, линейный режим</small></td>
    <td WIDTH="17%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="21%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="7%" VALIGN="TOP"><p ALIGN="CENTER"><small>нет</small></td>
    <td WIDTH="24%" VALIGN="TOP"><small>ввод пароля</small></td>
  </tr>
  <tr>
    <td WIDTH="31%" VALIGN="TOP"><small>Telnet, линейный режим</small></td>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="21%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="7%" VALIGN="TOP"><p ALIGN="CENTER"><small>нет</small></td>
    <td WIDTH="24%" VALIGN="TOP"><small>редактор vi</small></td>
  </tr>
</table>


<p><small>Рисунок 26.15 Сравнение режимов Rlogin и Telnet в
действии.</small></p>

<p>&nbsp;</p>
<i><b>

<p><a NAME="t265033"></a>Режим строка за раз (Kludge Line Mode) </p>
</b></i>

<p><small>Мы видели на рисунке 26.11, что более новые
сервера, которые поддерживают опцию линейного
режима, входят в режим строка за раз, если клиент
не поддерживает линейный режим. Мы также
упомянули, что все клиенты и серверы на этом
рисунке поддерживают режим строка за раз, однако
это не было установкой по умолчанию и должно быть
специально включено сервером или пользователем.
Давайте посмотрим, как включается режим строка
за раз с использованием опций Telnet. </small></p>

<p><small>Во-первых, мы опишем, как сервер <a NAME="t265034"></a>BSD/386
обсуждает этот режим, когда клиент не
поддерживает <a NAME="t265035"></a>реальный линейный
режим.</small></p>

<p><small>&nbsp;</small> 

<ol>
  <li><small>Когда клиент отказывает на требование
    сервера включить линейный режим, сервер посылает
    опцию DO TIMING MARK. RFC 860 <a NAME="t265036"></a>[Postel and Reynolds 1983f]
    определяет эту опцию Telnet. Она предназначена для
    того, чтобы оба участника обмена могли
    синхронизироваться друг с другом. Мы увидим, как
    это происходит, позже в этом разделе, когда будем
    рассматривать прерывание от пользователя.
    Использование этой опции заключается в том,
    чтобы определить, поддерживает ли клиент режим
    строка за раз. </small></li>
  <li><small>Клиент отвечает WILL TIMING MARK, что указывает на
    то, что он поддерживает опцию строка за раз. </small></li>
  <li><small>Сервер посылает опцию WONT SUPPRESS GO AHEAD вместе с
    опцией WONT ECHO, сообщая о том, что он хочет
    выключить эти две опции. Мы упоминали ранее, что
    режим символ за раз подразумевает, что обе опции
    SUPPRESS GO AHEAD и ECHO включены, таким образом,
    выключение этих опций стартует режим строка за
    раз. </small></li>
  <li><small>Клиент отвечает DONT SUPPRESS GO AHEAD и DONT ECHO. </small></li>
  <li><small>Сервер посылает приглашение login:, мы вводим
    имя. Ввод отправляется серверу в виде полной
    строки и отражается локальным эхом клиентом. </small></li>
  <li><small>Сервер посылает строку Password: вместе с опцией
    WILL ECHO. При вводе пароля отражение эхом
    выключается, так как Telnet клиент считает, что
    сервер ответит эхом. Клиент отвечает DO ECHO. </small></li>
  <li><small>Мы вводим пароль. Он отправляется клиентом
    на сервер в виде полной строки. </small></li>
  <li><small>Эхо снова включается, после того как сервер
    отправил WONT ECHO, на что клиент отвечает DONT ECHO. </small></li>
</ol>

<p>&nbsp;</p>

<p><small>С этого момента обычные команды
обрабатываются так же, как и с опцией линейного
режима. Клиент осуществляет все редактирование и
отражение эхом, отправляя серверу полные строки. </small></p>

<p><small>Мы упоминали ранее, что все клиенты и
сервера на рисунке 26.11, которые помечены как
&quot;char&quot;, поддерживают режим строки за раз,
однако по умолчанию стартуют в режиме символ за
раз. Мы можем увидеть, как происходит обсуждение,
когда мы сообщаем клиенту о необходимости войти
в линейный режим:</small></p>

<p>&nbsp;</p>


<p><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; клиент
это sun, сервер это svr4<br>
svr4 %
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим
Control-], чтобы пообщаться с Telnet клиентом <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (эхо
выключено)<br>
<br>
telnet&gt; <b>status </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; проверяем,
находимся ли мы в режиме символ за раз<br>
Connected to svr4.tuc.noao.edu<br>
Operating in character-at-a-time mode.<br>
Escape character is '^]'.<br>
<br>
telnet&gt; <b>toggle options </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; просмотрим
обработку опций<br>
Will show option processing.<br>
<br>
telnet&gt; <b>mode line </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; переключимся
в режим строки за раз<br>
SENT dont SUPPRESS GO AHEAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; клиент
отправляет эти две опции<br>
SENT dont ECHO<br>
RCVD wont SUPPRESS GO AHEAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; и сервер
отвечает на обе WONT<br>
RCVD wont ECHO<br>
</p>


<p>&nbsp;</p>

<p><small>Telnet сессия помещается в режим строки за раз,
при этом обе опции SUPPRESS GO AHEAD и ECHO выключены. </small></p>

<p><small>Если мы запустим приложение, такое как
редактор vi, на сервере, то будем иметь те же
проблемы, что мы имели с опцией линейного режима.
Серверу необходимо сообщить клиенту о
необходимости переключиться из режима строка за
раз в режим символ за раз, пока работает это
приложение, а затем переключиться обратно, когда
оно закончит свою работу. Используется следующая
техника.</small></p>

<p><small>&nbsp;</small> 

<ol>
  <li><small>Telnet сервер знает, что он должен перейти в
    режим символ за раз, потому что приложение меняет
    режим на своем псевдотерминале, о чем
    уведомляется сервер. Сервер посылает WILL SUPPRESS GO
    AHEAD и WILL ECHO, это помещает клиента в режим символ за
    раз. </small></li>
  <li><small>Клиент отвечает DO SUPPRESS GO AHEAD и WILL ECHO. </small></li>
  <li><small>Приложение запускается на сервере. </small></li>
  <li><small>Когда приложение прекращает свою работу и
    изменяет режим своего псевдотерминала, Telnet
    сервер помещает клиента обратно в режим строка
    за раз. Он посылает WONT SUPPRESS GO AHEAD и WONT ECHO. </small></li>
  <li><small>Клиент отвечает DONT SUPPRESS GO AHEAD и DONT ECHO,
    указывая на то, что он вернулся в режим строка за
    раз.</small></li>
</ol>

<p>&nbsp;</p>

<p><small>На рисунке 26.16 показаны различные установки
опций SUPPRESS GO AHEAD и ECHO для режимов символ за раз и
строка за раз.<a NAME="t265037"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="745">
  <tr>
    <td WIDTH="21%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Режим</small></td>
    <td WIDTH="19%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>SUPPRESS
    GO AHEAD</small></td>
    <td WIDTH="13%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>ECHO</small></td>
    <td WIDTH="48%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Пример</small></td>
  </tr>
  <tr>
    <td WIDTH="21%" VALIGN="TOP"><small>символ за раз</small></td>
    <td WIDTH="19%" VALIGN="TOP"><p ALIGN="CENTER"><small>вкл.</small></td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>вкл.</small></td>
    <td WIDTH="48%" VALIGN="TOP"><small>редактор vi в режиме
    строка за раз</small></td>
  </tr>
  <tr>
    <td WIDTH="21%" VALIGN="TOP"><small>строка за раз</small></td>
    <td WIDTH="19%" VALIGN="TOP"><p ALIGN="CENTER"><small>выкл.</small></td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>выкл.</small></td>
    <td WIDTH="48%" VALIGN="TOP"><small>обычные команды</small></td>
  </tr>
  <tr>
    <td WIDTH="21%" VALIGN="TOP"><small>строка за раз</small></td>
    <td WIDTH="19%" VALIGN="TOP"><p ALIGN="CENTER"><small>выкл.</small></td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>вкл.</small></td>
    <td WIDTH="48%" VALIGN="TOP"><small>ввод пароля</small></td>
  </tr>
</table>


<p><small>Рисунок 26.16 Установки Telnet опций при режиме
строка за раз.</small></p>

<p>&nbsp;</p>
<i><b>

<p><a NAME="t265038"></a>Линейный режим: символ прерывания
от клиента</p>
</b></i>

<p><small>Давайте посмотрим, что делает Telnet, когда
клиент вводит символ прерывания. Мы открыли
сессию между клиентом bsdi и сервером vangogh.cs.berkeley.edu.
На рисунке 26.17 показана временная диаграмма того,
что происходит, когда вводится символ
прерывания. (Мы удалили объявления окна и тип
сервиса.) </small></p>

<p><small>В сегменте 1 символ прерывания (обычно Control-C
или DELETE) конвертируется в команду Telnet
&quot;прерывание процесса&quot; (IP - interrupt process): &lt;IAC,
IP&gt;. Следующие 3 байта, &lt;IAC, DO, TM&gt;, содержат опцию
Telnet DO TIMING MARK. Эта метка отправляется клиентом и на
нее должен быть получен ответ либо WILL, либо WONT. В
любом случае все данные получены от сервера,
перед тем как выдается отклик (за исключением
команд Telnet). Это метка синхронизации от клиента к
серверу и обратно. Сегмент 1 не посылается с
использованием <a NAME="t265039"></a>режима срочности TCP.<a NAME="t265040"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t26_1700.jpg" WIDTH="517" HEIGHT="376"></small></p>


<p ALIGN="CENTER"><small>Рисунок 26.17 Введение символа
прерывания в процессе функционирования
линейного режима.</small></p>

<p>&nbsp;</p>


<p>Требование к хостам <a NAME="t265041"></a>Host Requirements RFC указывает, что IP команда
должна быть послана с использованием сигнала
синхронизации Telnet. Если это сделано, за &lt;IAC, IP&gt;
должно следовать &lt;IAC, DM&gt;, с указателем
срочности, указывающим на DM байт. Большинство Unix
Telnet клиентов имеют опцию, которая отправляет IP
команду с сигналом синхронизации, однако эта
опция по умолчанию выключена (как мы здесь и
видели).</p>


<p>&nbsp;</p>

<p><small>Сегмент 2 это отклик сервера на опцию DO TIMING
MARK. Он следует в сегментах 3 и 4 за сигналом
синхронизации Telnet: &lt;IAC, DM&gt;. <a NAME="t265042"></a>Указатель
срочности в сегменте 3 указывает на DM байт,
который отправляется в сегменте 4. </small></p>

<p><small>Если в очередь поставлено полное окно
данных или оно в пути от сервера к клиенту, все
эти данные будут отброшены клиентом после
отправки команды прерывания процесса в сегменте
1. Даже если управление потоком данных TCP
запретило серверу отправлять данные в сегментах
2, 3 и 4, указатель срочности все равно посылается.
Это аналогично тому, что мы видели в случае Rlogin на
рисунке 26.7. </small></p>

<p><small>Почему сигнал синхронизации посылается в
виде двух сегментов (3 и 4)? Мы рассмотрели это в
разделе <a HREF="tcp20.html#t208000">&quot;Режим срочности (Urgent
Mode)&quot;</a> главы 20, это связано с указателем
срочности TCP. Требование к хостам <a NAME="t265043"></a>Host
Requirements RFC говорит, что он должен указывать на
последний байт срочных данных, тогда как
большинство Berkeley реализаций указывают на 1 байт
позади последнего байта срочных данных.
(Обратитесь к рисунку 26.6, на котором указатель
срочности указывает на 1 байт позади командного
байта.) Сервер Telnet специально пишет первый байт
сигнала синхронизации как срочные данные, зная,
что указатель срочности будет (неверно)
указывать на следующий байт, который он запишет
(метка данных, DM), однако эта первая запись с
байтом IAC посылается немедленно, вместе с
указателем срочности, который следует в
следующем сегменте за DM байтом. </small></p>

<p><small>Последний сегмент данных, сегмент 6, это
следующее приглашение shellа от сервера.</small></p>
<u><b>

<p><a NAME="t266000"></a>Краткие выводы</p>
</b></u>

<p><small>В этой главе показано функционирование
приложений Rlogin и Telnet. Оба предоставляют заход
удаленным терминалом с хоста клиента на хост
сервера, а также позволяют запускать программы
на сервере. </small></p>

<p><small>Между этими приложениями существуют
отличия. Rlogin подразумевает, что на обоих концах
соединения присутствуют Unix хосты, поэтому
существует только одна опция. Это простой
протокол. Telnet не ограничивает, какая
операционная система используется на обоих
концах соединения. Telnet разработан для того, чтобы
функционировать между различными операционными
системами. </small></p>

<p><small>Чтобы поддерживать разнородное окружение,
Telnet предоставляет обсуждение опций между
клиентом и сервером. Это позволяет общаться
клиентам и серверам, а также позволяет добавлять
новые опции. </small></p>

<p><small>Мы рассмотрели процесс обсуждения опций
Telnet и видели, что три типа передачи данных: символ
за один раз, строка за раз и реальный линейный
режим. Сегодня существует тенденция по
направлению ко вводу строки за раз, когда это
возможно, чтобы уменьшить сетевой траффик и
обеспечить лучший отклик интерактивному
пользователю при редактировании строк и
отражения введенного эхом. </small></p>

<p><small>На рисунке 26.18 сравниваются различные
характеристики, предоставляемые Rlogin и Telnet.<a NAME="t266001"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="750">
  <tr>
    <td WIDTH="32%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Характеристика</small></td>
    <td WIDTH="34%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Rlogin</small></td>
    <td WIDTH="34%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Telnet</small></td>
  </tr>
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><small>транспортный
    протокол</small></td>
    <td WIDTH="34%" VALIGN="TOP"><small>Одно TCP соединение.
    Используется <a NAME="t266002"></a>режим срочности. </small></td>
    <td WIDTH="34%" VALIGN="TOP"><small>Одно TCP соединение.
    Используется режим срочности.</small></td>
  </tr>
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><small>пакетный режим</small></td>
    <td WIDTH="34%" VALIGN="TOP"><small>Всегда символ за
    один раз, удаленное эхо.</small></td>
    <td WIDTH="34%" VALIGN="TOP"><small>Общий режим по
    умолчанию - символ за один раз, удаленное эхо.
    Поддерживается режим строки за раз с эхом от
    клиента. Новые опции для реального линейного
    режима с эхом от клиента. Если приложение на
    сервере требует режим символ за один раз - он
    поддерживается всегда.</small></td>
  </tr>
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><small>управление потоком
    данных</small></td>
    <td WIDTH="34%" VALIGN="TOP"><small>Обычно
    осуществляется клиентом, однако может быть
    выключено сервером.</small></td>
    <td WIDTH="34%" VALIGN="TOP"><small>Обычно
    осуществляется сервером, иногда позволяется
    делать клиенту.</small></td>
  </tr>
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><small>тип терминала</small></td>
    <td WIDTH="34%" VALIGN="TOP"><small>Присутствует
    всегда.</small></td>
    <td WIDTH="34%" VALIGN="TOP"><small>Опционально,
    обычно поддерживается.</small></td>
  </tr>
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><small>скорость терминала</small></td>
    <td WIDTH="34%" VALIGN="TOP"><small>Присутствует
    всегда.</small></td>
    <td WIDTH="34%" VALIGN="TOP"><small>Опционально.</small></td>
  </tr>
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><small>размер окна</small></td>
    <td WIDTH="34%" VALIGN="TOP"><small>Опционально
    поддерживается большинством серверов.</small></td>
    <td WIDTH="34%" VALIGN="TOP"><small>Опционально.</small></td>
  </tr>
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><small>переменные
    окружения </small></td>
    <td WIDTH="34%" VALIGN="TOP"><small>Не поддерживается.</small></td>
    <td WIDTH="34%" VALIGN="TOP"><small>Опционально.</small></td>
  </tr>
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><small>автоматический login</small></td>
    <td WIDTH="34%" VALIGN="TOP"><small>По умолчанию. Может
    появиться приглашение ввести пароль, который
    посылается в виде открытого текста. Более новые
    версии поддерживают <a NAME="t266004"></a>Kerberos. </small></td>
    <td WIDTH="34%" VALIGN="TOP"><small>По умолчанию
    необходимо ввести имя и <a NAME="t266003"></a>пароль,
    который отправляется в виде открытого текста.
    Более новыми версиями предоставляется опция
    аутентификации.</small></td>
  </tr>
</table>


<p><small>Рисунок 26.18 Краткое описание характеристик,
предоставляемых Rlogin и Telnet.</small></p>

<p>&nbsp;</p>

<p><small>Telnet и Rlogin серверы обычно устанавливают TCP
опцию <a NAME="t266005"></a>&quot;оставайся в живых&quot; (keepalive)
(<a HREF="tcp23.html">глава 23</a>), если она поддерживается
реализацией TCP сервера, чтобы определить момент
выхода из строя хоста клиента. Оба приложения
также используют <a NAME="t266006"></a>режим срочности TCP,
чтобы посылать команды сервера клиенту, даже
если поток данных в этом направлении был
остановлен управлением потока данных.</small></p>
<i><b>

<p>Упражнения</b></i> 

<ol>
  <li>Найдите все <a NAME="t266007"></a>задержанные
    ACK на рисунке 26.5.</li>
  <li>Почему был отправлен сегмент номер 12 на рисунке
    26.7?</li>
  <li>Мы говорили, что Rlogin клиент должен использовать <a NAME="t266008"></a>зарезервированный порт (глава 1, раздел
    <a HREF="tcp01.html#t019000">&quot;Номера портов&quot;</a>). (Обычно,
    Rlogin клиент использует зарезервированный порт в
    диапазоне 512-1023.) Как это ограничение отражается
    на хосте? Существует ли способ обойти это?</li>
  <li>Прочитайте RFC 1097, описывающий Telnet опцию
    subliminal-message.</li>
</ol>

<hr>

</body>
</html>

<html>

<head>
<title>IP: Протокол Internet</title>

<meta http-equiv="Content-type" content="text/html; charset=koi8-r">
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>




<p><a NAME="t030000"></a>Глава 3 IP: протокол Internet</p>
<u>

<p><b><a NAME="t031000"></a>Введение</p>
</b></u>

<p><small><a NAME="t031001"></a>IP это рабочая лошадь семейства
протоколов TCP/IP. TCP, UDP, ICMP и IGMP передают свои данные
как IP датаграммы (рисунок 1.4). Один факт часто
удивляет новичков TCP/IP, особенно тех кто работал с
X.25 или SNA, этот факт заключается в том, что IP
ненадежный протокол, предоставляющий сервис
доставки датаграмм без соединения. </small></p>

<p><small>Под словом <a NAME="t031002"></a>ненадежный мы
подразумеваем то, что не существует гарантии
того, что IP датаграмма успешно достигнет пункта
назначения. Однако IP предоставляет определенный
сервис обработки некоторых событий. Когда
что-нибудь идет не так как хотелось бы, как
например, временное переполнение буфера у
маршрутизатора, IP применяет простой алгоритм
обработки ошибок: он отбрасывает датаграмму и
старается послать ICMP сообщение отправителю.
Любая требуемая надежность должна быть
обеспечена верхними уровнями (например TCP). </small></p>

<p><small>Термин <a NAME="t031003"></a>без соединения (connectionless)
означает, что IP не содержит никакой информации о
продвижении датаграмм. Каждая датаграмма
обрабатывается независимо от других. Это также
означает, что может быть доставлена испорченная
датаграмма. Если источник отправляет две
последовательные датаграммы (первая A, затем B) в
один и то же пункт назначения, каждая из них
маршрутизируется независимо и может пройти по
разным маршрутам, датаграмма B может прибыть
раньше чем A. </small></p>

<p><small>В этой главе мы кратко рассмотрим поля IP
заголовка, опишем IP маршрутизацию и коротко
опишем разделение на подсети. Также мы
рассмотрим две очень полезные команды: <a NAME="t031004"></a>ifconfig
и <a NAME="t031005"></a>netstat. Более подробно некоторые поля
IP заголовка будут описаны в следующих главах.
Именно тогда мы точно расскажем, как
используются те или иные поля. RFC 791 [<a NAME="t031006"></a>Postel
1981a] является официальной спецификацией для IP.</small></p>
<u><b>

<p><a NAME="t032000"></a>IP заголовок</p>
</b></u>

<p><small>На рисунке 3.1 показан формат IP датаграммы.
Стандартный размер IP заголовка составляет 20
байт, если не присутствуют опции.<a NAME="t032001"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t3_10000.jpg" WIDTH="526" HEIGHT="352"></small></p>


<p ALIGN="CENTER"><small><a NAME="t032012"></a>Рисунок 3.1 IP датаграмма,
поля IP заголовка.</small></p>

<p>&nbsp;</p>

<p><small>Мы покажем как выглядят заголовки
протоколов TCP/IP на рисунке 3.1. Старший значащий
бит имеет номер 0 (слева), а младший значащий бит
из 32-х бит имеет номер 31 и показан справа. </small></p>

<p><small>4 байта из 32-битного значения передаются в
следующем порядке: сначала биты 0 - 7, затем биты 8 -
15, затем 16 - 23 и, наконец, 24 - 31. Такой порядок
движения байтов называется <a NAME="t032003"></a>big endian
(Примечание переводчика: big endian - метод хранения
или передачи данных, при котором старший
значащий бит или байт стоит первым) и обязателен
для всех двоичных целых чисел в TCP заголовках при
их передаче по сети. Это называется <a NAME="t032004"></a>порядок
сетевых байтов (network byte order). Машины, которые
хранят двоичные целые в других форматах, как
например в формате <a NAME="t032005"></a>little endian (little endian -
метод хранения или передачи данных, при котором
младший значащий бит или байт стоит первым),
должны конвертировать значения заголовков в
соответствующий порядок сетевых байтов перед
передачей данных. </small></p>

<p><small>Текущая версия протокола - 4, поэтому IP
иногда называется <a NAME="t032006"></a>IPv4. В разделе <a HREF="#t03A000">&quot;Будущее IP&quot;</a> рассматриваются
некоторые предложения для новых версий IP. </small></p>

<p><small><a NAME="t032007"></a>Длина заголовка (header length) это
количество 32-битных слов в заголовке, включая
любые опции. Так как это 4-битное поле, оно
ограничивает размер заголовка в 60 байт. В <a HREF="tcp08.html">главе 8</a> мы увидим, что это ограничение
сильно влияет на некоторые опции, такие как опция
записи маршрута. Обычная величина в этом поле
(когда отсутствуют опции) - 5. </small></p>

<p><small><a NAME="t032008"></a>Поле типа сервиса (TOS - type-of-service)
состоит из 3-битного поля приставки (которое в
настоящее время игнорируется), 4 бит TOS и
неиспользуемого бита, который должен быть равен
0. 4 бита TOS следующие: минимальная задержка,
максимальная пропускная способность,
максимальная надежность и минимальная
стоимость. Только один из этих 4 бит может быть
установлен в единицу одновременно. Если все 4
бита равны 0, это означает обычный сервис. RFC 1340 <a NAME="t032009"></a>[Reynolds and Postel 1992] указывает, как эти биты
должны быть установлены для всех стандартных
приложений. RFC 1349 [<a NAME="t032010"></a>Almquist 1992] содержит
некоторые коррекции для этого RFC и более
детальное описание характеристики TOS. </small></p>

<p><small>На рисунке 3.2 показаны рекомендованные
значения поля TOS для различных приложений. В
последней колонке приведено шестнадцатиричное
значение, которое мы увидим в выводе <a NAME="t032011"></a>tcpdump
позже в этой главе.<a NAME="t032002"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="850">
  <tr>
    <td WIDTH="16%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Приложение</small></td>
    <td WIDTH="17%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Минимизация
    задержки</small></td>
    <td WIDTH="25%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Максимизация
    производительности</small></td>
    <td WIDTH="14%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Максимизация
    надежности</small></td>
    <td WIDTH="16%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Минимизация
    стоимости</small></td>
    <td WIDTH="14%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Шестнадцатиричное
    значение</small></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><small>Telnet/Rlogin</small></td>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="25%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0x10</small></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><small>FTP</small></td>
    <td WIDTH="17%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="25%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="16%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="RIGHT"><small>управление</small></td>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="25%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0x10</small></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="RIGHT"><small>данные</small></td>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="25%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0x08</small></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="RIGHT"><small>любые
    данные</small></td>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="25%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0x08</small></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><small>TFTP</small></td>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="25%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0x10</small></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><small>SMTP</small></td>
    <td WIDTH="17%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="25%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="16%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="RIGHT"><small>фаза
    команд</small></td>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="25%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0x10</small></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="RIGHT"><small>фаза
    данных</small></td>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="25%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0x08</small></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><small>DNS</small></td>
    <td WIDTH="17%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="25%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="16%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="RIGHT"><small>UDP запрос</small></td>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="25%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0x10</small></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="RIGHT"><small>TCP запрос</small></td>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="25%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0x00</small></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="RIGHT"><small>передача
    зоны</small></td>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="25%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0x08</small></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><small>ICMP</small></td>
    <td WIDTH="17%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="25%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="16%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="RIGHT"><small>ошибка</small></td>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="25%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0x00</small></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="RIGHT"><small>запрос</small></td>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="25%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0x00</small></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><small>любой IGP</small></td>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="25%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0x04</small></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><small>SNMP</small></td>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="25%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0x04</small></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><small>BOOTP</small></td>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="25%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0x00</small></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><small>NNTP</small></td>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="25%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>0x02</small></td>
  </tr>
</table>


<p><small>Рисунок 3.2 Рекомендованные значения поля
типа сервиса (TOS). </small></p>

<p>&nbsp;</p>

<p><small>Диалоговые приложения, Telnet и Rlogin, требуют
свести к минимуму задержку, так как они
используются человеком интерактивно и
осуществляют небольшую передачу данных.
Передача файлов с использованием FTP, с другой
стороны, требует максимальной пропускной
способности. Максимальная надежность необходима
для сетевого управления (SNMP) и для протоколов
маршрутизации. Новости Usenet (<a NAME="t032013"></a>NNTP) это
единственное приложение, которое требует
минимизации стоимости. </small></p>

<p><small>Характеристика TOS, в настоящее время,
большинством реализаций TCP/IP не поддерживается,
однако она включена в новые системы, начиная с <a NAME="t032014"></a>4.3BSD Reno. Некоторые протоколы
маршрутизации, такие как OSPF и <a NAME="t032015"></a>IS-IS,
имеют возможность принимать решение о
маршрутизации на основе этого поля.</small></p>

<p>&nbsp;</p>


<p><a NAME="t032016"></a>В разделе <a HREF="tcp02.html#t02A000">&quot;Вычисление загруженности
последовательной линии&quot;</a> главы 2 мы
упомянули, что драйверы SLIP обычно осуществляют
построение очереди на основе типа сервиса, что
позволяет диалоговому траффику обрабатываться
перед передачей данных. Так как большинство
реализаций не используют поле TOS, это построение
очереди делается с помощью драйвера SLIP, который
смотрит в <a NAME="t032017"></a>поле протокола (для того
чтобы определить, является ли данный сегмент TCP
сегментом или нет) и затем проверяет номера
портов TCP источника и назначения, чтобы
определить, принадлежит ли этот номер
диалоговому сервису. </p>


<p>&nbsp;</p>

<p><small><a NAME="t032018"></a>Поле полной длины (total length)
содержит полную длину IP датаграммы в байтах.
Благодаря этому полю и <a NAME="t032019"></a>полю длины
заголовка, мы знаем, с какого места начинаются
данные в IP датаграмме и их длину. Так как это поле
состоит из 16 бит, максимальный размер IP
датаграммы составляет 65535 байт. (Обратитесь к
рисунку 2.5 и обратите внимание, что Hyperchannel имеет
MTU, равный 65535. В действительности это не MTU - здесь
используется максимально возможный размер IP
датаграммы). Это поле изменяется в момент
фрагментации и повторной сборки датаграммы, что
будет описано в разделе <a HREF="tcp11.html#t115000">&quot;Фрагментация
IP&quot;</a> главы 11. </small></p>

<p><small>Несмотря на то что существует возможность
отправить датаграмму размером 65535 байт,
большинство канальных уровней поделят подобную
датаграмму на фрагменты. Более того, от хоста не
требуется принимать датаграмму размером больше
чем 576 байт. TCP делит пользовательские данные на
части, поэтому это ограничение обычно не
оказывает влияния на TCP. Что касается UDP, услугами
которого пользуются многие приложения (RIP, TFTP, BOOTP,
DNS, SNMP), то он ограничивает себя 512 байтами
пользовательских данных, что даже меньше
ограничения в 576 байт. Большинство приложений в
настоящее время (особенно те, которые
поддерживают NFS - Network File System) позволяют
использовать IP датаграмму размером 8192 байта. </small></p>

<p><small>Однако, <a NAME="t032020"></a>поле полной длины
требуется в IP заголовке для некоторых каналов
(как например, Ethernet), который дополняет маленькие
фреймы до минимальной длины. Несмотря на то что
минимальный размер фрейма Ethernet составляет 46 байт
(рисунок 2.1), IP датаграмма может быть еще меньше.
Если поле полной длины не было представлено, IP
уровень не будет знать, сколько 46-байтных фреймов
Ethernet получится из IP датаграммы. </small></p>

<p><small><a NAME="t032021"></a>Поле идентификации (identification)
уникально идентифицирует каждую датаграмму,
отправленную хостом. Значение, хранящееся в поле,
обычно увеличивается на единицу с посылкой
каждой датаграммы. Мы обратимся к этому полю,
когда будем рассматривать фрагментацию и <a NAME="t032022"></a>обратную сборку в разделе <a HREF="tcp11.html#t115000">&quot;Фрагментация IP&quot;</a> главы 11.
Там же мы рассмотрим поле флагов (flags) и поле
смещения фрагментации (fragmentation offset).</small></p>

<p>&nbsp;</p>


<p>RFC 791 [<a NAME="t032023"></a>Postel
1981a] сообщает, что поле идентификации должно быть
выбрано верхним уровнем, который отправляет IP
датаграммы, а это означает, что две
последовательно отправленные IP датаграммы, одна
из которых сгенерирована TCP, а другая - UDP, должны
иметь одно и то же поле идентификации. Подобный
подход работает (алгоритм сборки может
обработать такую ситуацию). Однако, большинство
реализаций, произошедших от Berkeley, увеличивают
соответствующую переменную в ядре IP уровня
каждый раз, когда отправляется IP датаграмма, вне
зависимости от того какой уровень отправляет
данные через IP. Переменная ядра инициируется
каждый раз в момент загрузки системы.</p>


<p>&nbsp;</p>

<p><small><a NAME="t032024"></a>Поле времени жизни (TTL - time-to-live)
содержит максимальное количество пересылок
(маршутизаторов), через которые может пройти
датаграмма. Это поле ограничивает время жизни
датаграммы. Значение устанавливается
отправителем (как правило 32 или 64) и уменьшается
на единицу каждым маршрутизатором, который
обрабатывает датаграмму. Когда значение в поле
достигает 0, датаграмма удаляется, а отправитель
уведомляется об этом с помощью ICMP сообщения.
Подобный алгоритм предотвращает зацикливание
пакетов в петлях маршрутизации. Мы вернемся к
этому полю в <a HREF="tcp08.html">главе 8</a>, когда будем
рассматривать программу Traceroute. </small></p>

<p><small>Мы говорили о <a NAME="t032025"></a>поле протокола
(protocol) в <a HREF="tcp01.htm">главе 1</a> и показали на <a HREF="tcp01.html#t017001">рисунке 1.8</a> как оно используется в
IP для <a NAME="t032026"></a>демультиплексирования
входящих датаграмм. Это поле указывает, какой
протокол отправил данные через IP. </small></p>

<p><small><a NAME="t032027"></a>Контрольная сумма заголовка
(header checksum) рассчитывается только для IP заголовка.
Она не включает в себя данные, которые следуют за
заголовком. ICMP, IGMP, UDP и TCP имеют контрольные суммы
в своих собственных заголовках, которые
охватывают их заголовки и данные. </small></p>

<p><small><a NAME="t032028"></a>Чтобы рассчитать контрольную
сумму IP для исходящей датаграммы, поле
контрольной суммы сначала устанавливается в 0.
Затем рассчитывается 16-битная сумма с
поразрядным дополнением (One's complement - поразрядное
дополнение к двоичной системе.) (заголовок
целиком воспринимается как последовательность
16-битных слов). 16-битное поразрядное дополнение
этой суммы сохраняется в поле контрольной суммы.
Когда IP датаграмма принимается, вычисляется
16-битная сумма с поразрядным дополнением. Так как
контрольная сумма, рассчитанная приемником,
содержит в себе контрольную сумму, сохраненную
отправителем, контрольная сумма приемника
состоит из битов равных 1, если в заголовке ничего
не было изменено при передаче. Если в результате
не получились все единичные биты (ошибка
контрольной суммы), IP отбрасывает принятую
датаграмму. Сообщение об ошибке не генерируется.
Теперь задача верхних уровней каким-либо образом
определить, что датаграмма отсутствует, и
обеспечить повторную передачу. </small></p>

<p><small>ICMP, IGMP, UDP и TCP используют такой же алгоритм
расчета контрольной суммы. Также TCP и UDP включают
в себя различные поля из IP заголовка, в
дополнение к своим собственным заголовкам и
данным. RFC 1071 <a NAME="t032029"></a>[Braden, Borman, and Partridge 1988]
описывает технику и реализацию расчета
контрольной суммы Internet. Так как маршрутизаторы
обычно изменяют только поле TTL (уменьшают его
значение на единицу), маршрутизатор может просто
увеличить на единицу контрольную сумму, когда он
перенаправляет полученную датаграмму, вместо
того чтобы рассчитывать контрольную сумму
заново для IP заголовка в целом. RFC 1141 <a NAME="t032030"></a>[Mallory
and Kullberg 1990] описывает как этого можно добиться.</small></p>

<p>&nbsp;</p>


<p>Стандартные реализации
BSD, однако, не используют метод обновления
контрольной суммы на единицу при
перенаправлении датаграммы.</p>


<p>&nbsp;</p>

<p><small>Каждая IP датаграмма содержит IP адрес
источника (source IP address) и IP адрес назначения (destination
IP address). Это 32-битные значения, которые мы описали
в разделе <a HREF="tcp01.html#t014000">&quot;Адресация Internet&quot;</a>
главы 1. </small></p>

<p><small>И последнее поле - поле <a NAME="t032031"></a>опций
(options), это список дополнительной информации
переменной длины. В настоящее время опции
определены следующим образом: </small>

<ul>
  <li><small><a NAME="t032032"></a>безопасность и обработка
    ограничений (для военных приложений, описано в RFC
    1108 [<a NAME="t032033"></a>Kent 1991]), </small></li>
  <li><small>запись маршрута (запись каждого маршрута и
    его IP адрес, глава 7, раздел <a HREF="tcp07.html#t073000">&quot;Опция
    записи IP маршрута&quot;</a>), </small></li>
  <li><small>временная марка (запись каждого маршрута,
    его IP адрес и время, глава 7, раздел <a HREF="tcp07.html#t074000">&quot;IP опция временной марки&quot;</a>), </small></li>
  <li><small>свободная маршрутизация от источника
    (указывает список IP адресов, через которые должна
    пройти датаграмма, глава 8, раздел <a HREF="tcp08.html#t085000">&quot;Опция
    IP маршрутизации от источника&quot;</a>), и </small></li>
  <li><small>жесткая маршрутизация от источника (то же
    самое, что и в предыдущем пункте, однако IP
    датаграмма должна пройти только через указанные
    в списке адреса, глава 8, раздел <a HREF="tcp08.html#t085000">&quot;Опция
    IP маршрутизации от источника&quot;</a>).</small></li>
</ul>

<p><small>Эти опции редко используются и не все хосты
или маршрутизаторы поддерживают все опции. </small></p>

<p><small>Поле опций всегда ограничено 32 битами.
Байты заполнения, значение которых равно 0,
добавляются по необходимости. Благодаря этому IP
заголовок всегда кратен 32 битам (как это
требуется для поля длины заголовка).</small></p>
<u><b>

<p><a NAME="t033000"></a>IP маршрутизация</p>
</b></u>

<p><small>IP маршрутизация это довольно простой
процесс, особенно с точки зрения хоста. Если
пункт назначения напрямую подключен к хосту
(например канал точка-точка) или хост включен
между несколькими сетями (Ethernet или Token ring), IP
датаграмма направляется непосредственно в пункт
назначения, иначе хост посылает датаграмму на
маршрутизатор по умолчанию, тем самым
предоставляя маршрутизатору решать как
доставить датаграмму в пункт назначения. Эту
простую схему реализуют практически все хосты. </small></p>

<p><small>В этом разделе и в <a HREF="tcp09.html">главе 9</a> мы
рассмотрим наиболее общие случаи, когда IP
уровень может быть сконфигурирован таким
образом, чтобы выполнять функции маршрутизации,
в дополнение к тому, что он работает в качестве
сетевого интерфейса. Большинство
многопользовательских систем в настоящее время,
включая практически каждую UNIX систему, могут
быть сконфигурированы таким образом, чтобы
выступать в роли маршрутизатора. Существует
возможность указать простой алгоритм
маршрутизации, который будет использоваться как
хостом, так и маршрутизатором. Основная и
фундаментальная разница между хостом и
маршрутизатором заключается в том, что хост
никогда не перенаправляет датаграммы с одного
своего интерфейса на другой, тогда как
маршрутизатор перенаправляет. Мы рассмотрим
более подробно опции конфигурирования в разделе <a HREF="tcp09.html#t094000">&quot;Перенаправлять или не
перенаправлять&quot;</a> главы 9. </small></p>

<p><small>В соответствии с общей схемой, IP может
получать датаграммы от собственных уровней TCP, UDP,
ICMP и IGMP (это датаграммы, формирующиеся здесь же),
которые необходимо отправить, однако датаграммы
могут быть приняты с какого-либо сетевого
интерфейса (эти датаграммы должны быть
перенаправлены). IP уровень имеет в памяти таблицу
маршрутизации, которую он просматривает каждый
раз при получении датаграммы, которую необходимо
перенаправить. Когда датаграмма принята с
сетевого интерфейса, IP, во-первых, проверяет, не
принадлежит ли ему указанный IP адрес назначения
или не является ли этот IP адрес
широковещательным. Если это так, то датаграмма
доставляется в модуль протокола, указанный в <a NAME="t033001"></a>поле протокола в IP заголовке. Если
датаграмма не предназначается для этого IP уровня
(1), если IP уровень был сконфигурирован для того
чтобы работать как маршрутизатор, пакет
перенаправляется (в этом случае датаграмма
обрабатывается как исходящая, что будет описано
ниже), иначе (2) датаграмма молча уничтожается. </small></p>

<p><small>Каждый пункт таблицы маршрутизации
содержит следующую информацию:</small> 

<ul>
  <li><small>IP адрес назначения. Это может быть как
    полный адрес хоста (host address) или адрес сети (network
    address), что указывается в поле флагов (описывается
    ниже). Адрес хоста имеет ненулевое значение
    идентификатора хоста (рисунок 1.5) и указывает на
    один конкретный хост, тогда как адрес сети имеет
    идентификатор хоста, установленный в 0, и
    указывает на все хосты, включенные в
    определенную сеть (Ethernet, Token ring). </small></li>
  <li><small>IP адрес <a NAME="t033002"></a>маршрутизатора
    следующей пересылки (next-hop router), или, иначе говоря,
    IP адрес непосредственно подключенной сети.
    Маршрутизатор следующей пересылки принадлежит
    одной из непосредственно подключенных сетей, в
    которую мы можем отправить датаграммы для их
    доставки. Маршрутизатор следующей пересылки это
    не конечный пункт назначения, однако он
    принимает датаграммы, которые мы посылаем, и
    перенаправляет их в направлении конечного
    пункта. </small></li>
  <li><small>Флаги. Один флаг указывает, является ли IP
    адрес пункта назначения, адресом сети или
    адресом хоста. Другой флаг указывает на то,
    является ли маршрутизатор следующей пересылки
    действительно маршрутизатором или это
    непосредственно подключенный интерфейс (мы
    опишем эти флаги в разделе <a HREF="tcp09.html#t092000">&quot;Принципы
    маршрутизации&quot;</a> главы 9). </small></li>
  <li><small>Указание на то, на какой сетевой интерфейс
    должны быть переданы датаграммы для передачи.</small></li>
</ul>

<p><small>IP маршрутизация осуществляется по принципу
пересылка-за-пересылкой. Как мы можем увидеть из
таблицы маршрутизации, IP не знает полный маршрут
к пункту назначения (за исключением тех пунктов
назначения, которые непосредственно подключены
к посылающему хосту). Все что может предоставить
IP маршрутизация - это IP адрес маршрутизатора
следующей пересылки, на который посылается
датаграмма. При этом делается предположение, что <a NAME="t033003"></a>маршрутизатор следующей пересылки
ближе к пункту назначения, чем посылающий хост.
Также делается предположение, что маршрутизатор
следующей пересылки напрямую подключен к
посылающему хосту. </small></p>

<p><small>IP маршрутизация осуществляет следующие
действия:</small> 

<ol>
  <li><small>Осуществляется поиск в таблице
    маршрутизации, при этом ищется пункт, который
    совпадет с полным адресом пункта назначения
    (должен совпасть идентификатор сети и
    идентификатор хоста). Если пункт найден в таблице
    маршрутизации, пакет посылается на указанный
    маршрутизатор следующей пересылки или на
    непосредственно подключенный интерфейс (в
    зависимости от поля флагов). Как правило, так
    определяются каналы точка-точка, при этом другой
    конец такого канала, как правило, является полным
    IP адресом удаленного хоста.</small></li>
  <li><small>Осуществляется поиск в таблице
    маршрутизации пункта, который совпадет, как
    минимум, с идентификатором сети назначения. Если
    пункт найден, пакет посылается на указанный
    маршрутизатор следующей пересылки или на
    непосредственно подключенный интерфейс (в
    зависимости от поля флагов). Маршрутизация ко
    всем хостам, находящимся в сети назначения,
    осуществляется с использованием этого
    единственного пункта таблицы маршрутизации.
    Например, все хосты локальной сети Ethernet
    представляются в таблицах маршрутизации именно
    таким образом. Эта проверка совпадения
    идентификатора сети осуществляется с
    использованием возможной маски подсети, которую
    мы опишем в следующем разделе.</small></li>
  <li><small>В таблице маршрутизации ищется пункт,
    помеченный &quot;по умолчанию&quot; (default). Если пункт
    найден, пакет отсылается на указанный
    маршрутизатор по умолчанию.</small></li>
</ol>

<p><small>Если ни один из шагов не дал положительного
результата, датаграмма считается
недоставленной. Если недоставленная датаграмма
была сгенерирована данным хостом, то обычно
возвращается ошибка &quot;хост недоступен&quot; (host
unreachable) или &quot;сеть недоступна&quot; (network unreachable).
Этот код ошибки возвращается приложению, которое
сгенерировало датаграмму. </small></p>

<p><small>В начале всегда осуществляется сравнение
на совпадение полного адреса хоста, после чего
осуществляется сравнение идентификатора сети.
Только в том случае, если результат обеих
сравнений отрицательный, используется маршрут
по умолчанию. Маршруты по умолчанию и сообщения <a NAME="t033004"></a>ICMP о перенаправлении, отправляемые на
маршрутизатор следующей пересылки (если для
датаграммы выбрано неверное направление по
умолчанию), являются довольно мощными
характеристиками IP маршрутизации, к которым мы
еще вернемся в <a HREF="tcp09.html">главе 9</a>. </small></p>

<p><small>Еще одна фундаментальная характеристика IP
маршрутизации заключается в возможности указать
маршрут к сети, вместо того, чтобы указывать
маршрут к каждому отдельно взятому хосту. Именно
поэтому хосты включенные в Internet, например, имеют
в своих таблицах маршрутизации тысячи пунктов,
вместо того чтобы содержать в них не более чем
миллион пунктов. </small></p>
<i><b>

<p>Примеры</p>
</b></i>

<p><small>Для начала представим себе простой пример:
хост bsdi имеет IP датаграмму, которую необходимо
послать на хост sun. Оба хоста находятся в одной и
той же сети Ethernet (рисунок находится на внутренней
стороне обложки). На рисунке 3.3 показан процесс
доставки датаграммы. </small></p>

<p><small>Когда IP принимает датаграмму от одного из
верхних уровней, он просматривает свою таблицу
маршрутизации и определяет, что IP адрес
назначения (140.252.13.33) непосредственно подключен к
сети (Ethernet 140.252.13.0). В таблице маршрутизации
найден совпадающий адрес сети (в следующем
разделе мы увидим, что благодаря разбиению на
подсети сетевой адрес этого Ethernet в
действительности 140.252.13.32, однако это не влияет на
маршрутизацию). </small></p>

<p><small>Датаграмма передается в драйвер устройства
Ethernet и посылается на sun в виде Ethernet фрейма
(рисунок 2.1). Адрес назначения в IP датаграмме это IP
адрес Sun (140.252.13.33), а адрес назначения в заголовке
канального уровня это 48-битовый Ethernet адрес
интерфейса Ethernet машины sun. 48-битный Ethernet адрес
получается с использованием ARP, как это делается -
мы увидим в <a HREF="tcp04.html">следующей</a> главе.<a NAME="t033005"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t3_30000.jpg" WIDTH="461" HEIGHT="199"></small></p>


<p ALIGN="CENTER"><small>Рисунок 3.3 Доставка IP датаграммы от
bsdi к sun.</small></p>

<p>&nbsp;</p>

<p><small>Рассмотрим еще один пример: bsdi имеет IP
датаграмму, которую необходимо послать на хост
ftp.uu.net, IP адрес которого 192.48.96.9. На рисунке 3.4
показан путь датаграммы через первые три
маршрутизатора. bsdi просматривает свою таблицу
маршрутизации, однако не находит совпадающий
хост или совпадающую сеть. Он использует пункт
таблицы маршрутизации по умолчанию, в
соответствии с которым необходимо послать
датаграмму на sun, который является <a NAME="t033006"></a>маршрутизатором
следующей пересылки. Когда датаграмма
передается от bsdi к sun, IP адрес для нее это конечный
адрес назначения (192.48.96.9), однако адрес
канального уровня - это 48-битный Ethernet адрес
интерфейса Ethernet машины sun. Сравните эту
датаграмму с одной из показанных на рисунке 3.3,
где IP адрес назначения и адрес назначения
канального уровня указывают на один и тот же хост
(sun). </small></p>

<p><small>Когда sun получает датаграмму, он понимает,
что IP адрес назначения этой датаграммы не его
собственный, и если sun сконфигурирован для того
чтобы выполнять функции маршрутизатора, он
перенаправляет датаграмму. Происходит просмотр
его таблицы маршрутизации, в результате чего
выбирается пункт по умолчанию. Из этого пункта
следует, что sun должен перенаправить датаграмму
на маршрутизатор следующей пересылки - netb, IP
адрес которого 140.252.1.183. Датаграмма пересылается
по SLIP каналу точка-точка с использованием
минимальной инкапсуляции, показанной на рисунке
2.2. Мы не показываем заголовок канального уровня,
как в случае с Ethernet, потому что его нет в случае SLIP
канала. </small></p>

<p><small>Когда netb получает датаграмму, он
осуществляет те же самые шаги, которые только что
осуществил sun: датаграмма не предназначается
какому-либо из его IP адресов, а так как netb
сконфигурирован так, чтобы выполнять функции
маршрутизатора, он перенаправляет датаграмму. В
данном случае также используется пункт таблицы
маршрутизации по умолчанию, при этом датаграмма
посылается на маршрутизатор следующей пересылки
gateway (140.252.1.4). С использованием ARP в сети Ethernet 140.252.1,
netb получает 48-битный Ethernet адрес соответствующий
адресу 140.252.1.4. Именно этот Ethernet адрес становится
адресом назначения в заголовке канального
уровня. </small></p>

<p><small>gateway осуществляет те же шаги, как и два
предыдущих маршрутизатора, в его таблице
маршрутизации пункт по умолчанию указывает на
адрес 140.252.104.2 как на адрес <a NAME="t033007"></a>маршрутизатора
следующей пересылки (мы убедимся, что этот
маршрутизатор является маршрутизатором
следующей пересылки для gateway с использованием
Traceroute на рисунке 8.4). </small></p>

<p><small>Из приведенного примера можно сделать
несколько важных выводов.</small> 

<ol>
  <li><small>Все хосты и маршрутизаторы в данном примере
    используют маршрут по умолчанию.</small></li>
  <li><small>IP адрес назначения датаграммы никогда не
    меняется. (В разделе <a HREF="tcp08.html#t085000">&quot;Опция IP
    маршрутизации от источника&quot;</a> главы 8 мы
    увидим, что это не всегда верно, если
    используется маршрутизация от источника, что
    бывает довольно редко.) Все решения о
    маршрутизации основываются на этом адресе
    назначения.</small></li>
  <li><small>Для каждого канала могут быть использованы
    различные заголовки канального уровня, а адрес
    назначения канального уровня (если присутствует)
    всегда содержит адрес маршрутизатора следующей
    пересылки. В нашем примере датаграммы,
    инкапсулированные во фреймы канального уровня,
    содержали Ethernet адрес следующей пересылки, однако
    SLIP не содержал. Адреса Ethernet обычно получаются с
    использованием ARP.<a NAME="t033008"></a></small></li>
</ol>


<p ALIGN="CENTER"><small><img SRC="t3_40000.jpg" WIDTH="532" HEIGHT="497"></small></p>


<p ALIGN="CENTER"><small>Рисунок 3.4 Путь датаграммы от bsdi к
ftp.uu.net (192.48.96.9).</small></p>

<p>&nbsp;</p>

<p><small>В <a HREF="tcp09.html">главе 9</a> мы снова вернемся к IP
маршрутизации, после того как расскажем об ICMP.
Также мы рассмотрим некоторые примеры таблиц
маршрутизации и примеры того, как они
используются при принятии решений о
маршрутизации.</small></p>
<u><b>

<p><a NAME="t034000"></a>Адресация подсетей</p>
</b></u>

<p><small>В настоящее время существует требование,
чтобы все хосты поддерживали адресацию подсетей
(RFC 950 <a NAME="t034004"></a>[Mogul and Postel 1985]). Теперь IP адрес не
делится просто на идентификатор сети и
идентификатор хоста: идентификатор хоста
делится на идентификатор подсети и
идентификатор хоста. </small></p>

<p><small>В сетях класса A и в сетях класса B адреса
отводится слишком много бит на идентификатор
хоста: 2<sup>24</sup> - 2 и 2<sup>16</sup> - 2 соответственно. Как
правило, такое количество хостов не подключается
к одной сети. (На рисунке 1.5 показан формат IP
адресов сетей различных классов сетей.) В данном
случае вычитается 2, потому что идентификатор
хоста из всех нулевых битов или всех единичных
битов не используется. </small></p>

<p><small>После получения от <a NAME="t034002"></a>InterNIC
идентификатора сети определенного класса,
системный администратор решает, делить ли сеть
на подсети или нет, а если делить, то сколько бит
будет отведено на идентификатор подсети и
сколько на идентификатор хоста. Например, сети,
описываемые в этом тексте, имеют адреса класса В
(140.252), а из оставшихся 16 бит 8 отводятся под
идентификатор подсети, а 8 на идентификатор
хоста. Это показано на рисунке 3.5.<a NAME="t034003"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t3_50000.jpg" WIDTH="456" HEIGHT="44"></small></p>


<p ALIGN="CENTER"><small>Рисунок 3.5 Разделение на подсети
адреса класса B.</small></p>

<p>&nbsp;</p>

<p><small>Подобное разделение позволяет создать 254
подсети по 254 хоста в каждой. </small></p>

<p><small>Большинство администраторов использует 8
из 16-ти бит идентификатора хоста в сети класса В,
для выделения подсетей. Это позволяет легко
выделить идентификатор подсети из десятичного
сетевого адреса, при этом для сетей класса&nbsp;А
или класса В можно выделить различное количество
битов для организации подсетей. </small></p>

<p><small>В большинстве примеров разделение на
подсети осуществляется с адресами класса В.
Поделить на подсети можно и адреса класса С,
однако в этом случае на идентификатор подсети
выделяется очень мало битов. Разделение на
подсети очень редко применяется по отношению
адресов класса А, потому что адресов класса А
очень мало (однако, большинство адресов класса А
поделено на подсети). </small></p>

<p><small>Разделение на подсети скрывает детали
внутренней организации сети от внешних
маршрутизаторов. В нашем примере, все IP адреса
имеют идентификатор сети класса В - 140.252, однако в
ней существует более чем 30 подсетей и более чем 400
хостов, распределенных по этим подсетям. Один
маршрутизатор обеспечивает подключение к Internet,
как показано на рисунке 3.6. </small></p>

<p><small>На этом рисунке мы пометили большинство
маршрутизаторов как Rn, где n это номер подсети. Мы
показали маршрутизаторы, которые соединяют эти
подсети вместе с девятью системами, которые
показаны на рисунке, находящимся на внутренней
стороне обложки. Сети Ethernet показаны жирными
линиями, а каналы точка-точка показаны пунктиром.
Мы показали не все хосты, находящиеся в различных
подсетях. Например, более 50 хостов находятся в
подсети 140.252.3 и более 100 в подсети 140.252.1. </small></p>

<p><small>Преимущество использования подсети
заключается в том, что используется один адрес
класса В с 30 подсетями, а не 30 адресов класса С.
При этом разделение на подсети уменьшает размер
таблиц маршрутизации Internet. Факт того что адрес
сети класса В 140.252 поделен на подсети говорит о
том, что они прозрачны для всех маршрутизаторов
Internet, кроме тех, которые находятся в подсети 140.252.<a NAME="t034001"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t3_60000.jpg" WIDTH="524" HEIGHT="455"></small></p>


<p ALIGN="CENTER"><small>Рисунок 3.6 Настройки большинства
подсетей <a NAME="t034005"></a>noao.edu 140.252.</small></p>

<p>&nbsp;</p>

<p><small>Для того чтобы получить доступ к хосту, IP
адрес которого начинается с 140.252, внешний
маршрутизатор должен всего лишь знать путь к IP
адресу 140.252.104.1. Это означает, что для доступа ко
всем сетям 140.252 необходим только один пункт в
таблице маршрутизации, вместо 30-ти пунктов в
случае использования 30 адресов класса С. Таким
образом, деление на подсети уменьшает размер
таблиц маршрутизации (в разделе <a HREF="tcp10.html#t108000">&quot;CIDR:
бесклассовая маршрутизация между доменами&quot;</a>
главы 10 мы рассмотрим новую технологию, которая
помогает уменьшить размер таблиц маршрутизации
даже если используются адреса класса С). </small></p>

<p><small>Для того чтобы показать что подсети
непрозрачны для маршрутизаторов внутри подсети,
обратимся к рисунку 3.6 и представим, что
датаграмма прибывает в gateway из Internet с адресом
назначения 140.252.57.1. Маршрутизатор gateway должен
знать где находится подсеть 57 и что датаграммы
для этой подсети надо посылать в kpno. В свою
очередь, kpno должен посылать датаграммы в R55,
который пошлет их в R57.</small></p>
<u><b>

<p><a NAME="t035000"></a>Маска подсети</p>
</b></u>

<p><small>В процессе конфигурации, которая
происходит в момент загрузки хоста,
осуществляется установка IP адреса хоста.
Большинство систем хранят его в дисковом файле,
который читается во время загрузки. В <a HREF="tcp05.html">главе
5</a> мы рассмотрим, как бездисковые системы
определяют свой IP адрес при загрузке. </small></p>

<p><small><a NAME="t035001"></a>В дополнение к IP адресу, хосту
также необходимо знать, сколько бит будет
использовано в качестве идентификатора подсети
и сколько бит будет использовано в качестве
идентификатора хоста. Это также определяется во
время загрузки с использованием <a NAME="t035002"></a>маски
подсети. Маска это 32-битное значение, которое
содержит биты, установленные в единицу для
идентификатора сети и идентификатора подсети, и
биты, установленные в 0 для идентификатора хоста.
На рисунке 3.7 показано формирование маски
подсети для двух различных разделений адреса
класса В. В верхнем примере происходит
разделение на хосте <a NAME="t035003"></a>noao.edu, как
показано на рисунке 3.5, где идентификатор подсети
и идентификатор хоста занимают 8 бит. В нижнем
примере показано разделение адреса класса В, при
этом идентификатор подсети занимает 10 бит, а
идентификатор хоста - 6 бит.<a NAME="t035004"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t3_70000.jpg" WIDTH="529" HEIGHT="133"></small></p>


<p ALIGN="CENTER"><small>Рисунок 3.7 Пример масок подсетей
для двух различных подсетей класса B.</small></p>

<p>&nbsp;</p>

<p><small>Несмотря на то, что IP адреса обычно пишутся
в десятичном виде с точками, маски подсети, как
правило, пишутся в шестнадцатиричном виде,
особенно если разделение происходит не побайтно,
а побитно. </small></p>

<p><small>После того как хост получил свой IP адрес и
маску подсети, он может определить,
предназначена ли IP датаграмма для (1) хоста в его
собственной подсети, (2) хосту в другой подсети
его собственной сети, или (3) хосту в другой сети.
Зная собственный IP адрес, можно определить, к
какому классу он относится: А, В или С (по старшим
битам), также можно определить, где проведена
граница между идентификатором сети и
идентификатором подсети. По маске подсети можно
определить где проведена граница между
идентификатором подсети и идентификатором
хоста.</small></p>
<i><b>

<p>Пример</p>
</b></i>

<p><small>Представьте себе адрес хоста 140.252.1.1 (адрес
класса В), и маску подсети - 255.255.255.0 (8 бит на
идентификатор подсети и 8 бит на идентификатор
хоста).</small> 

<ul>
  <li><small>Если IP адрес назначения 140.252.4.5, мы знаем, что
    идентификатор сети класса В тот же самый (140.252),
    однако идентификатор подсети другой (1 и 4). На
    рисунке 3.8 показано, как происходит сравнение
    двух IP адресов с использованием маски подсети. </small></li>
  <li><small>Если IP адрес назначения 140.252.1.22, то
    идентификатор сети класса В тот же самый (140.252), и
    идентификатор подсети также тот же самый (1).
    Однако идентификатор хоста другой. </small></li>
  <li><small>Если IP адрес назначения 192.43.235.6 (адрес класса
    С), идентификатор сети другой. С этим адресом не
    может быть произведено дальнейшее сравнение.<a NAME="t035005"></a></small></li>
</ul>


<p ALIGN="CENTER"><small><img SRC="t3_80000.jpg" WIDTH="533" HEIGHT="149"></small></p>


<p ALIGN="CENTER"><small>Рисунок 3.8 Сравнение двух подсетей
класса В, использующих маски подсети.</small></p>

<p>&nbsp;</p>

<p><small><a NAME="t035006"></a>В процессе IP маршрутизации,
сравнения, подобные этому, делаются все время с
использованием двух IP адресов и маски подсети.</small></p>
<u><b>

<p><a NAME="t036000"></a>Специальные IP адреса</p>
</b></u>

<p><small>В процессе описания подсетей может
встретится семь специальных IP адресов (см.
рисунок 3.9). На этом рисунке 0 означает поле,
состоящее из всех бит, установленных в ноль, -1
означает поле из бит, установленных в единицы, а
netid (идентификатор сети), subnetid (идентификатор
подсети) и hostid (идентификатор хоста) обозначает
соответствующие поля, которые установлены не в
единицы и не в нули. Пустая колонка
идентификатора подсети означает, что адреса не
могут быть разбиты на подсети.<a NAME="t036001"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="815">
  <tr>
    <td WIDTH="28%" VALIGN="TOP" COLSPAN="3" BGCOLOR="#ffffff"><p ALIGN="CENTER"><a name="t3.9"></a><small>IP адрес</small></td>
    <td WIDTH="33%" VALIGN="TOP" COLSPAN="2" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Может появляться как</small></td>
    <td WIDTH="40%" VALIGN="MIDDLE" ROWSPAN="2"><p ALIGN="CENTER"><small>Описание</small></p>
    <p>&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="8%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>ID
    сети</small></td>
    <td WIDTH="11%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>ID
    подсети</small></td>
    <td WIDTH="9%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>ID
    хоста</small></td>
    <td WIDTH="15%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>источник?</small></td>
    <td WIDTH="18%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>назначение?</small></td>
  </tr>
  <tr>
    <td WIDTH="8%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="11%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>OK</small></td>
    <td WIDTH="18%" VALIGN="TOP"><p ALIGN="CENTER"><small>никогда</small></td>
    <td WIDTH="40%" VALIGN="TOP"><small>этот хост в этой
    сети (см. ограничения ниже)</small></td>
  </tr>
  <tr>
    <td WIDTH="8%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="11%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>hostid</small></td>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>OK</small></td>
    <td WIDTH="18%" VALIGN="TOP"><p ALIGN="CENTER"><small>никогда</small></td>
    <td WIDTH="40%" VALIGN="TOP"><small>указывает хост в
    этой сети (см. ограничения ниже)</small></td>
  </tr>
  <tr>
    <td WIDTH="8%" VALIGN="TOP"><p ALIGN="CENTER"><small>127</small></td>
    <td WIDTH="11%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>любой</small></td>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>OK</small></td>
    <td WIDTH="18%" VALIGN="TOP"><p ALIGN="CENTER"><small>OK</small></td>
    <td WIDTH="40%" VALIGN="TOP"><small>адрес loopback (см.
    раздел <a HREF="tcp02.html#t027000">&quot;Интерфейс Loopback&quot;</a>
    главы 2) </small></td>
  </tr>
  <tr>
    <td WIDTH="8%" VALIGN="TOP"><p ALIGN="CENTER"><small>-1</small></td>
    <td WIDTH="11%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>-1</small></td>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>никогда</small></td>
    <td WIDTH="18%" VALIGN="TOP"><p ALIGN="CENTER"><small>OK</small></td>
    <td WIDTH="40%" VALIGN="TOP"><small><a NAME="t036002"></a>ограниченный
    широковещательный запрос (никогда не
    перенаправляется) </small></td>
  </tr>
  <tr>
    <td WIDTH="8%" VALIGN="TOP"><p ALIGN="CENTER"><small>netid</small></td>
    <td WIDTH="11%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>-1</small></td>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>никогда</small></td>
    <td WIDTH="18%" VALIGN="TOP"><p ALIGN="CENTER"><small>OK</small></td>
    <td WIDTH="40%" VALIGN="TOP"><small><a NAME="t036003"></a>широковещательный
    запрос, направляемый в сеть на netid</small></td>
  </tr>
  <tr>
    <td WIDTH="8%" VALIGN="TOP"><p ALIGN="CENTER"><small>netid</small></td>
    <td WIDTH="11%" VALIGN="TOP"><p ALIGN="CENTER"><small>subnetid</small></td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>-1</small></td>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>никогда</small></td>
    <td WIDTH="18%" VALIGN="TOP"><p ALIGN="CENTER"><small>OK</small></td>
    <td WIDTH="40%" VALIGN="TOP"><small><a NAME="t036004"></a>широковещательный
    запрос, направляемый в подсеть на netid, subnetid</small></td>
  </tr>
  <tr>
    <td WIDTH="8%" VALIGN="TOP"><p ALIGN="CENTER"><small>netid</small></td>
    <td WIDTH="11%" VALIGN="TOP"><p ALIGN="CENTER"><small>-1</small></td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>-1</small></td>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>никогда</small></td>
    <td WIDTH="18%" VALIGN="TOP"><p ALIGN="CENTER"><small>OK</small></td>
    <td WIDTH="40%" VALIGN="TOP"><small><a NAME="t036005"></a>широковещательный
    запрос, направляемый во все подсети на netid</small></td>
  </tr>
</table>


<p><small>Рисунок 3.9 Специальные IP адреса.</small></p>

<p>&nbsp;</p>

<p><small>Мы разделили эту таблицу на три секции.
Первые две записи содержат специальные адреса
источников, затем адрес интерфейса <a NAME="t036006"></a>loopback,
и последние четыре записи - это
широковещательные адреса. </small></p>

<p><small>Первые два пункта в таблице с
идентификатором сети, равным 0, могут
существовать только как адрес источника во время
процедуры инициализации, когда хост определяет
свой собственный IP адрес, например, с
использованием протокола BOOTP (<a HREF="tcp16.html">глава 16</a>).
</small></p>

<p><small>В разделе <a HREF="tcp12.html#t122000">&quot;Широковещательные
запросы&quot;</a> главы 12 мы рассмотрим четыре типа
широковещательных адресов более подробно.</small></p>
<u><b>

<p><a NAME="t037000"></a>Пример подсети</p>
</b></u>

<p><small>В примере показаны подсети, использованные
в тексте, а также, как используются две различные
маски подсети.<a NAME="t037001"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t3_10001.jpg" WIDTH="533" HEIGHT="227"></small></p>


<p ALIGN="CENTER"><small>Рисунок 3.10 Настройки хостов и сетей
в описываемой подсети.</small></p>

<p>&nbsp;</p>

<p><small>Если Вы сравните этот рисунок с одним из
тех, что показаны на внутренней стороне обложки,
то заметите, что мы опустили некоторые детали,
которые описывают подсоединение маршрутизатора
sun к верхнему Ethernet. (посредством SLIP соединения).
Это не влияют на наше описание деления на подсети
в данном разделе. Мы вернемся к подобному SLIP
соединению в разделе <a HREF="tcp04.html#t046000">&quot;Уполномоченный
агент ARP&quot;</a> главы 4, когда будем описывать
уполномоченного агента ARP. </small></p>

<p><small>Проблема заключается в том, что мы имеем две
раздельные сети внутри подсети 13: Ethernet и канал
точка-точка (выделенный канал SLIP). (Каналы
точка-точка всегда привносят некоторые проблемы,
так как каждый конец требует собственный IP
адрес.) В будущем здесь может появиться больше
хостов и сетей, однако недостаточно для того,
чтобы выделять другой номер подсети. Мы
принимаем решение расширить идентификатор
подсети с 8 до 11 бит, и уменьшить идентификатор
хоста с 8 до 5 бит. Это называется <a NAME="t037002"></a>подсетями
с переменной длиной, так как большинство сетей
внутри сети 140.252 используют маску подсети длиной
8 бит, тогда как наша сеть использует маску
подсети длиной 11 бит. </small></p>

<p>&nbsp;</p>


<p>RFC 1009 <a NAME="t037003"></a>[Braden and
Postel 1987] позволяет использовать в сетях с
подсетями несколько масок подсетей. Новые
требования к маршрутизаторам <a NAME="t037004"></a>Router
Requirements RFC [<a NAME="t037005"></a>Almquist 1993] определяют все
требования. Проблема, однако, заключается в том,
что не все протоколы маршрутизации обмениваются
масками подсети вместе с идентификатором сети
назначения. Мы увидим в <a HREF="tcp10.html">главе 10</a>, что
RIP не поддерживает подсети переменной длины,
однако RIP версии 2 и OSPF поддерживают. У нас не было
подобных проблем, так как RIP не используется в
подсетях, описываемых в тексте.</p>


<p>&nbsp;</p>

<p><small>На рисунке 3.11 показана структура IP адреса,
используемая в подсети, описываемой в книге.
Первые 8 бит в 11-битном идентификаторе подсети
всегда равны 13 в данной подсети. Для оставшихся
трех бит идентификатора подсети мы используем
двоичное 001 для Ethernet и 010 для SLIP канала
точка-точка.<a NAME="t037006"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t3_11000.jpg" WIDTH="526" HEIGHT="79"></small></p>


<p ALIGN="CENTER"><small>Рисунок 3.11 Использование подсетей
переменной длины.</small></p>

<p>&nbsp;</p>

<p><small><a NAME="t037007"></a>Маска подсети с переменной
длиной не создаст проблем для других хостов и
маршрутизаторов в сети 140.252, так как все
датаграммы, направляемые в подсеть 140.252.13,
приходят на маршрутизатор sun (IP адрес 140.252.1.29.
Рисунок 3.10) и если sun знает об 11-битном
идентификаторе подсети для хостов в подсети 13,
все будет нормально. </small></p>

<p><small>Маска подсети для всех интерфейсов в
подсети 140.252.13 установлена в 255.255.255.224 или 0xffffffe0.
Это означает, что крайние правые 5 битов
отводятся на идентификатор хоста, а 27 бит слева
оставлены на идентификатор сети и идентификатор
подсети. </small></p>

<p><small>На рисунке 3.12 показано распределение IP
адресов и масок подсетей для интерфейсов,
приведенных на рисунке 3.10.<a NAME="t037008"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="815">
  <tr>
    <td WIDTH="7%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Хост</small></td>
    <td WIDTH="18%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>IP
    адрес</small></td>
    <td WIDTH="21%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Маска
    подсети</small></td>
    <td WIDTH="17%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>ID
    сети/ ID подсети</small></td>
    <td WIDTH="12%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>ID
    хоста</small></td>
    <td WIDTH="25%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Комментарии</small></td>
  </tr>
  <tr>
    <td WIDTH="7%" VALIGN="TOP"><small>sun</small></td>
    <td WIDTH="18%" VALIGN="TOP"><small>140.252.1.29</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>255.255.255.0</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>140.252.1.</small></td>
    <td WIDTH="12%" VALIGN="TOP"><p ALIGN="CENTER"><small>29</small></td>
    <td WIDTH="25%" VALIGN="TOP"><small>в подсети 1</small></td>
  </tr>
  <tr>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="18%" VALIGN="TOP"><small>140.252.13.33</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>255.255.255.244</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>140.252.13.32</small></td>
    <td WIDTH="12%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="25%" VALIGN="TOP"><small>Ethernet, который
    рассматривается в качестве примера</small></td>
  </tr>
  <tr>
    <td WIDTH="7%" VALIGN="TOP"><small>svr4</small></td>
    <td WIDTH="18%" VALIGN="TOP"><small>140.252.13.34</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>255.255.255.244</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>140.252.13.32</small></td>
    <td WIDTH="12%" VALIGN="TOP"><p ALIGN="CENTER"><small>2</small></td>
    <td WIDTH="25%" VALIGN="TOP">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="7%" VALIGN="TOP"><small>bsdi</small></td>
    <td WIDTH="18%" VALIGN="TOP"><small>140.252.13.35</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>255.255.255.244</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>140.252.13.32</small></td>
    <td WIDTH="12%" VALIGN="TOP"><p ALIGN="CENTER"><small>3</small></td>
    <td WIDTH="25%" VALIGN="TOP"><small>Ethernet</small></td>
  </tr>
  <tr>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="18%" VALIGN="TOP"><small>140.252.13.66</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>255.255.255.244</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>140.252.13.64</small></td>
    <td WIDTH="12%" VALIGN="TOP"><p ALIGN="CENTER"><small>2</small></td>
    <td WIDTH="25%" VALIGN="TOP"><small>точка-точка</small></td>
  </tr>
  <tr>
    <td WIDTH="7%" VALIGN="TOP"><small>slip</small></td>
    <td WIDTH="18%" VALIGN="TOP"><small>140.252.13.65</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>255.255.255.244</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>140.252.13.64</small></td>
    <td WIDTH="12%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="25%" VALIGN="TOP"><small>точка-точка</small></td>
  </tr>
  <tr>
    <td WIDTH="7%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="18%" VALIGN="TOP"><small>140.252.13.63</small></td>
    <td WIDTH="21%" VALIGN="TOP"><small>255.255.255.224</small></td>
    <td WIDTH="17%" VALIGN="TOP"><small>140.252.13.32</small></td>
    <td WIDTH="12%" VALIGN="TOP"><p ALIGN="CENTER"><small>31</small></td>
    <td WIDTH="25%" VALIGN="TOP"><small>широковещательный
    адрес в Ethernet</small></td>
  </tr>
</table>


<p><small>Рисунок 3.12 IP адреса описываемой подсети.</small></p>

<p>&nbsp;</p>

<p><small>Первая колонка помечена как &quot;хост&quot;
(&quot;Host&quot;), однако и sun и bsdi также функционируют
как маршрутизаторы, так как они имеют несколько
интерфейсов и перенаправляют пакеты с одного
интерфейса на другой. </small></p>

<p><small><a NAME="t037009"></a>В последней строке таблицы
показано, что широковещательный адрес сети Ethernet
на рисунке 3.10 установлен 140.252.13.63: он формируется
из идентификатора подсети Ethernet (140.252.13.32) и
младших 5 бит на рисунке 3.11, установленных в
единицу (16+8+4+2+1=31). (В <a HREF="tcp12.html">главе 12</a> мы
увидим, что этот адрес называется
широковещательным адресом подсети.)</small></p>
<u><b>

<p><a NAME="t038000"></a>Команда ifconfig</p>
</b></u>

<p><small>Сейчас, когда мы описали канальный уровень
и IP уровень, мы можем показать команду, которая
используется для конфигурирования сетевого
интерфейса который используется TCP/IP. Команда
ifconfig(8) обычно запускается в момент загрузки
хоста при конфигурации каждого интерфейса. </small></p>

<p><small>Для интерфейсов с дозвоном (dialup), которые
могут включаться и выключаться (такие как SLIP
каналы), ifconfig должна быть запущена каждый раз
когда канал включается или выключается. </small></p>

<p><small><a NAME="t038001"></a>В следующем примере показаны
значения для подсети, описываемой в книге.
Сравните эти значения с теми, что приведены на
рисунке 3.12.</small></p>

<p>&nbsp;</p>


<p>sun % <b>/usr/etc/ifconfig -a </b>опция -a в SunOS означает &quot;все
интерфейсы&quot; le0: flags=63&lt;UP,BROADCAST, NOTRAILERS, RUNNING&gt; inet
140.252.13.33 netmask ffffffe0 broadcast 140.252.13.63 sl0: flags=1051&lt;UP, POINTOPOINT,
RUNNING, LINK0&gt; inet 140.252.1.29 --&gt; 140.252.1.183 netmask ffffff00 lo0:
flags=49&lt;UP, LOOPBACK, RUNNING&gt; inet 127.0.0.1 netmask ff000000</p>


<p>&nbsp;</p>

<p><small><a NAME="t038002"></a>Интерфейс loopback (глава 2, раздел <a HREF="tcp02.html#t027000">&quot;Интерфейс Loopback&quot;</a>)
воспринимается как сетевой интерфейс. Он
использует адрес класса A и не позволяет
разбивать себя на подсети. </small></p>

<p><small>Обратите внимание на то, что в Ethernet не
используется инкапсуляция завершителей (глава 2,
раздел <a HREF="tcp02.html#t023000">&quot;Инкапсуляция
завершителей&quot;</a>) и что Ethernet поддерживает
широковещательные запросы, тогда как SLIP канал
это канал точка-точка. </small></p>

<p><small>Флаг <a NAME="t038003"></a>LINK0 для SLIP интерфейса это
опция конфигурирования, которая позволяет
осуществлять сжатие slip (<a NAME="t038004"></a>CSLIP, глава 2,
раздел <a HREF="tcp02.html#t025000">&quot;SLIP с компрессией
(CSLIP)&quot;</a>). Еще одна возможная опция это <a NAME="t038005"></a>LINK1,
которая включает CSLIP, если принят сжатый пакет с
удаленного конца, и <a NAME="t038006"></a>LINK2, которая
позволяет отбрасывать все исходящие пакеты ICMP.
Мы рассмотрим адрес назначения этого SLIP канала в
разделе <a HREF="tcp04.html#t046000">&quot;Уполномоченный агент
ARP&quot;</a> главы 4.</small></p>

<p>&nbsp;</p>


<p>Комментарии,
приведенные в инструкции по инсталляции,
объясняют причину, по которой была введена
последняя опция: &quot;Она не должна быть
установлена, однако некоторые <a NAME="t038007"></a>кретины,
посылающие pingи на Вас, могут свести
производительность канала к нулю&quot;.</p>


<p>&nbsp;</p>

<p><small>Еще один маршрутизатор - bsdi. Так как опция -a
это характеристика <a NAME="t038008"></a>SunOS, (BSD релизы не
имеют подобной опции) мы должны исполнить <a NAME="t038009"></a>ifconfig несколько раз, указывая имя
интерфейса в качестве аргумента:</small></p>

<p>&nbsp;</p>


<p>bsdi % <b>/sbin/ifconfig we0</b> we0: flags=863&lt;UP, BROADCAST, NOTRAILERS, RUNNING,
SIMPLEX&gt; inet 140.252.13.35 netmask ffffff00 broadcast 140.252.13.63 bsdi % <b>/sbin/ifconfig
sl0</b> sl0: flags=1011&lt;UP, POINTOPOINT, LINK0&gt; inet 140.252.13.66 --&gt;
140.252.13.65 netmask ffffff00</p>


<p>&nbsp;</p>

<p><small>Здесь у интерфейса Ethernet мы видим новую
опцию (we0): <a NAME="t038010"></a>SIMPLEX. Эта опция из <a NAME="t038011"></a>4.4BSD,
которая указывает на то, что интерфейс не может
слушать свою собственную передачу. Она
устанавливается в <a NAME="t038012"></a>BSD/386 для всех
интерфейсов Ethernet. Если опция установлена,
интерфейс, посылающий фрейм с широковещательным
адресом, посылает копию на локальный хост и
посылает копию на loopback. (Мы покажем пример данной
характеристики в разделе <a HREF="tcp06.html#t063000">&quot;ICMP
запрос и отклик маски адреса&quot;</a> главы 6.) </small></p>

<p><small>На хосте slip конфигурация интерфейса SLIP
примерно такая же, как показано выше для bsdi, за
исключением того, что IP адреса на двух концах
переставлены местами:</small></p>

<p>&nbsp;</p>


<p>slip % <b>/sbin/ifconfig sl0</b> sl0: flags=1011&lt;UP, POINTOPOINT, LINK0&gt; inet
140.252.13.65 --&gt; 140.252.13.66 netmask ffffffe0</p>


<p>&nbsp;</p>

<p><small>Последний интерфейс - это Ethernet на хосте svr4.
Он аналогичен интерфейсу Ethernet, показанному
ранее, за исключением того, что версия команды
ifconfig в <a NAME="t038013"></a>SVR4 не печатает флаг RUNNING:</small></p>

<p>&nbsp;</p>


<p>svr4 % <b>/usr/sbin/ifconfig emd0</b> emd0: flags=23&lt;UP, BROADCAST, NOTRAILERS&gt;
inet 140.252.13.34 netmask ffffffe0 broadcast 140.252.13.63</p>


<p>&nbsp;</p>

<p><small>Команда <a NAME="t038014"></a>ifconfig обычно
поддерживает и другие семейства протоколов (не
TCP/IP), а также имеет несколько дополнительных
опций. Обратитесь к руководству по вашей системе,
для того чтобы изучить эту команду более
подробно. </small></p>
<u><b>

<p><a NAME="t039000"></a>Команда netstat</p>
</b></u>

<p><small>Команда <a NAME="t039001"></a>netstat(1) также
предоставляет информацию об интерфейсах
системы. Флаг <a NAME="t039002"></a>-i выдает информацию об
интерфейсах, а флаг <a NAME="t039003"></a>-n выдает IP адреса
вместо имен хостов. </small></p>

<p>&nbsp;</p>


<p>sun % <b>netstat -in</b> Name Mtu Net/Dest Address Ipkts Ierrs Opkts Oerrs Collis Queue
le0 1500 140.252.13.32 140.252.13.33 67719 0 92133 0 1 0 sl0 552 140.252.1.183
140.252.1.29 48035 0 54963 0 0 0 lo0 1536 127.0.0.1 127.0.0.1 15548 0 15548 0 0 0</p>


<p>&nbsp;</p>

<p><small>Эта команда печатает MTU для каждого
интерфейса, количество входящих пакетов, ошибки
ввода, количество исходящих пакетов, ошибки
вывода, коллизии (столкновения) и текущий размер
исходящей очереди. </small></p>

<p><small>Мы вернемся к команде netstat в <a HREF="tcp09.html">главе
9</a>, где будем использовать ее для рассмотрения
таблиц маршрутизации, и в <a HREF="tcp13.html">главе 13</a>,
когда будем использовать модифицированную
версию команды, чтобы рассмотреть активные
группы при групповой адресации.</small></p>
<u><b>

<p><a NAME="t03A000"></a>Будущее IP</p>
</b></u>

<p><small>У IP существуют три проблемы. Все они явились
результатом феноменального роста сети Internet за
последние несколько лет. (Обратитесь к <a HREF="tcp01.html#t01H001">упражнению 2</a> главы 1.)</small> 

<ol>
  <li><small>Почти половина всех адресов класса В уже
    распределена. Если адреса класса В будут
    распространяться с такой же скоростью как
    сейчас, то их запас будет исчерпан где-то в 1995
    году.</small></li>
  <li><small>32-битные адреса в общем случае непригодны
    для долговременного роста Internet.</small></li>
  <li><small>Текущая структура маршрутизации не
    иерархическая, а плоская, при этом на каждую сеть
    требуется запись в таблицы маршрутизации. По
    мере роста количества сетей все более
    распространяются адреса класса С, а также узлы, в
    которых сосредоточено несколько сетей (вместо
    адреса класса В), при этом заметен рост таблиц
    маршрутизации.</small></li>
</ol>

<p><small><a NAME="t03A001"></a>Бесклассовая маршрутизация
между доменами (CIDR - Classless Interdomain Routing) призвана
разрешить третью проблему, при этом к текущей
версии IP будут добавлены некоторые расширения (IP
версия 4). Мы обсудим это более подробно в разделе <a HREF="tcp10.html#t108000">&quot;CIDR: бесклассовая маршрутизация
между доменами&quot;</a> главы 10. </small></p>

<p><small>Что касается новой версии IP, которую часто
называют IPng, было сделано четыре предложения для
следующих поколений IP. В майском выпуске IEEE Network
(vol.7, no.3) за 1993 год содержится обзор первых трех
предложений вместе с CIDR. RFC 1454 [<a NAME="t03A011"></a>Dixon 1993]
также сравнивает первые три предложения.</small> 

<ol>
  <li><small><a NAME="t03A002"></a>Простой протокол Internet (SIP - Simple
    Internet Protocol) . Предлагается минимальный набор
    изменений к IP, после чего IP будет использовать
    64-битные адреса и другой формат заголовка.
    (Первые 4 бита заголовка также содержат номер
    версии, которые устанавливается в 4.)</small></li>
  <li><small><a NAME="t03A003"></a>PIP. Здесь также используются
    большие, переменной длины, иерархические адреса
    с другим форматом заголовка.</small></li>
  <li><small><a NAME="t03A004"></a>TUBA, что означает TCP и UDP с
    увеличенными адресами (TCP and UDP with bigger Addresses),
    основан на <a NAME="t03A005"></a>OSI <a NAME="t03A006"></a>CLNP (сетевой
    протокол без соединения - Connectionless Network Protocol),
    протокол OSI похожий на IP. Он предлагает еще
    большие адреса: переменной длины, до 20 байт.
    Однако, СLNP это существующий протокол, тогда как
    SIP и PIP это всего лишь предложения, более того, CLNP
    уже документирован. RFC 1347 [<a NAME="t03A007"></a>Callon 1992]
    описывает детали TUBA. Глава&nbsp;7 [<a NAME="t03A008"></a>Perlman
    1992] содержит сравнение IPv4 и CLNP. Множество
    маршрутизаторов уже поддерживают CLNP, однако
    большинство хостов не поддерживают.</small></li>
  <li><small><a NAME="t03A009"></a>TP/IX, который описан в RFC 1475 [<a NAME="t03A010"></a>Ullmann 1993]. Как и в случае с SIP, он
    использует 64-битные IP адреса, также изменяя TCP и UDP
    заголовки: 32-битный номер порта для обоих
    протоколов, 64-битный номер последовательности,
    64-битный номер подтверждения и 32-битные окна для
    TCP. </small></li>
</ol>

<p><small>Первые три предложения используют в
основном те же версии TCP и UDP в качестве
транспортных уровней. Однако только одно из этих
четырех предложений было выбрано в качестве
основы для IPv4. Вполне возможно, что в тот момент,
когда Вы читаете эти строки, решение принимается
или уже принято, поэтому мы ничего не будем
говорить об этом более. Однако, надо сказать, что
пройдет еще много времени, прежде чем IPv4 станет
действительно реальным протоколом.</small></p>
<u><b>

<p><a NAME="t03B000"></a>Краткие выводы</p>
</b></u>

<p><small>Мы начали эту главу с описания IP заголовка,
кратко описав все поля. Также было сделано
введение в маршрутизацию IP, был рассмотрен
простой роутинг: мы рассмотрели, как выбирается
непосредственно подключенная сеть или
маршрутизатор по умолчанию. </small></p>

<p><small>Хосты и маршрутизаторы имеют таблицы
маршрутизации, которые используются для
принятия решений о маршрутизации. В этой таблице
присутствует три типа маршрутов: указанный хост,
указанная сеть и необязательный маршрут по
умолчанию. Для этих маршрутов существует система
приоритетов. Наивысший приоритет имеет маршрут к
хосту, затем маршрут к сети, и, наконец, маршрут по
умолчанию используется только тогда, когда не
существует других маршрутов. </small></p>

<p><small>IP маршрутизация осуществляется по принципу
пересылка-за-пересылкой (hop-by-hop). IP адрес
назначения никогда не меняется в процессе
передачи датаграммы по пересылкам, однако
инкапсуляция и адреса назначения канального
уровня могут изменяться при каждой пересылке.
Большинство хостов и многие маршрутизаторы
используют <a NAME="t03B001"></a>маршрутизатор следующей
пересылки по умолчанию для всего внешнего
траффика. </small></p>

<p><small>Адреса сетей класса А и класса В обычно
разбиваются на подсети. Количество бит,
используемых для идентификатора подсети,
указывается с помощью маски подсети. Мы привели
подробные примеры того как это делается с
использованием подсети, которая описывается в
этой книге, и немного рассказали о подсетях с
переменной длиной. Мы использовали разбиение на
подсети, для того чтобы уменьшить размер таблиц
маршрутизации, так как ко множеству сетей можно
получить доступ через одну точку. Информация об
интерфейсах и сетях может быть получена с
использованием команд <a NAME="t03B002"></a>ifconfig и <a NAME="t03B003"></a>netstat. Они включают в себя IP адреса
интерфейсов, их маски подсетей,
широковещательные адреса и MTU. </small></p>

<p><small>Мы закончили главу, описав возможные
изменения, которые могут произойти в протоколах
Internet при появлении следующего поколения IP. </small></p>
<i><b>

<p>Упражнения</b></i> 

<ol>
  <li>Должен ли быть <a NAME="t03B004"></a>адрес
    интерфейса loopback всегда 127.0.0.1?</li>
  <li>На рисунке 3.6 определите маршрутизаторы,
    которые имеют больше двух интерфейсов.</li>
  <li>В чем отличие маски подсети для адреса класса А
    с 16 битами для идентификатора подсети и адреса
    класса В с 8 битами для адреса подсети?</li>
  <li>Прочитайте RFC 1219 [<a NAME="t03B005"></a>Tsuchiya 1991], для того
    чтобы познакомиться с рекомендуемой технологией
    назначения идентификаторов подсетей и
    идентификаторов хостов.</li>
  <li>Можно ли использовать маску подсети 255.255.0.255 для
    адресов класса А?</li>
  <li>Почему <a NAME="t03B006"></a>MTU для интерфейса <a NAME="t03B007"></a>loopback,
    показанного в разделе <a HREF="#t039000">&quot;Команда
    netstat&quot;</a>, установлен в 1536?</li>
  <li>Семейство протоколов TCP/IP построено на основе
    уровня IP, который определяет технологию передачи
    датаграмм по сети. Существуют семейства
    протоколов, которые основаны на применении
    сетевых технологий, ориентированных на
    соединения. Прочитайте [<a NAME="t03B008"></a>Clark 1988], чтобы
    найти три преимущества сетей с передачей
    датаграмм.</li>
</ol>





<p>&nbsp;</p>
<hr>
</center>
</body>
</html>


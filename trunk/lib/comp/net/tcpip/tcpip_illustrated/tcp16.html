<html>

<head>
<title>BOOTP: протокол загрузки</title>

<meta http-equiv="Content-type" content="text/html; charset=koi8-r">
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>




<p><a NAME="t160000"></a>Глава 16 BOOTP: протокол загрузки</p>
<u>

<p><b><a NAME="t161000"></a>Введение</p>
</b></u>

<p><small>В <a HREF="tcp05.html">главе 5</a> мы описали, как в
момент загрузки бездисковая система может
определить свой IP адрес с использованием RARP. При
использовании RARP возникает две проблемы: (1)
единственное, что можно узнать, это IP адрес, и (2)
так как RARP использует широковещательный запрос
на канальном уровне, запросы RARP не
перенаправляются маршрутизаторами (поэтому RARP
сервер должен находиться в каждой физической
сети). В этой главе мы опишем альтернативный
метод загрузки бездисковых систем, который
называется протоколом загрузки (<a NAME="t161001"></a>BOOTP -
Bootstrap Protocol). </small></p>

<p><small>BOOTP использует UDP и обычно используется
совместно с <a NAME="t161002"></a>TFTP (<a HREF="tcp15.html">глава 15</a>).
Официальная спецификация BOOTP приведена в RFC 951 <a NAME="t161003"></a>[Croft and Gilmore 1985], пояснения даются в RFC 1542 [<a NAME="t161004"></a>Wimer 1993].</small></p>
<u><b>

<p><a NAME="t162000"></a>Формат пакета BOOTP</p>
</b></u>

<p><small>BOOTP запросы и отклики инкапсулируются в UDP
датаграммы, как показано на рисунке 16.1.<a NAME="t162002"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t16_1_20.jpg" WIDTH="414" HEIGHT="105"></small></p>


<p ALIGN="CENTER"><small>Рисунок 16.1 Инкапсуляция запросов и
откликов BOOTP в UDP датаграмму.</small></p>

<p>&nbsp;</p>

<p><small>На рисунке 16.2 приведен формат 300-байтного
BOOTP запроса и отклика.<a NAME="t162001"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t16_2_20.jpg" WIDTH="525" HEIGHT="614"></small></p>


<p ALIGN="CENTER"><small>Рисунок 16.2 Формат BOOTP запроса и
отклика.</small></p>

<p>&nbsp;</p>

<p><small>Код операции (opcode) равен 1 для запроса и 2 для
отклика. Поле типа аппаратного адреса (hardware type)
равно 1 для Ethernet 10 Мбит/сек, это же значение
находится в поле с таким же именем в ARP запросе
или отклике (см. <a HREF="tcp04.html#t044001">рисунок 4.3</a>).
Длина аппаратного адреса (hardware address length) равна 6
байтам, как и для Ethernet. </small></p>

<p><small>Счетчик пересылок (hop count) устанавливается
клиентом в 0, однако может быть использован
уполномоченным сервером (описано в разделе <a HREF="#t165000">&quot;BOOTP через маршрутизаторы&quot;</a> этой
главы). </small></p>

<p><small><a NAME="t162003"></a>Идентификатор транзакции
(transaction ID) - 32-битное целое число, которое
устанавливается клиентом и возвращается
сервером. Оно позволяет клиенту сопоставить
отклик с запросом. Клиент устанавливает в это
поле случайное число для каждого запроса. </small></p>

<p><small>В поле количество секунд (number of seconds) клиент
записывает время, когда он предпринял первую
попытку загрузиться. На основании значения этого
поля вторичный сервер делает вывод о том, что
первичный сервер не доступен. (Вторичный сервер
делает подобный вывод если величина в поле
количества секунд достигла определенного
значения.) </small></p>

<p><small>Если клиент уже знает свой IP адрес, он
заполняет поле IP адрес клиента (client IP address). Есле
нет - клиент устанавливает это значение в 0. В
последнем случае сервер вставляет в поле ваш IP
адрес (your IP address) IP адрес клиента. Поле IP адрес
сервера (server IP address) заполняется сервером. Если
используется уполномоченный сервер (раздел <a HREF="#t165000">&quot;BOOTP через маршрутизаторы&quot;</a> этой
главы), он заполняет IP адрес шлюза (gateway IP address). </small></p>

<p><small>Клиент должен установить свой аппаратный
адрес клиента (client hardware address). Это то же значение,
которое находиться в заголовке Ethernet и в поле UDP
датаграммы, благодаря чему оно становится
доступным любому пользовательскому процессу
(например, серверу BOOTP), который получил
датаграмму. Обычно процессу, работающему с UDP
датаграммами, сложно или практически невозможно
определить значение, находящееся в поле
заголовка Ethernet датаграммы, в которой передается
UDP датаграмма. </small></p>

<p><small>Имя хоста сервера (server hostname) это строка,
которая заполняется сервером (не обязательно).
Сервер также может заполнить поле имени
загрузочного файла (boot filename). В это поле заносится
полный путь к файлу, который используется при
загрузке. </small></p>

<p><small>Область производителя (vendor-specific)
используется для различных расширений BOOTP. В
разделе <a HREF="#t166000">&quot;Информация
производителя&quot;</a> этой главы описываются
некоторые из этих расширений. </small></p>

<p><small>Когда клиент стартует с использованием BOOTP
(код операции равен 1), запрос обычно рассылается
с помощью широковещательного сообщения
канального уровня, при этом IP адрес назначения в
IP заголовке обычно установлен в 255.255.255.255 (<a NAME="t162004"></a>ограниченный широковещательный
запрос, глава 12, раздел <a HREF="tcp12.html#t122000">&quot;Широковещательные
запросы&quot;</a>). IP адрес источника - 0.0.0.0, так как
клиент еще не знает своего IP адреса. Обратитесь к <a HREF="tcp03.html#t036001">рисунку 3.9</a>, где показано, что 0.0.0.0
это разрешенный IP адрес источника, используемый
в момент загрузки источника.</small></p>
<i><b>

<p>Номера портов</p>
</b></i>

<p><small>Для BOOTP выделено два заранее известных
порта: 67 для сервера и 68 для клиента. Это означает,
что клиент не выбирает неиспользуемый
динамически назначаемый порт, а использует порт
номер 68. Причина, по которой были выбраны два
номера портов, вместо того чтобы использовать
только один для сервера, заключается в том, что
сервер может отправить отклик (хотя обычно он
этого не делает) широковещательным образом. </small></p>

<p><small>Если отклик от сервера распространялся бы
широковещательным образом, и если клиенту было
бы необходимо выбрать динамически назначаемый
номер порта, эти широковещательные пакеты также
были бы получены другими приложениями на других
хостах, которые используют тот же самый
динамически назначаемый номер порта. Таким
образом, можно сделать вывод, что отправлять
широковещательный запрос на случайный
(динамически назначаемый) номер порта не
рационально. </small></p>

<p><small>Если клиент воспользуется заранее
известным портом сервера (67), все сервера в сети
будут вынуждены просматривать каждый
широковещательный отклик. (Если все сервера были
&quot;разбужены&quot;, им придется проверить код
операции, определить, что это отклик, а не запрос,
и снова &quot;уснуть&quot;.) Поэтому выбор был
остановлен на том, как все сделано сейчас, то есть
клиент имеет свой собственный единственный
заранее известный порт, который отличается от
заранее известного порта сервера. </small></p>

<p><small>Если несколько клиентов загружаются в одно
и то же время, и если отклики от сервера
распространяются широковещательными запросами,
каждый клиент просматривает отклики, которые
предназначены другим клиентам. Клиенты
используют поле идентификатора транзакции в BOOTP
заголовке, чтобы сопоставить отклик с запросом,
или же просматривают возвращенный аппаратный
адрес клиента.</small></p>
<u><b>

<p><a NAME="t163000"></a>Пример</p>
</b></u>

<p><small>Давайте рассмотрим, как работает BOOTP при
загрузке X терминала. На рисунке&nbsp;16.3 показан
вывод команды tcpdump. (Имя клиента proteus, а имя
сервера mercury. Вывод этой команды tcpdump был получен
в другой сети, в отличие от всех других примеров,
приведенных в тексте.)<a NAME="t163001"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0.0.0.68
&gt; 255.255.255.255.bootp: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; secs:100
ether 0:0:a7:0:62:7c<br>
2&nbsp; 0.355446 (0.3554)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mercury.bootp
&gt; proteus.68: secs:100 Y:proteus <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S:mercury
G:mercury ether 0:0:a7:0:62:7c <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file
&quot;/local/var/bootfiles/Xncd19r&quot;<br>
<br>
3&nbsp; 0.355447 (0.0000)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp who-has
proteus tell 0.0.0.0<br>
4&nbsp; 0.851508 (0.4961)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp who-has
proteus tell 0.0.0.0<br>
5&nbsp; 1.371070 (0.5196)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp who-has
proteus tell proteus<br>
<br>
6&nbsp; 1.863226 (0.4922)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proteus.68 &gt;
255.255.255.255.bootp: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; secs:100
ether 0:0:a7:0:62:7c<br>
7&nbsp; 1.871038 (0.0078)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mercury.bootp
&gt; proteus.68: secs:100 Y:proteus <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S:mercury
G:mercury ether 0:0:a7:0:62:7c <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file
&quot;/local/var/bootfiles/Xncd19r&quot;<br>
<br>
8&nbsp; 3.871038 (2.0000)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proteus.68 &gt;
255.255.255.255.bootp: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; secs:100
ether 0:0:a7:0:62:7c<br>
9&nbsp; 3.878850 (0.0078)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mercury.bootp
&gt; proteus.68: secs:100 Y:proteus <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S:mercury
G:mercury ether 0:0:a7:0:62:7c <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file
&quot;/local/var/bootfiles/Xncd19r&quot;<br>
<br>
10&nbsp; 5.925786 (2.0469)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp who-has
mercury tell proteus<br>
11&nbsp; 5.929692 (0.0039)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp reply
mercury is-at 8:0:2b:28:eb:1d<br>
<br>
12&nbsp; 5.929694 (0.0000)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proteus.tftp
&gt; mercury.tftp: 37 RRQ <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;/local/var/bootfiles/Xncd19r&quot;<br>
13&nbsp; 5.996094 (0.0664)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mercury.2352
&gt; proteus.tftp: 516 DATA block 1<br>
14&nbsp; 6.000000 (0.0039)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proteus.tftp
&gt; mercury.2352: 4 ACK<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; в
этом месте удалено много строк<br>
<br>
15&nbsp; 14.980472 (8.9805)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mercury.2352 &gt;
proteus.tftp: 516 DATA block 2463<br>
16&nbsp; 14.984376 (0.0039)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proteus.tftp &gt;
mercury.2352: 4 ACK<br>
17&nbsp; 14.984377 (0.0000)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mercury.2352 &gt;
proteus.tftp: 228 DATA block 2464<br>
18&nbsp; 14.984378 (0.0000)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proteus.tftp &gt;
mercury.2352: 4 ACK<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 16.3 Пример использования BOOTP при
загрузке X терминала.</small></p>

<p>&nbsp;</p>

<p><small>В строке 1 мы видим, что запрос от клиента
0.0.0.0.68 направляется на 255.255.255.255.67. Единственные
поля, которые заполнил клиент, это количество
секунд и Ethernet адрес. Мы увидим, что клиент всегда
устанавливает количество секунд в значение&nbsp;100.
Счетчик пересылок и идентификатор транзакции
установлены в 0, поэтому они не присутствуют в
выводе tcpdump. (Идентификатор транзакции,
установленный в 0, означает, что клиент
игнорирует это поле, иначе, если бы он хотел
проверить это значение в отклике, он установил бы
это поле в случайную величину.) </small></p>

<p><small>В строке 2 показан отклик от сервера. Поля,
заполненные сервером, это IP адрес клиента
(который <a NAME="t163002"></a>tcpdump напечатал как имя proteus),
IP адрес сервера (напечатан как имя mercury), IP адрес
шлюза (напечатан как имя mercury) и имя загрузочного
файла. </small></p>

<p><small>После получения BOOTP отклика клиент
немедленно отправляет ARP запрос, чтобы
посмотреть, не использует ли кто-либо в сети
такой же IP адрес. Имя proteus, за которым следует who-has,
соответствует IP адресу адресата (<a HREF="tcp04.html#t044001">рисунок
4.3</a>), а IP адрес отправителя устанавливается в
0.0.0.0. Он отправляет еще один идентичный ARP запрос
через 0,5 секунды и еще один опять же через 0,5
секунды. В третьем ARP запросе (строка 5) клиент
изменяет IP адрес отправителя, и устанавливает
его в собственный IP адрес. Это так называемый
&quot;беспричинный&quot; ARP запрос (глава 4, раздел <a HREF="tcp04.html#t047000">&quot;Беспричинный ARP&quot;</a>). </small></p>

<p><small>В строке 6 показано, что клиент ожидает еще
0,5 секунды, после чего рассылает
широковещательным запросом еще один BOOTP запрос.
Единственное отличие между этим запросом и
запросом, показанным в строке 1, заключается в
том, что сейчас клиент помещает свой собственный
IP адрес в IP заголовок. Он получает тот же самый
отклик от того же самого сервера (строка 7). Клиент
ждет еще 2 секунды и отправляет
широковещательным образом еще один BOOTP запрос
(строка 8) и снова получает тот же самый отклик от
того же самого сервера. </small></p>

<p><small>Затем клиент ждет еще 2 секунды и отправляет
ARP запрос на сервер mercury (строка 10). После того как
получен ARP отклик, клиент незамедлительно
отправляет <a NAME="t163003"></a>TFTP запрос на чтение
своего загрузочного файла (строка 12). Затем
следуют 2464 пакета TFTP данных и подтверждений.
Полный размер переданных данных составляет 512 х
2463 + 224 = 1261280 байт. Таким образом, в X терминал
загружается операционная система. Мы удалили с
рисунка&nbsp;16.3 большинство строк, имеющих
отношение к TFTP. </small></p>

<p><small>Необходимо обратить внимание на то, что
этот пример TFTP обмена отличается от приведенного
на <a HREF="tcp15.html#t153001">рисунке 15.2</a> тем, что здесь
клиент использует заранее известный порт TFTP (69)
во время всей передачи. Так как один из трех
партнеров использует порт 69, tcpdump знает, что
пакеты это TFTP сообщения, поэтому он может
интерпретировать каждый пакет с использованием
TFTP протокола. Именно поэтому на рисунке 16.3
указано, какие из пакетов содержат данные, какие
содержат подтверждения и каков номер блока для
каждого пакета. Мы не могли получить эту
дополнительную информацию на <a HREF="tcp15.html#t153001">рисунке
15.2</a>, потому что ни одна из сторон не
использовала заранее известный порт TFTP для
передачи данных. Обычно, TFTP клиент не может
использовать заранее известный порт TFTP, так как
этот порт используется сервером в
многопользовательской системе. Однако здесь
система только загружается, TFTP сервис не
предоставляется, что позволяет клиенту
использовать порт в течении всего времени
передачи. Также из примера видно, что TFTP сервер на
mercury не заботится о том, каков номер порта клиента
- он отправляет на порт клиента данные вне
зависимости от его номера. </small></p>

<p><small>На рисунке 16.3 мы видим, что 1261280 байт
передано за 9 секунд. При этом скорость передачи
составляет примерно 140000 байт в секунду. Несмотря
на то, что это медленней, чем при передаче файлов
с использованием FTP по Ethernet, это совсем неплохо
для простого <a NAME="t163004"></a>протокола с остановкой
и ожиданием подтверждения, такого как TFTP. </small></p>

<p><small>После того как X терминал загрузился,
осуществляется дополнительная передача файлов
посредством TFTP, содержащих шрифты терминала,
осуществляются некоторые запросы к DNS серверам и
затем инициализация X протокола. Полное время
загрузки на рисунке 16.3 составило почти 15 секунд,
еще 6 секунд было истрачено на последующие шаги.
Это означает, что бездисковый X терминал
загрузился за 21 секунду.</small></p>
<u><b>

<p><a NAME="t164000"></a>Сервер BOOTP</p>
</b></u>

<p><small>BOOTP клиент обычно &quot;живет&quot; в постоянной
памяти бездисковой системы. Однако нам интересно
посмотреть, как обычно реализуется сервер. </small></p>

<p><small>Во-первых, сервер читает UDP датаграммы с
заранее известного порта (67). Специальных средств
не требуется. В этом заключается отличие от RARP
сервера (см. главу 5, раздел <a HREF="tcp05.html#t054000">&quot;Реализация
RARP сервера&quot;</a>), который, как мы говорили, читает
Ethernet фреймы, у которых в поле типа установлено
&quot;RARP запрос&quot; (RARP request). Протокол BOOTP также
позволяет серверу легко получить аппаратный
адрес клиента, поместив его в BOOTP пакет (см.
рисунок 16.2). </small></p>

<p><small>Тут возникает интересная проблема: как
сервер может послать отклик непосредственно
клиенту? Отклик находится в UDP датаграмме, и
сервер знает IP адрес клиента (который обычно
считывается из конфигурационного файла на
сервере). Однако, если клиент отправил UDP
датаграмму на этот IP адрес (это обычный способ
обработки вывода UDP), хост сервера, возможно,
выдаст ARP запрос для этого IP адреса. Однако,
клиент не может ответить на ARP запрос, так как он
еще не знает своего IP адреса! (Проблема подробно
описана в RFC 951.) </small></p>

<p><small>Существует два решения. Первое, которое
обычно используется в Unix серверах, заключается в
том, что сервер выдает <a NAME="t164001"></a>ioctl (2) запрос в
ядро, чтобы поместить определенный пункт в ARP кэш
для этого клиента. (Это как раз то, что делает
команда <a NAME="t164002"></a>arp <a NAME="t164003"></a>-s, глава 4,
раздел <a HREF="tcp04.html#t048000">&quot;Команда arp&quot;</a>.)
Сервер может так поступить, так как он знает
аппаратный адрес клиента и его IP адрес. Это
означает, что когда сервер посылает UDP датаграмму
(BOOTP отклик), ARP модуль сервера может найти IP адрес
клиента в ARP кэше. </small></p>

<p><small>Альтернативное решение этой проблемы
заключается в том, что сервер рассылает BOOTP
отклик широковещательным запросом, вместо того
чтобы посылать его непосредственно клиенту. Для
того чтобы уменьшить количество
широковещательных запросов в сети, это решение
должно быть использовано только в том случае,
когда сервер не может поместить пункт в свой ARP
кэш. Обычно, для того чтобы ввести пункт в ARP кэш,
необходимы права суперпользователя, а рассылка
широковещательных откликов сервером не требует
дополнительных привилегий.</small></p>
<u><b>

<p><a NAME="t165000"></a>BOOTP через маршрутизаторы</p>
</b></u>

<p><small>В разделе <a HREF="tcp05.html#t054000">&quot;Реализация RARP
сервера&quot;</a> главы 5 мы сказали, что одним из
неприятных свойств RARP является то, что он
использует широковещательные запросы
канального уровня, которые обычно не
перенаправляются маршрутизаторами. А это
означает, что необходимо иметь RARP сервер в каждой
физической сети. BOOTP может работать через
маршрутизатор, если маршрутизатор поддерживает
этот протокол. (Большинство производителей
маршрутизаторов добавляют поддержку этой
характеристики.) </small></p>

<p><small>Обычно это необходимо для бездисковых
маршрутизаторов, потому что если в качестве
маршрутизатора используется
многопользовательская система с диском, она
может сама запустить BOOTP сервер. Однако все BOOTP
сервера на основе Unix (<a HREF="tcp_f.html">приложение F</a>)
поддерживают этот режим, но, повторим снова, если
Вы можете запустить BOOTP сервер в одной физической
сети, нет необходимости перенаправлять запросы
от другого сервера из другой сети. </small></p>

<p><small>Что произойдет, если маршрутизатор (также
называемый &quot;BOOTP агент&quot; (BOOTP relay agent)) слушает
BOOTP запросы на заранее известном порту сервера
(67). Когда запрос принят, агент помещает свой IP
адрес в поле IP адреса шлюза (gateway IP address) в BOOTP
запросе и отправляет запрос на реальный BOOTP
сервер. (Адрес, помещенный агентом в поле шлюза,
это IP адрес интерфейса, на который был принят
запрос.) Агент также увеличивает на единицу
значение в поле пересылок. (Это делается для того,
чтобы предотвратить зацикливание, если запрос
будет повторно перенаправлен. В RFC 951 говориться,
что запрос должен быть отброшен, если счетчик
пересылок достигнет значения 3.) Так как
исходящий запрос это датаграмма с персональным
адресом (исходный запрос от клиента был
широковещательным), он может пройти по любому
маршруту к любому BOOTP серверу, проходя через
другие маршрутизаторы. Реальный сервер получает
запрос, формирует BOOTP отклик и отправляет его
назад агенту, а не клиенту. Реальный сервер знает
что запрос был перенаправлен, так как значение в
поле шлюза ненулевое. Агент получает отклик и
отправляет его клиенту.</small></p>
<u><b>

<p><a NAME="t166000"></a>Информация производителя</p>
</b></u>

<p><small>На рисунке 16.2 мы показали 64-байтную область
производителя. В RFC 1533 <a NAME="t166001"></a>[Alexander and Droms 1993]
определен формат этой области. Область
производителя содержит необязательную
информацию для сервера, которую он может вернуть
клиенту. </small></p>

<p><small>Если информация присутствует, в первые 4
байта этой области устанавливается IP адрес
99.130.83.99. Это означает, что в области присутствует
дополнительная информация. </small></p>

<p><small>Вся остальная область занята списком
пунктов. Каждый пункт начинается с 1-байтового
поля признака. Два из пунктов состоят только из
поля признака: признак равный 0 это байт
заполнения, а признак равный 255 обозначает конец
пунктов. Все байты, расположенные после первого
конечного байта, должны быть установлены в
значение 255. </small></p>

<p><small>Все остальные пункты, кроме этих 1-байтовых
пунктов, состоят из единичного байта, за которым
следует информация. На рисунке 16.4 показан формат
некоторых пунктов в области производителя.<a NAME="t166002"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t16_4_20.jpg" WIDTH="533" HEIGHT="450"></small></p>


<p ALIGN="CENTER"><small>Рисунок 16.4 Формат некоторых
пунктов в области производителя.</small></p>

<p>&nbsp;</p>

<p><small>Маска подсети и значение времени это пункты
с фиксированной длиной, потому что их значение
всегда занимает 4 байта. Смещение времени - это
количество секунд после полуночи 1 января 1900
года, UTC. </small></p>

<p><small>Пункт шлюза это один из пунктов с
переменной длиной. Длина всегда кратна 4, а
значение - это 32-битные IP адреса одного или
нескольких шлюзов (маршрутизаторов), которыми
пользуется клиент. Первый из возвращенных
адресов должен быть адресом предпочтительного
шлюза. </small></p>

<p><small>В RFC 1533 определено еще 14 пунктов. Возможно,
наиболее важный из них - это IP адрес DNS сервера со
значением признака равным 6. В других пунктах
содержатся IP адрес сервера печати, IP адрес
сервера времени и так далее. Обратитесь к RFC, где
приведены все подробности. </small></p>

<p><small>В примере, приведенном на рисунке 16.3, мы не
видим <a NAME="t166003"></a>ICMP запроса маски адреса (глава
6, раздел <a HREF="tcp06.html#t063000">&quot;ICMP запрос и отклик
маски адреса&quot;</a>), который может быть разослан
клиентом широковещательным сообщением для
определения собственной маски подсети. Его также
не было в выводе tcpdump, поэтому мы можем
предположить, что маска подсети клиента была
передана в области производителя в отклике BOOTP.</small></p>

<p>&nbsp;</p>


<p>Требования к хостам <a NAME="t166004"></a>Host Requirements RFC рекомендуют, чтобы
система, использующая BOOTP, получала свою маску
подсети с использованием BOOTP, а не ICMP. </p>


<p>&nbsp;</p>

<p><small>Размер области производителя ограничен 64
байтами. Это требование выдвигается некоторыми
приложениями. Новый протокол, протокол
динамической конфигурации хостов (<a NAME="t166005"></a>DHCP
- Dynamic Host Configuration Protocol), заменяет собой BOOTP. В DHCP эта
область увеличена до 312 байт, как определено в RFC
1541 [<a NAME="t166006"></a>Droms 1993].</small></p>
<u><b>

<p><a NAME="t167000"></a>Краткие выводы</p>
</b></u>

<p><small>BOOTP использует UDP и разработан в качестве
альтернативы RARP для загрузки бездисковых систем,
которым необходимо определить свой IP адрес. BOOTP
также может вернуть дополнительную информацию,
такую как IP адрес маршрутизатора, маску подсети
клиента и IP адрес DNS сервера. </small></p>

<p><small>Так как BOOTP используется в процессе
загрузки, бездисковые системы должны иметь
следующие протоколы в своей постоянной памяти:
BOOTP, TFTP, UDP, IP и драйвер устройства для локальной
сети. </small></p>

<p><small>Реализация BOOTP сервера значительно проще
чем RARP сервера, так как BOOTP запросы и отклики
используют UDP датаграммы, а не специальные фреймы
канального уровня. Маршрутизаторы могут также
выступать в роли уполномоченных агентов для
реальных BOOTP серверов, перенаправляя запросы
клиентов на реальные серверы в удаленные сети.</small></p>
<i><b>

<p>Упражнения</b></i> 

<ol>
  <li>Мы сказали, что одно из преимуществ
    BOOTP над RARP заключается в том, что BOOTP может
    работать через маршрутизаторы, тогда как RARP,
    который использует широковещательные запросы
    канального уровня, не может. В разделе <a HREF="#t165000">&quot;BOOTP
    через маршрутизаторы&quot;</a> этой главы, мы
    определили специальные способы, с помощью
    которых BOOTP может работать через маршрутизаторы.
    Что произойдет, если добавить маршрутизатору
    возможность перенаправлять RARP запросы?</li>
  <li>Мы сказали, что BOOTP клиент должен использовать <a NAME="t167001"></a>идентификатор транзакции, чтобы
    сопоставить отклики с запросами, в том случае,
    если несколько клиентов загружаются в одно и то
    же время с одного и того же сервера, который
    использует широковещательные отклики. Однако на
    рисунке 16.3 идентификатор транзакции установлен
    в 0, что указывает на то, что этот клиент
    игнорирует идентификатор транзакции. Как Вы
    думаете, сопоставляет ли этот клиент отклики с
    запросами?</li>
</ol>





<hr>

</body>
</html>

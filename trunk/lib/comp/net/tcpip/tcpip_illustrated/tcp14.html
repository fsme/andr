<html>

<head>
<title>DNS: Система имен доменов (Domain Name System)</title>

<meta http-equiv="Content-type" content="text/html; charset=koi8-r">
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>




<p><a NAME="t140000"></a>Глава 14 DNS: система имен доменов</p>
<u>

<p><b><a NAME="t141000"></a>Введение</p>
</b></u>

<p><small><a NAME="t141001"></a>Система имен доменов (DNS - Domain Name
System) это распределенная база данных, которая
используется приложениями TCP/IP, для установления
соответствия между именами хостов и IP адресами.
DNS также используется для маршрутизации
электронной почты. Мы используем термин
распределенная, потому что на одном узле Internet не
хранится вся необходимая информация. Каждый узел
(университет, университетский городок, компания
или отдел внутри компании) поддерживает
собственую информационную базу данных и
запускает программу сервер, которая может
отправить запрос по Internet к другим системам. DNS
предоставляет протокол, который позволяет
клиентам и серверам общаться друг с другом. </small></p>

<p><small>С точки зрения приложения, доступ к DNS
осуществляется посредством <a NAME="t141002"></a>разборщика
(resolver) (разборщик (resolver) - подпрограммы, которые
используются для создания, отправки и
интерпретации пакетов, используемых серверами
имен Internet). В Unix системах, к разборщику можно
получить доступ через две библиотечные функции, <a NAME="t141003"></a>gethostbyname(3) и <a NAME="t141004"></a>gethostbyaddr(3),
которые линкуются с приложением, когда оно
строится. Первая воспринимает в качестве
аргумента имя хоста и возвращает IP адрес, а
вторая воспринимает в качестве аргумента IP адрес
и возвращает имя хоста. Разборщик устанавливает
контакты с одним или несколькими <a NAME="t141005"></a>серверами
DNS (name servers), чтобы установить это соответствие. </small></p>

<p><small>На <a HREF="tcp04.html#t042001">рисунке 4.2</a> показано,
что разборщик - это часть приложения. Он не
является частью ядра операционной системы как
протоколы TCP/IP. Приложение должно конвертировать
имя хоста в IP адрес, перед тем как оно попросит TCP
открыть соединение или послать датаграмму с
использованием UDP. Протоколы TCP/IP внутри ядра
ничего не знают о DNS. </small></p>

<p><small>В этой главе мы рассмотрим, как разборщики
общаются с DNS серверами с использованием
протоколов TCP/IP (в основном UDP). Однако мы не будем
рассматривать установку и администрирование DNS
серверов или все опции, существующие у
разборщиков и серверов. Это может составить еще
одну книгу. (В публикации <a NAME="t141006"></a>[Albitz and Liu 1992]
приведены подробности функционирования
стандартных Unix разборщиков и серверов DNS.) </small></p>

<p><small>RFC 1034 [<a NAME="t141007"></a>Mockapetris 1987a] описывает
концепции, лежащие в основе DNS, а RFC 1035 [Mockapetris 1987b]
содержит подробности разработки и спецификации
DNS. Наиболее широкоиспользуемая реализация DNS,
как разборщика, так и сервера - <a NAME="t141008"></a>BIND
(Berkeley Internet Name Domain). Процесс сервера называется <a NAME="t141009"></a>named. Анализ траффика, генерируемого DNS в
глобальных сетях, приводится в <a NAME="t141010"></a>[Danzig,
Obraczka, and Kumar 1992].</small></p>
<u><b>

<p><a NAME="t142000"></a>Основы DNS</p>
</b></u>

<p><small>Пространство имен DNS имеет иерархическую
структуру, которая внешне напоминает файловую
систему Unix. На рисунке 14.1 показана иерархическая
организация DNS.<a NAME="t142001"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t14_1_20.jpg" WIDTH="501" HEIGHT="375"></small></p>


<p ALIGN="CENTER"><small>Рисунок 14.1 Иерархическая
организация DNS.</small></p>

<p>&nbsp;</p>

<p><small>Каждый узел (кружочки на рисунке 14.1) имеет
метку длиной до 63 символов. Корень дерева это
специальный узел без метки. Метки могут
содержать заглавные буквы или маленькие. Имя
домена (domain name) для любого узла в дереве - это
последовательность меток, которая начинается с
узла выступающего в роли корня, при этом метки
разделяются точками. (Здесь видно отличие от
файловой системы Unix, где полный путь всегда
начинается с вершины (корня) и опускается вниз по
дереву.) Каждый узел дерева должен иметь
уникальное имя домена, однако одинаковые метки
могут быть использованы в различных точках
дерева. </small></p>

<p><small>Имя домена, которое заканчивается точкой,
называется <a NAME="t142002"></a>абсолютным именем домена
(absolute domain name) или полным именем домена (<a NAME="t142003"></a>FQDN
- fully qualified domain name). Например, sun.tuc.noao.edu.. Если имя
домена не заканчивается на точку,
подразумевается, что имя должно быть завершено.
Как будет закончено имя, зависит от
используемого программного обеспечения DNS. Если
незаконченное имя состоит из двух или более
меток, его можно воспринимать как законченное
или полное; иначе справа от имени должен быть
добавлен локальный суффикс. Например, имя sun
может быть завершено локальным суффиксом
.tuc.noao.edu.. </small></p>

<p><small>Домены верхнего уровня поделены на три
зоны:</small> 

<ol>
  <li><small><a NAME="t142004"></a>arpa это специальный домен,
    используемый для сопоставления адрес - имя
    (раздел <a HREF="#t145000">&quot;Запросы указателя&quot;</a>
    этой главы).</small></li>
  <li><small>Семь 3-символьных доменов называются <a NAME="t142005"></a>общими (generic) доменами. В некоторых
    публикациях они называются <a NAME="t142006"></a>организационными
    (organizational) доменами.</small></li>
  <li><small>Все 2-символьные домены, основанные на кодах
    стран, можно найти в <a NAME="t142007"></a>ISO 3166. Они
    называются <a NAME="t142008"></a>доменами стран (country), или <a NAME="t142009"></a>географическими (geographical) доменами. </small></li>
</ol>

<p><small>На рисунке 14.2 приведен список обычной
классификации семи основных доменов.<a NAME="t142010"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="508">
  <tr>
    <td WIDTH="19%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Домен</small></td>
    <td WIDTH="81%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Описание</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><p ALIGN="CENTER"><small>com</small></td>
    <td WIDTH="81%" VALIGN="TOP"><small>коммерческие
    организации</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><p ALIGN="CENTER"><small>edu</small></td>
    <td WIDTH="81%" VALIGN="TOP"><small>учебные
    организации</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><p ALIGN="CENTER"><small>gov</small></td>
    <td WIDTH="81%" VALIGN="TOP"><small>правительственные
    организации США</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><p ALIGN="CENTER"><small>int</small></td>
    <td WIDTH="81%" VALIGN="TOP"><small>международные
    организации</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><p ALIGN="CENTER"><small>mil</small></td>
    <td WIDTH="81%" VALIGN="TOP"><small>военные
    организации США</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><p ALIGN="CENTER"><small>net</small></td>
    <td WIDTH="81%" VALIGN="TOP"><small>сети</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><p ALIGN="CENTER"><small>org</small></td>
    <td WIDTH="81%" VALIGN="TOP"><small>другие организации</small></td>
  </tr>
</table>


<p><small>Рисунок 14.2 3-символьные общие домены.</small></p>

<p>&nbsp;</p>

<p><small>Иногда считается, что 3-символьные общие
домены используются только организациями
Соединенных Штатов, а 2-символьные домены стран
всеми остальными, однако это не так. Существуют
неамериканские организации в основных доменах, и
множество организаций в Соединенных Штатах
находятся в домене страны .us. (RFC 1480 <a NAME="t142011"></a>[Cooper
and Postel 1993] описывает домен .us более подробно.)
Единственные общие домены, которые закреплены за
Соединенными Штатами, это .gov и .mil. </small></p>

<p><small>Многие 2-символьные домены стран второго
уровня, очень похожи на основные домены: .ac.uk,
например, принадлежит академическим институтам,
а .co.uk коммерческим организациям Великобритании. </small></p>

<p><small>Одна важная характеристика DNS, не
показанная на рисунке 14.1, это передача
ответственности внутри DNS. Не существует
организации, которая бы управляла и обслуживала
все дерево в целом и каждую метку в отдельности.
Вместо этого, одна организация (NIC) обслуживает
только часть дерева (домены верхнего уровня), а
ответственность за определенные зоны передает
другим организациям. </small></p>

<p><small><a NAME="t142012"></a>Зона (zone) это отдельно
администрируемая часть дерева DNS. Например, домен
второго уровня <a NAME="t142013"></a>noao.edu это отдельная
зона. Многие домены второго уровня поделены на
меньшие зоны. Например, университет может
поделить свою зону на подзоны по факультетам, а
компания может поделить себя на зоны по принципу
деления на филиалы или отделы.</small></p>

<p>&nbsp;</p>


<p>Если Вы знакомы с
файловой системой Unix, то обратите внимание, что
деление дерева DNS на зоны очень напоминает
деление на логические файловые системы
физических дисковых разделов. Однако мы не можем
сказать, основываясь на рисунке 14.1, под чьим
руководством находятся зоны, также как мы не
можем по подобному рисунку сказать, какие
директории в файловой системе находятся в
определенном дисковом разделе.</p>


<p>&nbsp;</p>

<p><small>С того момента, как выбрана организация или
персона, которая несет ответственность за
управление зоной, эта организация или персона
должна организовать несколько серверов DNS (name
servers) для этой зоны. Как только в зоне появляется
новая система, администратор этой зоны помещает
имя и IP адрес нового хоста в базу данных сервера
DNS. В небольших университетах, например, один
человек может делать это каждый раз при
появлении новой системы, однако в больших
университетах ответственность должна быть
распределена (например, по департаментам), так
как один человек не может осуществлять эту
работу в целом. </small></p>

<p><small><a NAME="t142014"></a>Сервер DNS, скажем, обслуживает
одну зону или несколько зон. Человек, который
несет ответственность за зону, администрирует <a NAME="t142015"></a>основной сервер DNS (primary name server) для этой
зоны и один или несколько <a NAME="t142016"></a>вторичных
серверов DNS (secondary name servers). Первичный и вторичный
сервера должны быть независимы и избыточны таким
образом, чтобы система DNS не вышла из строя при
отказе одного из серверов. </small></p>

<p><small>Основное отличие между первичными и
вторичными серверами заключается в том, что
первичные загружают всю необходимую информацию
из дисковых файлов, тогда как вторичные получают
информацию от первичного. Процесс передачи
информации от первичного сервера вторичному
называется <a NAME="t142017"></a>передачей зоны (zone transfer).
Когда в зоне появляется новый хост,
администратор добавляет соответствующую
информацию (минимум, имя и IP адрес) в дисковый
файл на первичном сервере. После чего первичный
сервер DNS уведомляется о необходимости повторно
считать свои конфигурационные файлы. Вторичные
сервера регулярно опрашивают первичные (обычно
каждые 3 часа), и если первичные содержат новую
информацию, вторичный получает ее с
использованием передачи зоны. </small></p>

<p><small>Что произойдет, если сервер DNS не содержит
необходимой информации? Он должен установить
контакт с другим сервером DNS. (В этом заключается
распределенная природа DNS.) Однако не каждый
сервер DNS знает, как обратиться к другому серверу.
Вместо этого каждый сервер DNS должен знать, как
установить контакт с <a NAME="t142018"></a>корневыми
серверами DNS (root name servers). В апреле 1993 года
существовало восемь корневых серверов, все
первичные сервера должны знать IP адреса каждого
корневого сервера. (Эти IP адреса находятся в
конфигурационных файлах первичного сервера.
Первичные сервера должны знать именно IP адреса
корневых серверов, а не их DNS имена.) Корневой
сервер, в свою очередь, знает имена и положения (IP
адрес) каждого официального сервера DNS для всех
доменов второго уровня. При этом возникает
последовательный процесс: запрашивающий сервер
должен установить контакт с корневым сервером.
Корневой сервер сообщает запрашивающему серверу
о необходимости обратиться к другому серверу и
так далее. Мы рассмотрим эту процедуру и
соответствующие примеры позже в этой главе.</small></p>

<p>&nbsp;</p>


<p>Вы можете получить
текущий список корневых серверов,
воспользовавшись анонимным (anonymous) FTP. Получите
файл <a NAME="t142019"></a>netinfo/root-servers.txt с <a NAME="t142020"></a>ftp.rs.internic.net
или <a NAME="t142021"></a>nic.ddn.mil.</p>


<p>&nbsp;</p>

<p><small>Фундаментальная характеристика DNS - это
кэширование (caching). Когда DNS сервер получает
информацию о соответствии (скажем, IP адресов
именам хостов), он кэширует эту информацию таким
образом, что в случае следующего запроса может
быть использована информация из кэша,
дополнительный запрос на другие сервера не
делается. В разделе <a HREF="#t147000">&quot;Кэширование&quot;</a>
этой главы мы рассмотрим кэширование более
подробно.</small></p>
<u><b>

<p><a NAME="t143000"></a>Формат сообщения DNS</p>
</b></u>

<p><small>Для DNS запроса и для DNS отклика используется
одинаковый формат. На рисунке 14.3 показан общий
формат DNS сообщения.<a NAME="t143001"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t14_3_20.jpg" WIDTH="519" HEIGHT="367"></small></p>


<p ALIGN="CENTER"><small>Рисунок 14.3 Общий формат DNS запроса и
ответа.</small></p>

<p>&nbsp;</p>

<p><small>Сообщение содержит фиксированный 12-байтный
заголовок, за которым следуют четыре поля
переменной длины. </small></p>

<p><small>Значение в поле идентификации (identification)
устанавливается клиентом и возвращается
сервером. Это поле позволяет клиенту определить,
на какой запрос пришел отклик. </small></p>

<p><small>16-битовое поле флагов (flags) поделено на
несколько частей, как показано на рисунке 14.4.<a NAME="t143002"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t14_4_20.jpg" WIDTH="321" HEIGHT="150"></small></p>


<p ALIGN="CENTER"><small>Рисунок 14.4 Поле флагов (flags) в
заголовке DNS.</small></p>

<p>&nbsp;</p>

<p><small>Описание каждого поля мы начнем с крайне
левых битов.</small> 

<ul>
  <li><small>QR (тип сообщения), 1-битовое поле: 0 обозначает
    - запрос, 1 обозначает - отклик. </small></li>
  <li><small>opcode (код операции), 4-битовое поле. Обычное
    значение 0 (стандартный запрос). Другие значения -
    это 1 (инверсный запрос) и 2 (запрос статуса
    сервера). </small></li>
  <li><small>AA - 1-битовый флаг, который означает <a NAME="t143003"></a>&quot;авторитетный
    ответ&quot; (authoritative answer). Сервер DNS имеет полномочия
    для этого домена в разделе вопросов. </small></li>
  <li><small>TC - 1-битовое поле, которое означает <a NAME="t143004"></a>&quot;обрезано&quot;
    (truncated). В случае UDP это означает, что полный размер
    отклика превысил 512 байт, однако были возвращены
    только первые 512 байт отклика. </small></li>
  <li><small>RD - 1-битовое поле, которое означает
    &quot;требуется рекурсия&quot; (recursion desired). Бит может
    быть установлен в запросе и затем возвращен в
    отклике. Этот флаг требует от DNS сервера
    обработать этот запрос самому (т.е. сервер должен
    сам определить требуемый IP адрес, а не возвращать
    адрес другого DNS сервера), что называется <a NAME="t143005"></a>рекурсивным запросом (recursive query). Если
    этот бит не установлен и запрашиваемый сервер DNS
    не имеет авторитетного ответа, запрашиваемый
    сервер возвратит список других серверов DNS, к
    которым необходимо обратиться, чтобы получить
    ответ. Это называется <a NAME="t143006"></a>повторяющимся
    запросом (iterative query) . Мы рассмотрим примеры обоих
    типов запросов в следующих примерах. </small></li>
  <li><small>RA - 1-битовое поле, которое означает
    &quot;рекурсия возможна&quot; (recursion available). Этот бит
    устанавливается в 1 в отклике, если сервер
    поддерживает рекурсию. Мы увидим в наших
    примерах, что большинство серверов DNS
    поддерживают рекурсию, за исключением
    нескольких корневых серверов (коневые сервера не
    в состоянии обрабатывать рекурсивные запросы
    из-за своей загруженности). </small></li>
  <li><small>Это 3-битовое поле должно быть равно 0. </small></li>
  <li><small>rcode это 4-битовое поле кода возврата. Обычные
    значения: 0 (нет ошибок) и 3 (ошибка имени). Ошибка
    имени возвращается только от полномочного
    сервера DNS и означает, что имя домена, указанного
    в запросе, не существует.</small></li>
</ul>

<p><small>Следующие четыре 16-битных поля указывают на
количество пунктов в четырех полях переменной
длины, которые завершают запись. В запросе
количество вопросов (number of questions) обычно равно 1, а
остальные три счетчика равны 0. В отклике
количество ответов (number of answers) по меньшей мере
равно 1, а оставшиеся два счетчика могут быть как
нулевыми, так и ненулевыми.</small></p>
<i><b>

<p>Раздел вопросов в DNS запросе</p>
</b></i>

<p><small>Формат каждого вопроса в разделе вопросов
(question) показан на рисунке 14.5. Обычно присутствует
только один вопрос. </small></p>

<p><small>Имя запроса (query name) это искомое имя. Оно
выглядит как последовательность из одной или
нескольких меток. Каждая <a NAME="t143007"></a>метка
начинается с 1-байтового счетчика, который
содержит количество следующих за ним байт. Имя
заканчивается байтом равным 0, который является
меткой с нулевой длиной. И является, в свою
очередь, меткой корня. Каждый счетчик байтов
должен быть в диапазоне от 0 до 63, так как длина
метки ограничена 63 байтами.<a NAME="t143008"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t14_5_20.jpg" WIDTH="480" HEIGHT="109"></small></p>


<p ALIGN="CENTER"><small>Рисунок 14.5 Формат раздела вопроса
(question) в запросе DNS.</small></p>

<p>&nbsp;</p>

<p><small>(Дальше в этом разделе мы увидим, что байт
счетчик с двумя старшими битами, установленными
в 1, значения от 192 до 255, используется в схеме со
сжатием.) В отличие от многих других форматов
сообщений, которые мы рассмотрели, этому полю
разрешено заканчиваться на ограничителе не
равном 32 битам. Заполнение не используется. </small></p>

<p><small>На рисунке 14.6 показано, как хранится имя
домена gemini.tuc.noao.edu.<a NAME="t143009"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t14_6_20.jpg" WIDTH="436" HEIGHT="64"></small></p>


<p ALIGN="CENTER"><small>Рисунок 14.6 Представление имени
домена gemini.tuc.noao.edu.</small></p>

<p>&nbsp;</p>

<p><small>У каждого вопроса есть тип запроса (query type), а
каждый отклик (называемый записью ресурса, о чем
мы поговорим ниже) имеет тип (type). Существует
около 20 различных значений, некоторые из которых
в настоящее время уже устарели. На рисунке 14.7
показаны некоторые из этих значений. Тип запроса
это надмножество (множество, подмножеством
которого является данное множество) типов: два из
показанных значений, могут быть использованы
только в вопросах.<a NAME="t143010"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="552">
  <tr>
    <td WIDTH="19%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Имя</small></td>
    <td WIDTH="21%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Цифровое
    значение</small></td>
    <td WIDTH="30%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Описание</small></td>
    <td WIDTH="13%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>тип
    (type)?</small></td>
    <td WIDTH="16%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>тип
    запроса (query type)?</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><small>A</small></td>
    <td WIDTH="21%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="30%" VALIGN="TOP"><small>IP адрес</small></td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><small><a NAME="t143011"></a>NS</small></td>
    <td WIDTH="21%" VALIGN="TOP"><p ALIGN="CENTER"><small>2</small></td>
    <td WIDTH="30%" VALIGN="TOP"><small>сервер DNS</small></td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><small><a NAME="t143012"></a>CNAME</small></td>
    <td WIDTH="21%" VALIGN="TOP"><p ALIGN="CENTER"><small>5</small></td>
    <td WIDTH="30%" VALIGN="TOP"><small>каноническое имя</small></td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><small>PTR</small></td>
    <td WIDTH="21%" VALIGN="TOP"><p ALIGN="CENTER"><small>12</small></td>
    <td WIDTH="30%" VALIGN="TOP"><small>запись указателя</small></td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><small><a NAME="t143013"></a>HINFO</small></td>
    <td WIDTH="21%" VALIGN="TOP"><p ALIGN="CENTER"><small>13</small></td>
    <td WIDTH="30%" VALIGN="TOP"><small>информация о хосте</small></td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><small><a NAME="t143014"></a>MX</small></td>
    <td WIDTH="21%" VALIGN="TOP"><p ALIGN="CENTER"><small>15</small></td>
    <td WIDTH="30%" VALIGN="TOP"><small>запись об обмене
    почтой</small></td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><small><a NAME="t143015"></a>AXFR</small></td>
    <td WIDTH="21%" VALIGN="TOP"><p ALIGN="CENTER"><small>252</small></td>
    <td WIDTH="30%" VALIGN="TOP"><small>запрос на передачу
    зоны</small></td>
    <td WIDTH="13%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><small>* или <a NAME="t143016"></a>ANY </small></td>
    <td WIDTH="21%" VALIGN="TOP"><p ALIGN="CENTER"><small>255</small></td>
    <td WIDTH="30%" VALIGN="TOP"><small>запрос всех
    записей</small></td>
    <td WIDTH="13%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>╥ </small></td>
  </tr>
</table>


<p><small>Рисунок 14.7 Значения type и query type для DNS
вопросов и ответов. </small></p>

<p>&nbsp;</p>

<p><small>Наиболее распространенный тип запроса - тип
<a NAME="t143017"></a>A, который обозначает, что необходим IP
адрес для запрашиваемого имени (query name). <a NAME="t143018"></a>PTR
запрос требует имена, соответствующие IP адресу.
Это запрос указателя, который мы опишем в разделе
<a HREF="#t145000">&quot;Запросы указателя&quot;</a> этой главы.
Другие типы запросов мы опишем в разделе <a HREF="#t146000">&quot;Записи ресурсов&quot;</a> этой главы. </small></p>

<p><small><a NAME="t143019"></a>Класс запроса (query class) обычно
равен 1, что указывает на адреса Internet. (В некоторых
случаях поддерживаются не-IP значения.)</small></p>
<i><b>

<p>Часть записи ресурса в отклике DNS</p>
</b></i>

<p><small>Последние три поля в DNS сообщении это ответы
(answers), полномочия (authority) и дополнительная
информация (additional information), общий формат
называется записью ресурса (<a NAME="t143020"></a>RR - resource
record). На рисунке&nbsp;14.8 показан формат записи
ресурса.<a NAME="t143021"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t14_8_20.jpg" WIDTH="481" HEIGHT="240"></small></p>


<p ALIGN="CENTER"><small>Рисунок 14.8 Формат записи ресурса DNS.</small></p>

<p>&nbsp;</p>

<p><small>Имя домена (domain name) это имя, которому
соответствуют следующие данные ресурса. Формат
имени домена тот же, что мы описали ранее для поля
имени запроса (query name) (рисунок 14.6). </small></p>

<p><small>Тип (type) указывает на один из типов кодов RR.
Это то же самое, что и значения типа запроса (query
type), которые мы описали раньше. Для данных Internet
класс (class) обычно установлен в 1. </small></p>

<p><small>Поле <a NAME="t143022"></a>время жизни (time-to-live) это
количество секунд, в течение которых RR может быть
кэширована клиентом. Обычно TTL RR равно 2 дням. </small></p>

<p><small>Длина записи ресурса (resource data length) указывает
на количество данных ресурса (resource data). Формат
этих данных зависит от типа (type). Для типа равного
1 (запись A) данные ресурса - это 4-байтный IP адрес.
Сейчас мы описали основной формат DNS запросов и
откликов. </small></p>

<p><small>Теперь посмотрим с использованием <a NAME="t143023"></a>tcpdump, как они упаковываются в пакеты и
как происходит обмен. </small></p>
<u><b>

<p><a NAME="t144000"></a>Простой пример</p>
</b></u>

<p><small>Давайте посмотрим, как происходит общение
между разборщиком и сервером DNS. Мы запустили
клиента Telnet с хоста sun на хост gemini, подключившись
к серверу времени:</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>telnet gemini daytime</b><br>
Trying 140.252.1.11 ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; первые
три строки вывода от Telnet клиента<br>
Connected to gemini.tuc.noao.edu.<br>
Escape character is '^]'.<br>
Wed Mar 24 10:44:17 1993
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вывод
от сервера дневного времени<br>
Connection closed by foreign host.&nbsp;&nbsp;&nbsp; вывод от Telnet клиента<br>
</p>


<p>&nbsp;</p>

<p><small>В этом примере мы указали разборщику на
хосте sun (где запущен клиент Telnet) использовать
сервер DNS на хосте noao.edu (140.252.1.54). На рисунке 14.9
показано взаимное расположение этих трех систем.<a NAME="t144001"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t14_9_20.jpg" WIDTH="281" HEIGHT="157"></small></p>


<p ALIGN="CENTER"><small>Рисунок 14.9 Системы, используемые в
примере работы DNS.</small></p>

<p>&nbsp;</p>

<p><small>Как мы уже упомянули ранее, разборщик
является частью клиента. Он устанавливает
контакт с сервером DNS, чтобы получить IP адрес,
перед тем как будет установлено TCP соединение
между Telnet и сервером времени. </small></p>

<p><small>На этом рисунке мы опустили подробности,
описывающие, как происходит общение между sun и
Ethernet сетью 140.252.1, которое в действительности
осуществляется по SLIP каналу, потому что это не
относится к нашим рассуждениям. Мы запустим <a NAME="t144002"></a>tcpdump на SLIP канале, чтобы посмотреть, как
происходит обмен пакетами между разборщиком и
сервером DNS. </small></p>

<p><small>Файл <a NAME="t144003"></a>/etc/resolv.conf на хосте sun
сообщает разборщику о необходимости сделать
следующее:</small></p>

<p>&nbsp;</p>


<p>sun % <b>cat /etc/resolv.conf<br>
</b>nameserver 140.252.1.54<br>
domain tuc.noao.edu&nbsp;</p>

<p>&nbsp;</p>

<p><small>Первая строка сообщает IP адрес DNS сервера -
хоста noao.edu. Может быть указано до трех строк <a NAME="t144004"></a>nameserver, таким образом, будет обеспечен
запасной сервер на случай, если один из них
выключен или недоступен. Строка <a NAME="t144005"></a>domain
содержит домен по умолчанию. Если искомое имя не
является полным именем домена (не заканчивается
точкой), к имени добавляется имя домена по
умолчанию .tuc.noao.edu. Именно поэтому мы можем ввести
telnet gemini вместо telnet gemini.tuc.noao.edu. </small></p>

<p><small>На рисунке 14.10 показан обмен пакетами между
разборщиком и сервером DNS.<a NAME="t144006"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 140.252.1.29.1447
&gt; 140.252.1.54.53: 1+ A?<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gemini.tuc.noao.edu.
(37)<br>
<br>
2&nbsp; 0.290820 (0.2908)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 140.252.1.54.53 &gt;
140.252.1.29.1447: 1* 2/0/0 A <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 140.252.1.11
(69)<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 14.10 Вывод команды tcpdump для запроса
на сервер DNS на хосте gemini.tuc.noao.edu.</small></p>

<p>&nbsp;</p>

<p><small>Мы проинструктировали tcpdump не печатать
имена доменов для IP адресов источника и
назначения каждой IP датаграммы. Вместо этого он
печатает 140.252.1.29 для клиента (разборщик) и 140.252.1.54
для сервера DNS. Порт 1447, используемый клиентом,
это порт, назначаемый динамически, а 53 это
заранее известный порт DNS сервера. Если tcpdump
постарается напечатать имена вместо IP адресов,
ему придется обратиться к тому же DNS серверу
(осуществляя запрос указателя), что может
привести к нежелательному выводу. </small></p>

<p><small>Начиная со строки 1, поле после двоеточия (1+)
означает, что поле идентификации равно 1, а знак
плюс обозначает, что установлен флаг <a NAME="t144007"></a>RD
(требуется рекурсия). Мы видим, что по умолчанию
разборщик требует рекурсию. </small></p>

<p><small>Следующее поле, A?, означает, что тип запроса
- A (мы хотим получить IP адрес), а маркировка
вопроса обозначает, что это запрос (не ответ).
Затем печатается имя запроса: gemini.tuc.noao.edu..
Разборщик добавляет последнюю точку к имени
запроса, указывая на то, что это абсолютное имя
домена. </small></p>

<p><small>Длина пользовательских данных в UDP
датаграмме составляет 37 байт: 12 байт - заголовок
фиксированного размера (рисунок 14.3), 21 байт - имя
запроса (рисунок 14.6) и 4 байта - тип запроса и класс
запроса. То что UDP датаграмма имеет нечетную
длину напоминает нам, что в DNS сообщениях не
используются биты заполнения. </small></p>

<p><small>Строка 2 в выводе команды <a NAME="t144008"></a>tcpdump
это ответ от DNS сервера, где 1* в поле
идентификации со звездочкой обозначает, что
установлен флаг <a NAME="t144009"></a>AA (авторитетный
ответ). (Мы ожидали от сервера именно этого, так
как первичный сервер для домена <a NAME="t144010"></a>noao.edu
имеет полное представление об именах внутри
этого домена.) </small></p>

<p><small>Вывод 2/0/0 показывает количество записей
ресурсов в трех последних полях с переменной
длиной отклика: 2 ответ RR, 0 полномочия RR и 0
дополнительные RR. Команда tcpdump печатает только
первый ответ, который в данном случае имеет тип A
(IP адрес) со значением 140.252.1.11. </small></p>

<p><small>Почему мы получили два ответа на наш запрос?
Потому что хост gemini имеет <a NAME="t144011"></a>несколько
интерфейсов. Поэтому возвращено два IP адреса.
Другое полезное средство, использующее DNS, - это
программа <a NAME="t144012"></a>host. Она позволяет нам
отправить запрос на DNS сервер и посмотреть что
вернется. Если мы запустим эту программу, то
увидим два IP адреса для хоста gemini:</small></p>

<p>&nbsp;</p>


<p>sun % <b>host gemini<br>
</b>gemini.tuc.noao.edu A 140.252.1.11<br>
gemini.tuc.noao.edu A 140.252.3.54</p>


<p>&nbsp;</p>

<p><small>Первый ответ на рисунке 14.10 и первая строка
вывода команды host - IP адрес, принадлежащий той же
подсети (140.252.1), что и запрашивающий хост. В этом
нет ничего странного. Если сервер DNS и хост,
отправляющий запрос, находятся в той же самой
сети (или подсети), <a NAME="t144013"></a>BIND сортирует
результаты таким образом, чтобы адреса,
принадлежащие общей сети, появлялись в первую
очередь.</small></p>

<p>&nbsp;</p>


<p>Мы также можем получить
доступ к хосту gemini с использованием другого
адреса, однако это будет не так эффективно. С
использованием <a NAME="t144014"></a>traceroute в этом примере
можно увидеть, что обычный путь от подсети 140.252.1 к
140.252.3 не проходит через хост gemini, а проходит через
другой маршрутизатор, который подключен к обеим
сетям. В данном случае, если мы получим доступ к
gemini через другой IP адрес (140.252.3.54), все пакеты
потребуют еще одной дополнительной пересылки. Мы
вернемся к этому примеру и рассмотрим более
подробно причины, по которым используется
альтернативный маршрут, в разделе <a HREF="tcp25.html#t259000">&quot;Дополнительные примеры&quot;</a>
главы 25, где мы сможем использовать SNMP, чтобы
посмотреть таблицу маршрутизации
маршрутизатора.</p>

<p>&nbsp;</p>

<p>Существуют и другие
программы, предоставляющие простой
интерактивный доступ к DNS. Программа <a NAME="t144015"></a>nslookup
поставляется с большинством реализаций DNS. Глава
10 <a NAME="t144016"></a>[Albitz and Liu 1992] подробно описывает эту
программу. Программа <a NAME="t144017"></a>dig (Domain Internet Groper)
это еще одна общедоступная программа, с помощью
которой можно отправить запросы на DNS сервера.
Программа <a NAME="t144018"></a>doc (Domain Obscenity Control) -
shellовский скрипт, который использует dig и
диагностирует поведение доменов, отправляя
запросы на соответствующие DNS сервера и
осуществляя простой анализ откликов. В <a HREF="tcp_f.html">приложении F</a> подробно рассказано, как
можно получить эти программы.</p>

<p>&nbsp;</p>


<p><small>И последняя деталь, на которую необходимо
обратить внимание в этом примере, это размер UDP
данных в отклике: 69 байт. Чтобы объяснить эту
величину, надо знать две вещи.</small> 

<ol>
  <li><small>Вопрос возвращается в отклике.</small></li>
  <li><small>При отправке отклика с именами доменов
    может быть использовано множество повторов.
    Поэтому используется схема сжатия. И
    действительно, в нашем примере имя домена
    gemini.tuc.noao.edu появляется трижды. Схема сжатия
    довольно проста. Везде, где в имени домена
    появляется метка, используется единственный
    байт-счетчик (который находится в диапазоне от 0
    до 63), у которого два старших бита установлены в 1.
    Это 16-битный <a NAME="t144019"></a>указатель, а не 8-битный
    байт-счетчик. Следующие 14 байт в указателе
    определяют смещение следующей метки в DNS
    сообщении. (Смещение первого байта в поле
    идентификации равно 0.) Мы специально сказали, что
    этот указатель может появиться там, где
    появляется метка, а не только там, где появляется
    полное имя домена, однако возможно, что указатель
    будет иметь как форму полного имени домена, так и
    всего лишь окончательной части имени. (Это
    потому, что окончательные метки в именах
    заданных доменов часто бывают идентичны.)</small></li>
</ol>

<p><small>На рисунке 14.11 показан формат DNS отклика, что
соответствует строке 2 на рисунке 14.10. Здесь
показаны IP и UDP заголовки, чтобы напомнить о том,
что DNS сообщения обычно инкапсулируются в UDP
датаграммы. Мы специально показали байты
счетчики в метках имен доменов в вопросе. Два
возвращенных ответа одинаковы, за исключением
различных IP адресов. В этом примере каждый
указатель в ответе имеет значение 12, что является
смещением от начала DNS заголовка полного имени
домена. </small></p>

<p><small>И последнее, на что необходимо обратить
внимание, это вторая строка из вывода команды
Telnet, которая повторена здесь:<a NAME="t144020"></a></small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>telnet gemini daytime </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; мы
напечатали только gemini<br>
Trying 140.252.1.11 ...<br>
Connected to gemini.tuc.noao.edu.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; однако
в выводе клиента Telnet появился FQDN<br>
</p>


<p>&nbsp;</p>

<p>&nbsp;</p>


<p ALIGN="CENTER"><small><img SRC="t14_11_2.jpg" WIDTH="492" HEIGHT="335"></small></p>


<p ALIGN="CENTER"><small>Рисунок 14.11 Формат DNS отклика,
соответствующий строке 2 на рисунке 14.10.</small></p>

<dir>
  <dir>
    <p>&nbsp;</p>
  </dir>
</dir>

<p><small>Мы указали только имя хоста (gemini), а не
полное имя домена (<a NAME="t144021"></a>FQDN) , однако клиент
Telnet вывел именно полное имя домена. В данном
случае клиент Telnet ищет имя, которое мы ввели,
вызвав разборщик (gethostbyname), который возвращает IP
адрес и FQDN. Затем Telnet выводит IP адрес, с которым он
старается установить TCP соединение, и когда
соединение установлено, печатает FQDN. </small></p>

<p><small>Пауза между вводом команды Telnet и печатью IP
адреса, вызвана тем, что разборщик устанавливает
контакт с DNS сервером, чтобы преобразовать имя в IP
адрес. Пауза между выводом Trying и Connected to, вызвана
установлением TCP соединения между клиентом и
сервером, а не DNS.</small></p>
<u><b>

<p><a NAME="t145000"></a>Запросы указателя</p>
</b></u>

<p><small>Для понимания работы DNS важно знать, как
обрабатываются запросы указателя - задан IP адрес,
возвращается имя (или имена), соответствующее
этому адресу. </small></p>

<p><small>Во-первых, вернемся к рисунку 14.1 и
рассмотрим домен верхнего уровня <a NAME="t145001"></a>arpa,
а также домен in-addr, находящийся ниже. Когда
организация вступает в Internet и получает часть
простраства имен DNS, как, например, noao.edu, она также
получает право на часть пространства имен <a NAME="t145002"></a>in-addr.arpa, соответствующее ее IP адресам в
Internet. В данном случае <a NAME="t145003"></a>noao.edu - это сеть
класса B с идентификатором 140.252. Уровень дерева DNS
ниже in-addr.arpa должен быть первым байтом IP адреса (140
в данном примере), следующий уровень это
следующий байт IP адреса (252), и так далее. Однако
помните, что имена пишутся, снизу-вверх по дереву
DNS. Это означает, что DNS имя хоста sun с IP адресом
140.252.13.33 будет 33.13.252.140.in-addr.arpa. </small></p>

<p><small>Мы должны написать 4 байта IP адреса задом
наперед, потому что полномочия делегируются на
основе идентификаторов сетей: первый байт адрес
класса A, первый и второй байты адреса класса B, а
первый, второй и третий байты это адреса класса C.
Первый байт IP адреса должен быть непосредственно
под меткой in-addr, однако полные имена доменов (<a NAME="t145004"></a>FQDN) пишутся снизу вверх по дереву. Если
бы FQDN писались сверху вниз, DNS имя для IP адреса
было бы arpa.in-addr.140.252.13.33, однако в этом случае FQDN
для хоста должно быть edu.noao.tuc.sun. </small></p>

<p><small>Без отдельных ветвей дерева DNS осуществить
преобразования адрес - имя, (обратное
преобразование) можно было бы только начиная от
корня дерева и просматривая каждый домен
верхнего уровня. При сегодняшнем размере Internet
это могло бы занять дни или даже недели.
Использование же in-addr.arpa приемлемый вариант,
несмотря на переставленные местами байты в IP
адресе и специальные домены, иногда вносящие
определенную путаницу. </small></p>

<p><small>Однако встретиться с доменом in-addr.arpa и
переставленными байтами в IP адресе можно только
тогда, когда мы общаемся с DNS непосредственно,
используя, такие программы как host или
просматривая пакеты с использованием tcpdump. При
работе приложения, разборщик (<a NAME="t145005"></a>gethostbyaddr)
обычно воспринимает IP адрес и возвращает
информацию о хосте. Перестановка байтов и
добавление домена in-addr.arpa осуществляется
разборщиком автоматически. </small></p>
<i><b>

<p>Пример</p>
</b></i>

<p><small>Давайте воспользуемся программой <a NAME="t145006"></a>host,
чтобы осуществить поиск указателя, и при этом
просмотрим с использованием tcpdump как происходит
обмен пакетами. Мы используем те же начальные
установки как на рисунке 14.9, запустив программу
host на хосте sun с тем же самым сервером DNS noao.edu. Мы
указали IP адрес нашего хоста svr4:</small></p>

<p>&nbsp;</p>


<p>sun % <b>host 140.252.13.34<br>
</b>Name: svr4.tuc.noao.edu<br>
Address: 140.252.13.34</p>


<p>&nbsp;</p>

<p><small>Так как единственный аргумент в командной
строке это IP адрес, программа host автоматически
генерирует запрос указателя. На рисунке 14.12
показан вывод команды tcpdump.<a NAME="t145007"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 140.252.1.29.1610
&gt; 140.252.1.54.53: 1+ PTR? <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 34.13.252.140.in-addr.arpa.
(44)<br>
<br>
2&nbsp; 0.332288 (0.3323)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 140.252.1.54.53 &gt;
140.252.1.29.1610: 1* 1/0/0 PTR <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; svr4.tuc.noao.edu.
(75)<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 14.12 Вывод tcpdump для запроса
указателя.</small></p>

<p>&nbsp;</p>

<p><small>Из строки 1 видно, что идентификатор равен 1,
установлен флаг требования рекурсии (знак плюс),
и тип запроса это <a NAME="t145008"></a>PTR. (Вспомним, что
марка вопроса обозначает, что это запрос, а не
отклик.) Размер данных составляет 44 байта, из
которых 12 байт - DNS заголовок, 28 байт - 7 меток в
имени домена, и 4 байта это тип запроса и класс
запроса. </small></p>

<p><small>В отклике установлен бит <a NAME="t145009"></a>авторитетного
ответа (звездочка) и содержится одна запись
ресурса (RR) ответа. Тип RR это PTR, а данные ресурса
содержат имя домена. </small></p>

<p><small>От разборщика к серверу DNS в качестве
запроса указателя передается не 32-битный IP адрес,
а имя домена 34.13.252.140.in-addr.arpa.</small></p>
<i><b>

<p><a NAME="t145010"></a>Проверка неправильного имени хоста</p>
</b></i>

<p><small>Когда IP датаграмма прибывает на хост
сервера, будь то UDP датаграмма или TCP сегмент с
требованием установить соединение, все что
доступно процессу сервера это IP адрес клиента и
номер порта (UDP или TCP). Некоторые сервера требуют,
чтобы IP адрес клиента имел запись указателя в DNS.
В разделе <a HREF="tcp27.html#t273000">&quot;Примеры FTP&quot;</a>
главы 27 мы рассмотрим пример, иллюстрирующий это,
используя анонимный FTP с неизвестного IP адреса. </small></p>

<p><small>Другие серверы, как, например, сервер Rlogin (<a HREF="tcp26.html">глава 26</a>), требуют не только то, чтобы IP
адрес клиента имел запись указателя, но и еще
спрашивают DNS об IP адресе, соответствующем имени,
возвращенном в PTR отклике, и требуют, чтобы один
из возвращенных адресов совпадал с IP адресом в
принятой датаграмме. Эта проверка
осуществляется потому, что пункты в файле <a NAME="t145011"></a>.rhosts (глава 26, раздел <a HREF="tcp26.html#t262000">&quot;Протокол
Rlogin&quot;</a>) содержат имя хоста, а не IP адрес; таким
образом, сервер хочет убедиться, что имя хоста
действительно соответствует входящему IP адресу. </small></p>

<p><small>Некоторые производители автоматически
помещают эту проверку в программы разборщика,
конкретно в функцию gethostbyaddr. При этом подобная
проверка становится доступной для любой
программы, использующей разборщик. Отпадает
необходимость помещать эту проверку в каждое
приложение. </small></p>

<p><small>Мы можем увидеть, как это происходит, с
помощью библиотеки разборщика <a NAME="t145012"></a>SunOS
4.1.3. Мы написали простую программу, которая
осуществляет запрос указателя путем вызова
функции gethostbyaddr. Также мы поместили записи в файл <a NAME="t145013"></a>/etc/resolv.conf таким образом, чтобы
использовать в качестве DNS сервера хост noao.edu,
получить доступ к которому можно через SLIP канал с
хоста sun. На рисунке 14.13 показан вывод команды
tcpdump, полученный от SLIP канала, при вызове функции
gethostbyaddr, в случае, когда получается имя,
соответствующее IP адресу 140.252.1.29 (хост sun).<a NAME="t145014"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.1812
&gt; noao.edu.domain: 1+ PTR? <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 29.1.252.140.in-addr.arpa.
(43)<br>
2&nbsp; 0.339091 (0.3391)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; noao.edu.domain &gt; sun.1812: 1*
1/0/0 PTR <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.tuc.noao.edu.
(73)<br>
3&nbsp; 0.344348 (0.0053)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.1813 &gt; noao.edu.domain: 2+
A? <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.tuc.noao.edu.
(33)<br>
4&nbsp; 0.669022 (0.3247)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; noao.edu.domain &gt; sun.1813: 2*
2/0/0 A <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 140.252.1.29
(69)<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 14.13 Вызов функции разборщика,
которая осуществляет запрос указателя.</small></p>

<p>&nbsp;</p>

<p><small>В строке 1 запрос указателя, в строке 2
отклик. Однако, функция разборщика автоматически
посылает запрос об IP адресе в строке 3 на имя,
возвращенное в строке 2. Отклик в строке 4
содержит две записи ответа, так как хост sun имеет
два IP адреса. Если ни один из адресов не совпал с
аргументом gethostbyaddr, отправляется сообщение
системе, которая фиксирует событие, а функция
возвращает ошибку приложению.</small></p>
<u><b>

<p><a NAME="t146000"></a>Записи ресурсов</p>
</b></u>

<p><small>Мы видели несколько различных типов
записей ресурса (<a NAME="t146001"></a>RR), а именно: IP адрес
имеет тип A, а PTR обозначает запрос указателя.
Также мы видели RR, которые возвращает DNS сервер: RR
ответа, RR полномочий и RR дополнительной
информации. Всего существует около 20 различных
типов записей ресурсов, некоторые из которых мы
сейчас опишем.</small> 

<dl>
  <p><small>А</small></p>
  <dd><small>Запись А определяет IP адрес. Хранится как
    32-битное двоичное значение.</small><p><small><a NAME="t146003"></a>
    </small></p>
  </dd>
  <p><small>PTR</small></p>
  <dd><small>Запись указателя используется для запросов
    указателя. IP адрес представляется в виде имени
    домена (последовательность меток) в домене
    in-addr.arpa.</small><p><small><a NAME="t146004"></a> </small></p>
  </dd>
  <p><small>CNAME</small></p>
  <dd><small>&quot;Каноническое имя&quot; (canonical name).
    Представляется как имя домена
    (последовательность меток). Имя домена, которое
    имеет каноническое имя, часто называется <a NAME="t146005"></a>псевдонимом (alias). Они используются
    некоторыми FTP узлами, для того чтобы предоставить
    легкозапоминаемый псевдоним для какой-либо
    системы.</small><p><small>Например, сервер <a NAME="t146006"></a>gated
    (мы упоминали о нем в разделе <a HREF="tcp10.html#t103000">&quot;Демоны
    маршрутизации в Unix&quot;</a> главы 10) доступен через
    анонимное FTP с сервера gated.cornell.edu. Однако, не
    существует системы, названной gated, это псевдоним
    для какой-то другой системы. Эта другая система
    является каноническим именем для gated.cornell.edu:</small></p>
    <p>&nbsp;</p>
    <p><br>
    sun % <b>host -t cname gated.cornell.edu</b><br>
    gated.cornell.edu&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CNAME
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMET.CIT.CORNELL.EDU<br>
    </p>
    <p>&nbsp;</p>
    <p><small>Здесь мы использовали опцию <a NAME="t146007"></a>-t,
    чтобы указать на один конкретный тип запроса.</small></p>
    <p><small><a NAME="t146008"></a> </small></p>
  </dd>
  <p><small>HINFO</small></p>
  <dd><small>Информация о хосте: две символьные строки,
    указывающие на центральный процессор (CPU) и
    операционную систему. Не все хосты предоставляют
    записи HINFO для своих систем, и предоставляемая
    информация может быть устаревшей.</small><p>&nbsp;</p>
    <p><br>
    sun % <b>host -t hinfo sun</b><br>
    sun.tuc.noao.edu&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HINFO
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sun-4/25 Sun4.1.3<br>
    </p>
    <p>&nbsp;</p>
    <p><small><a NAME="t146009"></a> </small></p>
  </dd>
  <p><small>MX</small></p>
  <dd><small>Записи, посвященные обмену почтой, которые
    используются по следующему сценарию: (1) узел,
    который не подсоединен к Internet, может
    использовать узел, который подсоединен к Internet, в
    качестве своего почтового сервера. Два узла
    работают попеременно, обмениваясь любой
    прибывшей почтой, в основном с использованием
    протокола <a NAME="t146010"></a>UUCP. (2) запись MX
    предоставляет возможность доставить почту на
    альтернативный хост, когда хост назначения
    недоступен. (3) записи MX позволяют организациям
    предоставлять виртуальные хосты, на которые
    можно отправлять почту, как, например, cs.university.edu,
    даже если хост с таким именем не существует. (4)
    Организации со <a NAME="t146011"></a>шлюзами firewall могут
    использовать записи MX, чтобы ограничить доступ к
    внутренним системам.</small><p><small>Многие хосты,
    которые не подключены к Internet, имеют UUCP каналы к
    хостам, подключеным к Internet, как, например, UUNET. С
    помощью записи MX обеспечивается передача
    электронной почты с использованием стандартного
    обращения user@host (пользователь@хост). Например,
    фиктивный домен foo.com может иметь следующую MX
    запись: </small></p>
    <p>&nbsp;</p>
    <p><br>
    sun % <b>host -t mx foo.com</b><br>
    foo.com&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MX
    &nbsp;&nbsp;&nbsp;&nbsp; relay1.UU.NET<br>
    foo.com&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MX
    &nbsp;&nbsp;&nbsp;&nbsp; relay2.UU.NET<br>
    </p>
    <p>&nbsp;</p>
    <p><small>MX записи используются программами доставки
    почты на хостах, подключенных к Internet. В этом
    примере программа доставки почты говорит
    &quot;если у тебя есть почта, которую необходимо
    послать на user@foo.com, пошли почту на relay1.uu.net или на
    relay2.uu.net&quot;.</small></p>
    <p><small>В каждой записи MX есть 16-битное целое
    значение, которое называется <a NAME="t146012"></a>значением
    предпочтительности. Если для одного пункта
    назначения существует несколько MX записей, они
    будут использованы по порядку, начиная с той
    записи, у которой наименьшее значение
    предпочтительности. </small></p>
    <p><small>Записи MX используются, когда хост выключен
    или недоступен. В этом случае программа доставки
    почты использует MX записи только в том случае,
    если не может подсоединиться к пункту назначения
    с использованием TCP. Для объединенных сетей, с
    которыми экспериментировал автор, его основная
    система подключена к Internet через SLIP канал, и если
    она не работает, мы получим:</small></p>
    <p>&nbsp;</p>
    <p><br>
    sun % <b>host -tv mx sun</b><br>
    Query about sun for record types MX<br>
    Trying sun within tuc.noao.edu ...<br>
    Query done, 2 answers,authoritative status: no error<br>
    sun.tuc.noao.edu&nbsp;&nbsp;&nbsp; 86400&nbsp;&nbsp;&nbsp; IN&nbsp;&nbsp;&nbsp; MX
    &nbsp;&nbsp;&nbsp; 0 sun.tuc.noao.edu<br>
    sun.tuc.noao.edu&nbsp;&nbsp;&nbsp; 86400&nbsp;&nbsp;&nbsp; IN&nbsp;&nbsp;&nbsp; MX
    &nbsp;&nbsp;&nbsp; 10 noao.edu<br>
    </p>
    <p>&nbsp;</p>
    <p><small>Опцию <a NAME="t146013"></a>-v позволяет посмотреть
    значения предпочтительности. (Благодаря этой
    опции в выводе появятся и все другие поля.) Второе
    поле, 86400, - это <a NAME="t146014"></a>время жизни в секундах.
    Время жизни равно 24 часам (24х60х60). Третья колонка,
    IN, это класс (Internet). Мы видим, что непосредственная
    доставка на хост (первая запись MX) имеет
    наименьшее значение предпочтительности равное 0.
    Если это не работает (SLIP канал выключен),
    используется следующее более высокое значение
    предпочтительности (10), и делается попытка
    доставить почту на хост noao.edu. Если и это не
    сработает, отправитель отработает тайм-аут и
    повторит попытки позже.</small></p>
    <p><small>В разделе <a HREF="tcp28.html#t283000">&quot;Примеры SMTP&quot;</a>
    главы 28 мы покажем примеры доставки почты SMTP с
    использованием записей MX.</small></p>
    <p><small><a NAME="t146015"></a> </small></p>
  </dd>
  <p><small>NS</small></p>
  <dd><small>Запись имени сервера. Указывает на
    полномочные DNS серверы для домена. Представлена в
    виде имен доменов (последовательность меток). Мы
    рассмотрим примеры этих записей в следующем
    разделе.</small></dd>
</dl>

<p>&nbsp;</p>

<p><small>Это общие типы RR. В следующих примерах мы
увидим еще некоторые типы.</small></p>
<u><b>

<p><a NAME="t147000"></a>Кэширование</p>
</b></u>

<p><small>Чтобы уменьшить траффик DNS в Internet, все
сервера DNS используют кэширование. В стандартных
Unix реализациях кэш поддерживается сервером, а не
разборщиком. Так как разборщик является частью
каждого приложения, а приложения приходят и
уходят, оставляя кэш в программах, которые живут
все время, пока система работает (сервер DNS), имеет
смысл поддерживать кэш именно на сервере. При
этом кэш доступен любому приложению, которое
использует сервер. Любые другие хосты в узле,
которые используют этот сервер DNS, также
пользуются кэшем сервера. </small></p>

<p><small>В примерах (рисунок 14.9), мы запускали
клиентов на хосте sun, и обращались к DNS серверу на
хост noao.edu через SLIP канал. Сейчас попробуем
запустить DNS сервер на хосте sun. В этом случае,
если просмотреть с использованием tcpdump траффик DNS
в SLIP канале, мы увидим только запросы, которые не
могут быть обработаны сервером в своем
собственном кэше. </small></p>

<p><small>По умолчанию разборщик ищет сервер DNS на
локальном хосте (UDP порт 53 или TCP порт 53). Мы
удалили запись <a NAME="t147001"></a>nameserver из файла
разборщика, оставив только запись <a NAME="t147002"></a>domain:
</small></p>

<p>&nbsp;</p>


<p>sun % <b>cat /etc/resolv.conf<br>
</b>domain tuc.noao.edu&nbsp;</p>

<p>&nbsp;</p>

<p><small>Отсутствие записи nameserver в этом файле
приводит к тому, что разборщик пользуется
сервером DNS на локальном хосте. </small></p>

<p><small>Затем мы запустили команду <a NAME="t147003"></a>host
следующим образом:</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>host ftp.uu.net</b><br>
ftp.uu.net&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A
&nbsp;&nbsp;&nbsp; 192.48.96.9<br>
</p>

<p>&nbsp;</p>


<p><small>На рисунке 14.14 показан вывод команды <a NAME="t147004"></a>tcpdump для этого запроса.<a NAME="t147005"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.tuc.noao.edu.domain
&gt; NS.NIC.DDN.MIL.domain: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2
A? ftp.uu.net. (28)<br>
2&nbsp; 0.559285 (0.5593)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NS.NIC.DDN.MIL.domain &gt;
sun.tuc.noao.edu.domain: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2-
0/5/5 (229)<br>
<br>
3&nbsp; 0.564449 (0.0052)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.tuc.noao.edu.domain &gt;
ns.UU.NET.domain: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3+
A? ftp.uu.net. (28)<br>
4&nbsp; 1.009476 (0.4450)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ns.UU.NET.domain &gt;
sun.tuc.noao.edu.domain: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3*
1/0/0 A ftp.UU.NET (44)<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 14.14 Вывод tcpdump для: host ftp.uu.net.</small></p>

<p>&nbsp;</p>


<p>Появилась новая опция
программы tcpdump. Мы получаем все данные,
направляющиеся к или от UDP или TCP портов 53, с
помощью опции <a NAME="t147006"></a>-w. В этом случае весь
символьный вывод сохраняется в файле для
дальнейшей обработки. При этом tcpdump не пытается
вызвать свой собственный разборщик, чтобы
напечатать все имена, соответствующие IP адресам.
После того как запущены все запросы, мы
перезапустили tcpdump с опцией <a NAME="t147007"></a>-r. В этом
случае программа читает выходной файл и
генерирует обычный вывод (который показан на
рисунке 14.14). Это занимает несколько секунд, так
как tcpdump вызывает свой разборщик.</p>


<p>&nbsp;</p>

<p><small>Первое на что необходимо обратить внимание
в выводе <a NAME="t147008"></a>tcpdump, это то, что
идентификаторы представляют собой небольшие
целые числа (2 и 3). Это потому, что мы выключили
сервер DNS и затем перестартовали его, чтобы
очистить кэш. Когда сервер DNS стартует, он
устанавливает идентификатор в 1. </small></p>

<p><small>Затем мы ввели запрос, в котором требуется
получить IP адрес для хоста ftp.uu.net, DNS сервер
установил соединение с одним из восьми <a NAME="t147009"></a>корневых
серверов, <a NAME="t147010"></a>ns.nic.ddn.mil (строка 1). Это
обычный запрос типа <a NAME="t147011"></a>A, который мы уже
видели ранее, однако обратите внимание, что флаг
требования рекурсии не установлен. (Если флаг
установлен, после идентификатора 2 должен быть
напечатан знак плюс.) В наших предыдущих примерах
говорилось, что разборщик устанавливает флаг
необходимости рекурсии, однако здесь мы видим,
что наш сервер DNS не установил флаг, когда он
обратился к одному из корневых серверов. Это
произошло потому, что от корневых серверов
нельзя требовать рекурсивных ответов - они
должны быть использованы только для того, чтобы
найти адреса к другим полномочным серверам. </small></p>

<p><small>Из строки 2 видно, что отклик пришел назад
без записи ресурса (RR) ответа, с пятью RR
полномочий и пятью RR дополнительной информации.
Знак минус, следующий за идентификатором 2,
означает, что флаг &quot;рекурсия возможна&quot; (RA) не
установлен - этот корневой сервер не ответит на <a NAME="t147012"></a>рекурсивный запрос, даже если мы его об
этом попросим. </small></p>

<p><small>Несмотря на то, что tcpdump не напечатал 10
записей ресурсов, которые были возвращены, мы
можем исполнить команду host, чтобы посмотреть, что
находится в кэше:</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>host -v ftp.uu.net</b><br>
Query about ftp.uu.net for record types A<br>
Trying ftp.uu.net ...<br>
Query done, 1 answer, status: no error<br>
The following answer is not authoritative:<br>
ftp.uu.net&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 19109&nbsp;&nbsp;&nbsp; IN
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.48.96.9<br>
Authoritative nameservers:<br>
UU.NET
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 170308
&nbsp;&nbsp; IN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NS.UU.NET<br>
UU.NET
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 170308
&nbsp;&nbsp; IN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NS
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UUNET.UU.NET<br>
UU.NET
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 170308
&nbsp;&nbsp; IN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NS
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UUCP-GW-1.PA.DEC.COM<br>
UU.NET
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 170308
&nbsp;&nbsp; IN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NS
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UUCP-GW-2.PA.DEC.COM<br>
UU.NET
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 170308
&nbsp;&nbsp; IN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NS.EU.NET<br>
Additional information:<br>
NS.UU.NET
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 170347
&nbsp;&nbsp; IN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 137.39.1.3<br>
UUNET.UU.NET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 170347
&nbsp;&nbsp; IN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.48.96.2<br>
UUCP-GW-1.PA.DEC.COM&nbsp;&nbsp; 170347&nbsp;&nbsp; IN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16.1.0.18<br>
UUCP-GW-2.PA.DEC.COM&nbsp;&nbsp; 170347&nbsp;&nbsp; IN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16.1.0.19<br>
NS.EU.NET
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 170347
&nbsp;&nbsp; IN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.16.202.11<br>
</p>


<p>&nbsp;</p>

<p><small><a NAME="t147013"></a>В этот раз мы указали опцию <a NAME="t147014"></a>-v, чтобы увидеть не только записи A.
Вывод показывает, что в домене uu.net присутствует
пять полномочных DNS серверов. Пять RR с
дополнительной информацией, которые были
возвращены корневым серверам, содержат IP адреса
этих пяти DNS серверов. Поэтому у нас нет
необходимости снова устанавливать контакт с
корневым сервером, чтобы найти адрес одного из
этих серверов. Это еще одно из расширений
реализации, сделанное в DNS. </small></p>

<p><small>Команда host определяет, что ответ не
авторитетный. Это произошло из-за того, что ответ
был получен из кэша нашего DNS сервера, а не в
результате контакта с полномочным сервером. </small></p>

<p><small>Вернемся к строке 3 на рисунке 14.14; сервер DNS
установил контакт с первым полномочным сервером
(ns.uu.net) с тем же самым вопросом: какой IP адрес
ftp.uu.net? На этот раз наш сервер установил флаг
&quot;рекурсия необходима&quot;. Ответ, возвращенный в
строке 4 - это отклик с одним ответом RR. </small></p>

<p><small>Затем мы снова исполнили команду host,
спрашивая о том же самом имени:</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>host ftp.uu.net</b><br>
ftp.uu.net&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.48.96.9<br>
</p>


<p>&nbsp;</p>

<p><small>Это как раз то, что мы и ожидали, потому что
ответ на команду host был получен из кэша сервера. </small></p>

<p><small>Мы исполнили команду host снова в поисках
адреса для ftp.ee.lbl.gov:</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>host ftp.ee.lbl.gov</b><br>
ftp.ee.lbl.gov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CNAME&nbsp;&nbsp;&nbsp;&nbsp; ee.lbl.gov<br>
ee.lbl.gov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 128.3.112.20<br>
</p>


<p>&nbsp;</p>

<p><small>На рисунке 14.15 показан вывод команды tcpdump.<a NAME="t147015"></a></small></p>

<p>&nbsp;</p>


<p><br>
1 18.664971 (17.6555)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.tuc.noao.edu.domain &gt;
c.nyser.net.domain: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4
A? ftp.ee.lbl.gov. (32)<br>
2 19.429412 ( 0.7644)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c.nyser.net.domain &gt;
sun.tuc.noao.edu.domain: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4
0/4/4 (188)<br>
<br>
3 19.432271 ( 0.0029)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.tuc.noao.edu.domain &gt;
ns1.lbl.gov.domain: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5+
A? ftp.ee.lbl.gov. (32)<br>
4 19.909242 ( 0.4770)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ns1.lbl.gov.domain &gt;
sun.tuc.noao.edu.domain: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5*
2/0/0 CNAME ee.lbl.gov. (72)<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 14.15 Вывод tcpdump для: host ftp.ee.lbl.gov.</small></p>

<p>&nbsp;</p>


<p>Из строки 1 видно, что
теперь наш сервер установил контакт с другим
корневым сервером (c.nyser.net). Сервер DNS обычно
циклически опрашивает различные серверы для
зоны, при этом накапливается информация о
времени отклика от того или иного сервера. И, в
конце концов, будет использован тот сервер, время
возврата от которого минимально.</p>


<p>&nbsp;</p>

<p><small>Так как наш сервер установил контакт с
корневым сервером, флаг &quot;рекурсия
необходима&quot; не установлен. Корневой сервер не
сбросил флаг &quot;рекурсия возможна&quot;, как мы
видели в строке 2 на рисунке 14.14. (Даже если так, DNS
сервер все равно не должен запрашивать корневой
сервер с помощью рекурсивного запроса.) </small></p>

<p><small>В строке 2 отклик приходит назад без ответа,
однако с четырьмя RR полномочий и четырьмя RR
дополнительной информации. Как мы можем
догадаться, четыре RR полномочий это имена DNS
серверов для ftp.ee.lbl.gov, а другие четыре RR содержат
IP адреса этих четырех серверов. </small></p>

<p><small>Строка 3 - это запрос на сервер ns1.lbl.gov (первый
из четырех DNS серверов, полученных в строке 2).
Флаг &quot;рекурсия необходима&quot; установлен. </small></p>

<p><small>Отклик в строке 4 отличается от предыдущих
откликов. Возвращено два RR ответа, и tcpdump
сообщает, что первый - это RR <a NAME="t147016"></a>CNAME.
Каноническое имя для ftp.ee.lbl.gov - это ee.lbl.gov. </small></p>

<p>&nbsp;</p>


<p>Это общепринятое
использование записи CNAME. FTP узел для LBL всегда
имеет имя, начинающееся с ftp, однако время от
времени он может перемещаться с одного хоста на
другой. Пользователям достаточно знать только
имя ftp.ee.lbl.gov, а DNS сама установит соответствие с
тем или иным хостом.</p>


<p>&nbsp;</p>

<p><small>Вспомните, что когда мы запускали host, он
печатал и CNAME и IP адрес, соответствующий
каноническому имени. Это потому, что отклик
(строка 4 на рисунке 14.15) содержит два RR ответа.
Первый это <a NAME="t147017"></a>CNAME, второй это запись A.
Если запись A не была возвращена вместе с CNAME, наш
сервер пошлет еще один запрос, спрашивая IP адрес
ee.lbl.gov. Это еще одна оптимизация реализации: CNAME и
запись A канонического имени возвращается в
одном отклике.</small></p>
<u><b>

<p><a NAME="t148000"></a>UDP или TCP </p>
</b></u>

<p><small>Мы уже упоминали, что заранее известные
номера портов для DNS серверов - UDP порт 53 и TCP порт
53. Это означает, что DNS поддерживает как UDP, так и
TCP. Однако все примеры, которые мы просмотрели с
использованием <a NAME="t148001"></a>tcpdump, использовали UDP.
Когда используется тот или иной протокол и
почему? </small></p>

<p><small><a NAME="t148002"></a>Когда разборщик выдает запрос и
возвращается отклик с установленным битом TC
(обрезано - truncated), это означает, что размер
отклика превысил 512 байт, только первые 512 байт
были возвращены серверу. Разборщик обычно
отправляет запрос снова, но уже с использованием
TCP. При этом возвращается больше, чем 512 байт.
(Вспомните описание максимального размера UDP
датаграммы в разделе <a HREF="tcp11.html#t11A000">&quot;Максимальный
размер UDP датаграммы&quot;</a> главы 11.) Так как TCP
делит поток данных на части, которые называются
сегментами, он может передать любое количество
пользовательских данных с использованием
нескольких сегментов. </small></p>

<p><small>Также, когда в домене включается вторичный
сервер DNS, он осуществляет передачу зоны с
первичного сервера домена. Мы также говорили, что
вторичный сервер регулярно запрашивает
первичный (обычно каждые три часа). При этом
определяется, не обновил ли первичный сервер
свою таблицу, и если да, то осуществляется
передача зоны. Передача зоны осуществляется с
использованием TCP, так как в этом случае
передается значительно больше данных, чем в
случае одного запроса или отклика. </small></p>

<p><small>Так как DNS в основном использует UDP, и
разборщик, и сервер DNS должны отработать свой
собственный <a NAME="t148003"></a>тайм-аут и осуществить
повторную передачу. В отличие от других
приложений Internet, которые используют UDP (TFTP, BOOTP и
SNMP) и которые функционируют обычно в локальных
сетях, DNS отправляет запросы и получает отклики
обычно по глобальным сетям. Процент потерянных
пакетов и разница в значениях времен возврата
обычно значительно выше в глобальных сетях,
нежели в локальных, при этом повышается важность
надежной передачи и четкости работы алгоритма
расчета тайм-аутов для клиентов DNS.</small></p>
<u><b>

<p><a NAME="t149000"></a>Еще один пример</p>
</b></u>

<p><small>Давайте рассмотрим еще один пример, который
описывает несколько функций DNS, о которых мы
рассказали раньше. Мы запустили клиента Rlogin,
подсоединившись к Rlogin серверу в каком-то
удаленном домене. На рисунке 14.16 показан обмен
пакетами.<a NAME="t149001"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t14_16_2.jpg" WIDTH="461" HEIGHT="224"></small></p>


<p ALIGN="CENTER"><small>Рисунок 14.16 Обмен пакетами при
старте Rlogin клиента и сервера.</small></p>

<p>&nbsp;</p>

<p><small>Было осуществлено 11 шагов, при этом заранее
никакой информации на клиенте или сервере
кэшировано не было:</small> 

<ol>
  <li><small>Клиент стартует и вызывает свою функцию
    разборщика, чтобы конвертировать имя хоста,
    которое мы ввели вместо IP адреса. Запрос типа A
    отправляется на корневой сервер.</small></li>
  <li><small>Ответ от корневого сервера содержит DNS
    сервера для домена в котором находится Rlogin
    сервер.</small></li>
  <li><small>Разборщик клиента повторно отправляет
    запрос типа A на DNS сервер. Этот запрос обычно
    имеет установленный флаг <a NAME="t149002"></a>&quot;рекурсия
    необходима&quot;.</small></li>
  <li><small>Приходит отклик с IP адресом хоста.</small></li>
  <li><small>Клиент Rlogin устанавливает TCP соединение с
    сервером Rlogin. (В <a HREF="tcp18.html">главе 18</a> этот
    процесс описывается более подробно.) TCP модули
    клиента и сервера обмениваются друг с другом
    тремя пакетами.</small></li>
  <li><small>Сервер Rlogin принимает соединение от клиента
    и вызывает свой разборщик, чтобы получить имя
    хоста клиента по IP адресу, который сервер получил
    от своего TCP. Это PTR запрос, выданный на корневой DNS
    сервер. Может быть, это не тот корневой сервер, к
    которому обратился клиент в шаге 1.</small></li>
  <li><small>Отклик корневого сервера содержит имя DNS
    сервера домена in-addr.arpa клиента.</small></li>
  <li><small>Разборщик сервера повторно отправляет PTR
    запрос к DNS серверу клиента. </small></li>
  <li><small>PTR отклик содержит <a NAME="t149003"></a>FQDN хоста
    клиента.</small></li>
  <li><small>Разборщик сервера отправляет запрос типа A к
    DNS серверу клиента, спрашивая IP адрес,
    соответствующий имени, возвращенному в
    предыдущем шаге. Это может быть сделано
    автоматически с использованием функции сервера <a NAME="t149004"></a>gethostbyaddr, как мы описали в разделе <a HREF="#t145000">&quot;Запросы указателя&quot;</a> этой главы,
    или сервер Rlogin осуществляет этот шаг
    самостоятельно. Также, DNS сервер клиента часто
    тот же самый, что и DNS сервер клиента in-addr.arpa,
    однако это необязательно.</small></li>
  <li><small>Отклик от DNS сервера клиента содержит запись
    A для хоста клиента. Сервер Rlogin сравнивает запись
    A с IP адресом клиента, потребовавшего открыть TCP
    соединение.</small></li>
</ol>

<p><small>Кэширование может уменьшить количество
пакетов, которыми произошел обмен в этом примере.</small></p>
<u><b>

<p><a NAME="t14A000"></a>Краткие выводы</p>
</b></u>

<p><small>DNS это одна из важнейших частей любого
хоста, подключенного к Internet, эта система также
широко используется в частных объединенных
сетях. Основа организации - иерархическое дерево,
которое формирует пространство имен DNS. </small></p>

<p><small>Приложения обращаются к разборщикам, чтобы
конвертировать имя хоста в IP адрес и наоборот.
Разборщики обращаются к локальным серверам DNS, а
они, свою очередь, могут обратиться к одному из <a NAME="t14A001"></a>корневых серверов или к другим
серверам, чтобы получить ответ на запрос. </small></p>

<p><small>Все DNS запросы и отклики имеют один и тот же
формат. Эти сообщения содержат записи ресурсов
(RR) вопросов и, возможно, ответов, RR полномочий и RR
дополнительной информации. Мы рассмотрели
множество примеров, в которых показана
конфигурация разборщика и некоторые принципы
организации DNS: указатели на имена доменов (чтобы
уменьшить размер сообщений), <a NAME="t14A002"></a>кэширование,
домен in-addr.arpa (поиск имени по заданному IP адресу) и
возвращаемые дополнительные RR (для того чтобы
запрашивающий не выдавал повторный запрос).</small></p>


<p>&nbsp;</p>
<i><b>

<p>Упражнения </b></i>

<ol>
  <li>Классифицируйте DNS разборщик и DNS
    сервер как с точки зрения модели
    &quot;клиент-сервер&quot;.</li>
  <li>Объясните назначение всех 75 байт в отклике на
    рисунке 14.12.</li>
  <li>В разделе <a HREF="tcp12.html#t123000">&quot;Примеры
    широковещательных запросов&quot;</a> главы 12 мы
    говорили, что приложения, которые понимают как IP
    адреса в виде десятичных цифр, разделенных
    точками, так и имена хостов, должны воспринимать
    сначала IP адреса, а затем имена хостов, в том
    случае, если получить IP адрес не удалось. Что
    произойдет, если порядок проверки будет изменен
    на обратный?</li>
  <li>Каждая UDP датаграмма имеет длину. Процессу,
    который получает UDP датаграмму, сообщается ее
    длина. Разборщик может выдать запрос с
    использованием TCP вместо UDP. TCP это поток байтов
    без каких-либо маркеров записи. Как приложение
    может узнать, сколько данных возвращено?
    Обратите внимание, что в DNS заголовке нет поля
    длины (рисунок 14.3). (Подсказка: обратитесь к RFC 1035.)</li>
  <li>Мы говорили, что сервер DNS должен знать IP адреса
    корневых серверов, и что эта информация доступна
    через анонимный FTP. К сожалению, не все системные
    администраторы обновляют свои DNS файлы, если
    изменяется список корневых серверов. (В списке
    корневых серверов иногда происходят изменения,
    однако нечасто.) Как Вы думаете, каким образом DNS
    обрабатывает подобную ситуацию?</li>
  <li>Получите файл, упомянутый в <a HREF="tcp01.html#t01H001">упражнении
    8</a> главы 1, и определите, кто несет
    ответственность за обслуживание <a NAME="t14A003"></a>корневых
    серверов DNS. Как часто обновляется информация на
    корневых серверах?</li>
  <li>В чем заключается проблема обслуживания кэша на
    сервере DNS и какую роль в этом играет разборщик?</li>
  <li>При обсуждении рисунка 14.10 мы сказали, что DNS
    сервер сортирует записи A таким образом, что
    адреса, принадлежащие сети, в которой находится
    запрашивающий хост, становятся первыми. Кто
    должен сортировать записи A: сервер DNS или
    разборщик?</li>
</ol>

<hr>

</body>
</html>

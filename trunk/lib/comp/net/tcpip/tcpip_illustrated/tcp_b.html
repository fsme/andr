<html>

<head>
<title>Компьютерные часы</title>

<meta http-equiv="Content-type" content="text/html; charset=koi8-r">
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>


<b>

<p><a NAME="t320000"></a>Приложение B Компьютерные часы</p>
</b>

<p><small>Так как в большинстве примеров в этом
тексте рассчитываются какие-либо временные
интервалы, нам необходимо более подробно описать
способы поддержки времени в современных Unix
системах. Все сказанное ниже имеет отношение к
системам, на которых использовались примеры в
этой книге. Более подробно о поддержке времени
можно прочитать в разделах 3.4 и 3.5 публикации [<a NAME="t320001"></a>Leffler et al. 1989]. </small></p>

<p><small>С определенной частотой генерируются
аппаратные прерывания от часов. В случае Sun SPARCs и
Intel 80386s эти прерывания возникают каждые 10
миллисекунд. </small></p>

<p><small>Необходимо отметить, что в большинстве
компьютеров используется нескомпенсированный
кварцевый генератор для генерации прерываний.
Как можно заметить из таблицы 7 RFC 1305 <a NAME="t320002"></a>[Mills
1992], не стоит беспокоиться о том, на сколько
отстает в день этот генератор. Очень немногие
компьютеры могут поддерживать точное время
(другими словами, прерывания не возникают точно
каждые 10 миллисекунд). Приближение 0,01% дает
ошибку примерно в 8,64 секунды в день. Чтобы
поддерживать более точное время, (1) нужно
использовать лучший генератор (кварц), (2) можно
использовать внешний источник времени с
повышенной точностью (например, источник
времени, предоставляемый Global Positioning Satellites) или (3)
получить доступ по Internet к системам с более
точными часами. Последнее решается с помощью
протокола Network Time Protocol, как описано в RFC 1305, но это
выходит за рамки обсуждения нашей книги. </small></p>

<p><small>Еще один хорошо известный источник ошибок
во времени в Unix системах заключается в том, что
прерывания, которые появляются каждые 10
миллисекунд, всего лишь заставляют ядро
увеличивать переменную, которая отслеживает
время. Если ядро потеряло прерывание (например,
оно было слишком занято в период между двумя
соседними 10-миллисекундными прерываниями), часы
отстанут на 10 миллисекунд. Подобная потеря
прерываний часто приводит к отставанию часов в
Unix системах. </small></p>

<p><small>Даже если прерывания часов происходят
примерно каждые 10 миллисекунд, более новые
системы, такие как SPARCs, предоставляют более
высокую точность часов. При работе с NIT драйвером
(описанным в <a HREF="tcp_a.html">приложении А</a>), <a NAME="t320003"></a>tcpdump имеет доступ к этому таймеру с
повышенным разрешением. В SPARC этот таймер
предоставляет микросекундное разрешение.
Пользовательские процессы могут получить доступ
к этому таймеру с повышенным разрешением через
функцию <a NAME="t320004"></a>gettimeofday(2). </small></p>

<p><small>Автор провел следующий эксперимент. Была
запущена программа, которая вызывает функцию
gettimeofday циклически 10000 раз, при этом каждый раз
возвращенное значение сохранялось в массиве. В
конце цикла были напечатаны 9999 отрезков времени.
Для SPARC ELC величины отрезков времени показаны на
рисунке В.1.<a NAME="t320005"></a></small></p>

<p><small>&nbsp;</small></p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="307">
  <tr>
    <td WIDTH="52%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Микросекунды</small></td>
    <td WIDTH="48%" VALIGN="TOP" BGCOLOR=">
<HR><H3>Передача прервана!</H3>
GN="CENTER"><small>Счетчик</small></td>
  </tr>
  <tr>
    <td WIDTH="52%" VALIGN="TOP"><p ALIGN="CENTER"><small>36</small></td>
    <td WIDTH="48%" VALIGN="TOP"><p ALIGN="CENTER"><small>4914</small></td>
  </tr>
  <tr>
    <td WIDTH="52%" VALIGN="TOP"><p ALIGN="CENTER"><small>37</small></td>
    <td WIDTH="48%" VALIGN="TOP"><p ALIGN="CENTER"><small>4831</small></td>
  </tr>
  <tr>
    <td WIDTH="52%" VALIGN="TOP"><p ALIGN="CENTER"><small>38</small></td>
    <td WIDTH="48%" VALIGN="TOP"><p ALIGN="CENTER"><small>167</small></td>
  </tr>
  <tr>
    <td WIDTH="52%" VALIGN="TOP"><p ALIGN="CENTER"><small>39</small></td>
    <td WIDTH="48%" VALIGN="TOP"><p ALIGN="CENTER"><small>8</small></td>
  </tr>
  <tr>
    <td WIDTH="52%" VALIGN="TOP"><p ALIGN="CENTER"><small>другие</small></td>
    <td WIDTH="48%" VALIGN="TOP"><p ALIGN="CENTER"><small>79</small></td>
  </tr>
</table>


<p><small>Рисунок В.1 Распределение времени,
необходимое для вызова gettimeofday 10000 раз в SPARC ELC.</small></p>

<p><small>&nbsp;</small></p>

<p><small>Полное время, необходимое для запуска
программы, составило 0,38 секунды, при практически
свободной системе. Отсюда можно сделать вывод,
что процессу потребовалось для вызова gettimeofday
примерно 37 микросекунд. Так как ELC имеет скорость
примерно 21 MIPS (миллион инструкций в секунду), 37
микросекунд соответствуют примерно 800
инструкциям. Ядро принимает системный вызов от
пользовательского процесса, исполняет системный
вызов, копирует назад 8 байт в качестве
результата и возвращает управление
пользовательскому процессу. (Скорость MIPS
достаточно спорная величина, поэтому на
современных системах сложно оценить время
исполнения инструкций. Все что мы попробуем
сделать, это получить примерное представление и
увидеть, могут ли полученные значения иметь
какой-то определенный смысл.) </small></p>

<p><small>Из этого простого эксперимента мы можем
сказать, что значения, возвращенные gettimeofday,
содержат микросекундную точность. </small></p>

<p><small>Если мы запустим подобный тест в SVR4/386,
результаты будут отличны от приведенных выше.
Это объясняется тем, что большинство 386 Unix систем,
таких как <a NAME="t320006"></a>SVR4, имеют только
10-миллисекундные прерывания часов и даже не
стараются предоставить более высокое разрешение
часов. На рисунке В.2 показано распределение 9999
отрезков времени для компьютера 25Мгц 80386,
работающего под управлением операционной
системы SVR4.<a NAME="t320007"></a></small></p>

<p><small>&nbsp;</small></p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="274">
  <tr>
    <td WIDTH="57%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Микросекунды</small></td>
    <td WIDTH="43%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Счетчик</small></td>
  </tr>
  <tr>
    <td WIDTH="57%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
    <td WIDTH="43%" VALIGN="TOP"><p ALIGN="CENTER"><small>9871</small></td>
  </tr>
  <tr>
    <td WIDTH="57%" VALIGN="TOP"><p ALIGN="CENTER"><small>10000</small></td>
    <td WIDTH="43%" VALIGN="TOP"><p ALIGN="CENTER"><small>128</small></td>
  </tr>
</table>


<p><small>Рисунок В.2 Время, необходимое для вызова
gettimeofday 10000 раз в случае SVR4/386.</small></p>

<p><small>&nbsp;</small></p>

<p><small>Эти значения менее точны, разница во
времени обычно меньше чем 10 миллисекунд, что
воспринимается как 0. Практически все, что мы
можем сделать на подобных системах, это
рассчитать время часов на свободной машине и
поделить его на количество циклов. При этом мы
получим верхний предел, так как сюда входит
время, необходимое, чтобы 9999 раз вызвать printf и
записать результаты в файл. (В случае SPARC, рисунок
В.1, промежутки времени не включают в себя время,
необходимое для работы функции printf, так как все
10000 значений были сначала получены, а затем был
напечатан результат.) Под управлением SVR4 время
часов составило 3,15 секунды, что дает примерно 315
микросекунд на один системный вызов. Время
системного вызова в 8,5 раз медленнее, чем в SPARC,
что выглядит похожим на правду. </small></p>

<p><small><a NAME="t320008"></a>BSD/386 Version 1.0 предоставляет
микросекундную точность, такую же как SPARC. Она
читает регистр часов 8253 и рассчитывает
количество микросекунд, прошедшее с последнего
тика часов. Это разрешение доступно для
процессов вызывающих gettimeofday и для модулей ядра,
таких как пакетный фильтр BSD. </small></p>

<p><small>В случае <a NAME="t320009"></a>tcpdump эти цифры
означают, что мы можем доверять миллисекундным
значениям и значениям, равным частям
миллисекунд, которые напечатаны в системах SPARC и
BSD/386, однако значения, напечатанные tcpdump под
управлением SVR4/386, всегда будут кратны 10
миллисекундам. Для других программ, которые
печатают время возврата, таких как <a NAME="t320010"></a>ping
(<a HREF="tcp07.htm">глава 7</a>) и <a NAME="t320011"></a>traceroute (<a HREF="tcp08.html">глава 8</a>), в случае SPARC и BSD/386 систем мы
можем верить миллисекундным значениям вывода,
однако значения, напечатанные под управлением
SVR4/386, будут всегда кратны 10. Чтобы оценить время
возврата ping в локальной сети, что мы показывали в <a HREF="tcp07.html">главе 7</a>, равное примерно 3
миллисекундам, требуется запустить ping на SPARC или
BSD/386.</small></p>

<p><small>&nbsp;</small></p>


<p>В некоторых примерах
запущенных под BSD/386 Version 0.9.4 получена
10-миллисекундная точность часов (как под SVR4).
Когда мы показывали вывод команды tcpdump с этих
систем, то приводили только две цифры справа от
десятичной точки, в соответствии с
предоставляемой точностью часов.</p>
<hr>
</body>
</html>

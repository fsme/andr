<html>

<head>
<title>Установление и разрыв TCP соединения</title>

<meta http-equiv="Content-type" content="text/html; charset=koi8-r">
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>




<p><a NAME="t180000"></a>Глава 18 Установление и разрыв TCP
соединения</p>
<u>

<p><b><a NAME="t181000"></a>Введение</p>
</b></u>

<p><small>TCP это протокол, <a NAME="t181001"></a>ориентированный
на соединение. Перед тем как какая-либо сторона
может послать данные другой, между ними должно
быть установлено соединение. В этой главе мы
подробно рассмотрим, как устанавливается TCP
соединение и как оно разрывается. </small></p>

<p><small>Так как для работы TCP необходимо установить
соединение между двумя концами он отличается от
протоколов <a NAME="t181002"></a>без соединения, таких как
UDP. В <a HREF="tcp11.html">главе 11</a> мы видели, что при
использовании UDP каждая сторона просто отсылает
датаграммы другой, не установив перед этим
соединения. </small></p>
<u><b>

<p><a NAME="t182000"></a>Установление и разрыв соединения</p>
</b></u>

<p><small>Для того чтобы посмотреть, что происходит
при установлении и разрыве TCP соединения, мы
исполнили на системе svr4 следующую команду: </small></p>

<p>&nbsp;</p>


<p><br>
svr4 % <b>telnet bsdi discard</b><br>
Trying 192.82.148.3 ...<br>
Connected to bsdi.<br>
Escape character is '^]'.<br>
^<b>] </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим
Control, правую квадратную скобку,<br>
telnet&gt; <b>quit </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; чтобы
Telnet клиент разорвал соединение<br>
Connection closed.<br>
</p>


<p>&nbsp;</p>

<p><small>Команда <a NAME="t182003"></a>telnet устанавливает TCP
соединение с хостом bsdi на порт, соответствующий
discard сервису (глава 1, раздел <a HREF="tcp01.html#t01C000">&quot;Стандартные
простые сервисы&quot;</a>). Это как раз тот тип
сервиса, который нам необходим, чтобы посмотреть,
что происходит при установлении и разрыве
соединения, но без обмена данными.</small></p>
<i><b>

<p>Вывод tcpdump</p>
</b></i>

<p><small>На рисунке 18.1 показан вывод <a NAME="t182004"></a>tcpdump
для сегментов, сгенерированных этой командой.<a NAME="t182002"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; svr4.1037
&gt; bsdi.discard: S 1415531521:1415531521 (0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; win
4096 &lt;mss 1024&gt;<br>
2&nbsp; 0.002402 (0.0024)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.discard &gt; svr4.1037: S
1823083521:1823083521 (0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ack
1415531522 win 4096<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;mss
1024&gt;<br>
3&nbsp; 0.007224 (0.0048)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; svr4.1037
&gt; bsdi.discard: . ack 1823083522 win 4096<br>
4&nbsp; 4.155441 (4.1482)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; svr4.1037
&gt; bsdi.discard: F 1415531522:1415531522 (0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ack
1823083522 win 4096<br>
5&nbsp; 4.156747 (0.0013)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.discard &gt; svr4.1037: . ack
1415531523 win 4096<br>
6&nbsp; 4.158144 (0.0014)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.discard &gt; svr4.1037: F
1823083522:1823083522 (0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ack
1415531523 win 4096<br>
7&nbsp; 4.180662 (0.0225)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; svr4.1037
&gt; bsdi.discard: . ack 1823083523 win 4096<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 18.1 Вывод tcpdump для установления и
разрыва TCP соединения.</small></p>

<p>&nbsp;</p>

<p><small>Эти семь TCP сегментов содержат только TCP
заголовки. Обмен данными не осуществлялся. </small></p>

<p><small>Для TCP сегментов каждая выходная строка
начинается с</small></p>

<p>&nbsp;</p>

<p><small><i>source &gt; destination: flags (источник &gt; назначение:
флаги)</i></small></p>

<p>&nbsp;</p>

<p><small>где флаги (flags) представляют собой четыре из
шести флаговых битов TCP заголовка (<a HREF="tcp17.html#t172001">рисунок 17.2</a>). На рисунке 18.2
показаны пять различных символов, которые
соответствуют флагам и могут появиться в выводе.<a NAME="t182001"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="718">
  <tr>
    <td WIDTH="9%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>флаг</small></td>
    <td WIDTH="20%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>3-символьное
    сокращение</small></td>
    <td WIDTH="71%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Описание</small></td>
  </tr>
  <tr>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>S</small></td>
    <td WIDTH="20%" VALIGN="TOP"><p ALIGN="CENTER"><small>SYN</small></td>
    <td WIDTH="71%" VALIGN="TOP"><small>синхронизирующие
    номера последовательности</small></td>
  </tr>
  <tr>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>F</small></td>
    <td WIDTH="20%" VALIGN="TOP"><p ALIGN="CENTER"><small>FIN</small></td>
    <td WIDTH="71%" VALIGN="TOP"><small>отправитель
    закончил передачу данных</small></td>
  </tr>
  <tr>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>R</small></td>
    <td WIDTH="20%" VALIGN="TOP"><p ALIGN="CENTER"><small>RST</small></td>
    <td WIDTH="71%" VALIGN="TOP"><small>сброс соединения</small></td>
  </tr>
  <tr>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>P</small></td>
    <td WIDTH="20%" VALIGN="TOP"><p ALIGN="CENTER"><small>PSH</small></td>
    <td WIDTH="71%" VALIGN="TOP"><small>отправка данных
    принимающему процессу настолько быстро,
    насколько это возможно</small></td>
  </tr>
  <tr>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>.</small></td>
    <td WIDTH="20%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="71%" VALIGN="TOP"><small>ни один из четырех
    флагов не установлен</small></td>
  </tr>
</table>


<p><small>Рисунок 18.2 Символы флагов, выведенные
командой tcpdump для флаговых битов в TCP заголовке.</small></p>

<p>&nbsp;</p>

<p><small>В данном примере мы видим флаги S, F и точку.
Еще два флага (R и P) появятся позже. Два других
бита флагов в TCP заголовке - ACK и URG - напечатаны
командой tcpdump. </small></p>

<p><small>В одном сегменте может присутствовать
больше чем один из четырех флаговых битов,
показанных на рисунке 18.2, однако, обычно взведен
бывает только один флаг.</small></p>

<p>&nbsp;</p>


<p>RFC 1025 [<a NAME="t182005"></a>Postel
1987] называет сегмент, в котором максимальная
комбинация всех доступных флаговых битов
взведена одновременно (SYN, URG, PSH, FIN и 1 байт данных)
пакетом <a NAME="t182006"></a>Камикадзе (в английском
языке существует еще несколько определений
подобного пакета, а именно - &quot;грязный пакет&quot;,
&quot;пакет Новогодней елки&quot; и т.п.).</p>


<p>&nbsp;</p>

<p><small>В строке 1 поле 1415531521:1415531521 (0) означает, что
номер последовательности пакета равен 1415531521, а
количество байт данных в сегменте равно 0.
Команда <a NAME="t182007"></a>tcpdump печатает начальный
номер последовательности, двоеточие,
предполагаемый заключительный номер
последовательности и затем в скобках количество
байт данных. При этом существует возможность
просмотреть предполагаемый окончательный номер
последовательности, когда количество байтов
больше чем 0. В поле появляется (1), если сегмент
содержит один или несколько байт
пользовательских данных, или (2) если взведены
флаг SYN, FIN или RST. В строках 1, 2, 4 и 6 на рисунке 18.1
это поле появляется, потому что взведены
флаговые биты - обмен какими-либо данными в этом
примере не производился.</small></p>

<p><small>В строке 2 поле ack 1415531522 содержит номер
подтверждения. Оно печатается только в том
случае, если флаг ACK взведен. Поле win 4096 в каждой
строке вывода показывает размер окна, который
был объявлен отправителем. В этом примере, где не
осуществлялся обмен данными, размер окна
оставался неизменным и использовалась величина
по умолчанию - 4096. (Мы рассмотрим размер окна TCP в
разделе <a HREF="tcp20.html#t204000">&quot;Размер окна&quot;</a>
главы 20.)</small></p>

<p><small>И последнее поле в выводе на рисунке 18.1, &lt;mss
1024&gt; показывает максимальный размер сегмента (<a NAME="t182008"></a>MSS - maximum segment size) , опция, которую
устанавливает отправитель. Отправитель не хочет
получать TCP сегменты больше чем это значение. Это
делается обычно для того, чтобы избежать
фрагментации (глава 11, раздел <a HREF="tcp11.html#t115000">&quot;Фрагментация
IP&quot;</a>). Мы рассмотрим максимальный размер
сегмента в разделе <a HREF="#t184000">&quot;Максимальный
размер сегмента&quot;</a> этой главы, а формат
различных опций TCP покажем в разделе <a HREF="#t18A000">&quot;Опции
TCP&quot;</a> этой главы.</small></p>
<i><b>

<p>Временные диаграммы</p>
</b></i>

<p><small>На рисунке 18.3 показана временная диаграмма
соответствующая этому обмену пакетами. (Мы
описали некоторые основные характеристики
временных диаграмм, когда первый раз обратились
к <a HREF="tcp06.html#t065002">рисунку 6.11</a>.) На этом рисунке
показано, какая сторона отправляет пакеты. Также
приведен вывод команды tcpdump (на печать выводилось
SYN вместо S). В этой временной диаграмме удалено
значение размера окна, так как это не существенно
для нашего обсуждения.</small></p>
<i><b>

<p>Протокол установления соединения</p>
</b></i>

<p><small>А теперь давайте вернемся к деталям TCP
протокола, которые показаны на рисунке 18.3. Чтобы
установить TCP соединение, необходимо:</small> 

<ol>
  <li><small>Запрашивающая сторона (которая, как правило,
    называется клиент) отправляет SYN сегмент,
    указывая номер порта сервера, к которому клиент
    хочет подсоединиться, и исходный номер
    последовательности клиента (в данном примере <a NAME="t182009"></a>ISN, 1415531521). Это сегмент номер 1.</small></li>
  <li><small>Сервер отвечает своим сегментом SYN,
    содержащим исходный номер последовательности
    сервера (сегмент 2). Сервер также подтверждает
    приход SYN клиента с использованием ACK (ISN клиента
    плюс один). На SYN используется один номер
    последовательности.</small></li>
  <li><small>Клиент должен подтвердить приход SYN от
    сервера с использованием ACK (ISN сервера плюс один,
    сегмент 3).</small></li>
</ol>

<p><small>Этих трех сегментов достаточно для
установления соединения. Часто это называется <a NAME="t182010"></a>трехразовым рукопожатием (three-way handshake).<a NAME="t182011"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t18_3_20.jpg" WIDTH="491" HEIGHT="437"></small></p>


<p ALIGN="CENTER"><small>Рисунок 18.3 Временная диаграмма
установления и разрыва соединения.</small></p>

<p>&nbsp;</p>

<p><small>Считается, что сторона, которая посылает
первый SYN, активизирует соединение (<a NAME="t182012"></a>активное
открытие). Другая сторона, которая получает
первый SYN и отправляет следующий SYN, принимает
пассивное участие в открытии соединения (<a NAME="t182013"></a>пассивное открытие). (В разделе <a HREF="#t188000">&quot;Одновременное открытие&quot;</a> этой
главы мы подробно опишем процедуру открытия
соединения, где обе стороны считаются активными
при установлении соединения.) </small></p>

<p><small>Когда каждая сторона отправила свой SYN
чтобы установить соединение, она выбирает
исходный номер последовательности (ISN) для этого
соединения. ISN должен меняться каждый раз,
поэтому каждое соединение имеет свой, отличный
от других ISN. RFC 793 [<a NAME="t182014"></a>Postel 1981c] указывает,
что ISN является 32-битным счетчиком, который
увеличивается на единицу каждые 4 микросекунды.
Благодаря номерам последовательностей, пакеты,
задержавшиеся в сети и доставленные позже, не
воспринимаются как часть существующего
соединения.</small></p>

<p>&nbsp;</p>


<p>Как выбирается номер
последовательности? В <a NAME="t182015"></a>4.4BSD (и в
большинстве Berkeley реализаций) при инициализации
системы исходный номер последовательности
устанавливается в 1. Подобная практика
осуждается требованием к хостам <a NAME="t182016"></a>Host
Requirements RFC. Затем эта величина увеличивается на 64000
каждые полсекунды и возвращается в значение 0
через каждые 9,5 часов. (Это соответствует
счетчику, который увеличивается на единицу
каждые 8 микросекунд, а не каждые 4 микросекунды.)
Кроме того, каждый раз, когда устанавливается
соединение, эта переменная увеличивается на 64000.</p>


<p>&nbsp;</p>

<p><small>Промежуток в 4,1 секунды между сегментами 3 и
4 соответствует времени между установлением
соединения и вводом команды quit для <a NAME="t182017"></a>telnet,
чтобы разорвать соединение.</small></p>
<i><b>

<p>Протокол разрыва соединения</p>
</b></i>

<p><small>Для того чтобы установить соединение,
необходимо 3 сегмента, а для того чтобы разорвать
- 4. Это объясняется тем, что TCP соединение может
быть в <a NAME="t182018"></a>наполовину закрытом
состоянии. Так как TCP соединение <a NAME="t182019"></a>полнодуплексное
(данные могут передвигаться в каждом направлении
независимо от другого направления), каждое
направление должно быть закрыто независимо от
другого. Правило заключается в том, что каждая
сторона должна послать FIN, когда передача данных
завершена. Когда TCP принимает FIN, он должен
уведомить приложение, что удаленная сторона
разрывает соединение и прекращает передачу
данных в этом направлении. FIN обычно отправляется
в результате того, что приложение было закрыто. </small></p>

<p><small>Получение FIN означает только, что в этом
направлении прекращается движение потока
данных. TCP, получивший FIN, может все еще посылать
данные. Несмотря на то, что приложение все еще
может посылать данные при наполовину закрытом TCP
соединении, на практике только некоторые (совсем
немного) TCP приложения используют это. Обычным
является тот сценарий, который показан на
рисунке 18.3. Мы опишем наполовину закрытый режим
более подробно в разделе <a HREF="#t185000">&quot;Наполовину
закрытый TCP&quot;</a> этой главы. </small></p>

<p><small>Можно сказать, что та сторона, которая
первой закрывает соединение (отправляет первый
FIN), осуществляет <a NAME="t182020"></a>активное закрытие, а
другая сторона (которая приняла этот FIN)
осуществляет <a NAME="t182021"></a>пассивное закрытие.
Обычно, одна сторона осуществляет активное
закрытие, а другая пассивное, однако в разделе <a HREF="#t189000">&quot;Одновременное закрытие&quot;</a> этой
главы мы увидим, что обе стороны могут
осуществить активное закрытие. </small></p>

<p><small>Сегмент номер 4 на рисунке 18.3 приводит к
закрытию соединения и посылается, когда Telnet
клиент прекращает работу. Это происходит, когда
мы вводим quit. При этом TCP клиент вынужден послать
FIN, закрывая поток данных от клиента к серверу. </small></p>

<p><small>Когда сервер получает FIN, он отправляет
назад ACK с принятым номером последовательности
плюс один (сегмент 5). На FIN тратится один номер
последовательности, так же как на SYN. В этот
момент TCP сервер также доставляет приложению
признак конца файла (end-of-file) (чтобы выключить
сервер). Затем сервер закрывает свое соединение,
что заставляет его TCP послать FIN (сегмент 6),
который клиент должен подтвердить (ACK), увеличив
на единицу номер принятой последовательности
(сегмент 7). </small></p>

<p><small>На рисунке 18.4 показан типичный обмен
сегментами при закрытии соединения. Номера
последовательности опушены. На этом рисунке FIN
посылаются из-за того, что приложения закрывают
свои соединения, тогда как ACK для этих FIN
генерируется автоматически программным
обеспечением TCP. </small></p>

<p><small>Соединения обычно устанавливаются
клиентом, то есть первый SYN двигается от клиента к
серверу. Однако любая сторона может активно
закрыть соединение (послать первый FIN). Часто,
однако, именно клиент определяет, когда
соединение должно быть разорвано, так как
процесс клиента в основном управляется
пользователем, который вводит что-нибудь
подобное &quot;quit&quot;, чтобы закрыть соединение. На
рисунке 18.4 мы можем поменять местами метки,
приведенные наверху рисунка, назвав левую
сторону сервером, а правую сторону клиентом.
Однако даже в этом случае все будет работать
именно так, как показано на рисунке. (Первый
пример в разделе <a HREF="tcp14.html#t144000">&quot;Простой
пример&quot;</a> главы 14, например, показывал, как
сервер времени закрывает соединение.)<a NAME="t182022"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t18_4_20.jpg" WIDTH="498" HEIGHT="247"></small></p>


<p ALIGN="CENTER"><small>Рисунок 18.4 Обычный обмен
сегментами при закрытии соединения.</small></p>
<i><b>

<p>Обычный вывод tcpdump</p>
</b></i>

<p><small>Так как задача отсортировать огромное
количество номеров последовательности довольно
сложна, в выводе программы tcpdump содержатся полные
номера последовательности только для SYN
сегментов, а все следующие номера
последовательностей показаны как относительное
смещение от исходных номеров
последовательности. (Для того чтобы получить
вывод, приведенный на рисунке 18.1, мы должны были
указать опцию <a NAME="t182023"></a>-S.) Обычный вывод <a NAME="t182024"></a>tcpdump, соответствующий рисунку 18.1,
показан на рисунке 18.5.<a NAME="t182025"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; svr4.1037
&gt; bsdi.discard: S 1415531521:1415531521(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; win
4096 &lt;mss 1024&gt;<br>
2&nbsp; 0.002402 (0.0024)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.discard &gt; svr4.1037: S
1823083521:1823083521(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ack
1415531522<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; win
4096 &lt;mss 1024&gt;<br>
3&nbsp; 0.007224 (0.0048)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; svr4.1037 &gt; bsdi.discard: . ack
1 win 4096<br>
4&nbsp; 4.155441 (4.1482)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; svr4.1037 &gt; bsdi.discard: F 1:1
(0) ack 1 win 4096<br>
5&nbsp; 4.156747 (0.0013)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.discard &gt; svr4.1037: . ack
2 win 4096<br>
6&nbsp; 4.158144 (0.0014)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.discard &gt; svr4.1037: F 1:1
(0) ack 2 win 4096<br>
7&nbsp; 4.180662 (0.0225)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; svr4.1037 &gt; bsdi.discard: . ack
2 win 4096<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 18.5 Обычный вывод команды tcpdump,
соответствующий установлению и разрыву
соединения.</small></p>

<p>&nbsp;</p>

<p><small>Если у нас не будет возникать необходимости
показывать полные номера последовательности, мы
будем использовать эту форму вывода во всех
следующих примерах.</small></p>
<u><b>

<p><a NAME="t183000"></a>Тайм-аут при установлении
соединения</p>
</b></u>

<p><small>Существует несколько причин, по которым не
может быть установлено соединение. Например,
хост (сервер) выключен. Чтобы сымитировать
подобную ситуацию, мы исполнили команду <a NAME="t183003"></a>telnet, после того как отсоединили Ethernet
кабель от сервера. На рисунке 18.6 показан вывод
команды tcpdump.<a NAME="t183002"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp;&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1024
&gt; svr4.discard: S 291008001:291008001(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; win
4096 &lt;mss 1024&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [tos
0x10]<br>
2&nbsp;&nbsp; 5.814797 ( 5.8148)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1024 &gt; svr4.discard: S
291008001:291008001(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; win
4096 &lt;mss 1024&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [tos
0x10]<br>
3&nbsp; 29.815436 (24.0006)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1024 &gt; svr4.discard: S
291008001:291008001(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; win
4096 &lt;mss 1024&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [tos
0x10]<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 18.6 Вывод команды tcpdump для
установления соединения, которое было
прекращено по тайм-ауту.</small></p>

<p>&nbsp;</p>

<p><small>В этом выводе необходимо обратить внимание
на то, как часто TCP клиент отправляет SYN, стараясь
установить соединение. Второй сегмент
посылается через 5,8 секунды после первого, а
третий посылается через 24 секунды после второго.</small></p>

<p>&nbsp;</p>


<p>Необходимо заметить,
что этот пример был запущен примерно через 38
минут после того, как клиент был перезагружен.
Поэтому соответствующий исходный номер
последовательности равен 291008001 (примерно
38х60х6400х2). В начале главы мы сказали, что типичные
системы Berkeley устанавливают исходный номер
последовательности в 1, а затем увеличивают его
на 64000 каждые полсекунды.</p>

<p>Также необходимо отметить, что это
первое TCP соединение с того момента, как система
была перезагружена, так как номер порта клиента
равен 1024.</p>


<p>&nbsp;</p>

<p><small>Однако на рисунке 18.6 не показано, сколько
времени TCP клиент осуществлял повторные
передачи, перед тем как отказаться от своей
попытки. Для того чтобы посмотреть это временные
значения, мы должны исполнить команду telnet
следующим образом: </small></p>

<p>&nbsp;</p>


<p>bsdi % <b>date ; telnet svr4 discard ; date<br>
</b>Thu Sep 24 16:24:11 MST 1992<br>
Trying 192.82.148.2...<br>
telnet: Unable to connect to remote host: Connection timed out<br>
Thu Sep 24 16:25:27 MST 1992&nbsp;</p>

<p>&nbsp;</p>

<p><small>Время составляет 76 секунд. Большинство
систем Berkeley устанавливают предел времени в 75
секунд, за это время должно быть установлено
новое соединение. В разделе <a HREF="tcp21.html#t214000">&quot;Пример
RTT&quot;</a> главы 21 мы увидим, что третий пакет,
посланный клиентом, будет отброшен по тайм-ауту
примерно в 16:25:29, то есть через 48 секунд после того
как он был отправлен, при этом клиент не
прекратит свои попытки через 75 секунд.</small></p>
<i><b>

<p>Первый тайм-аут</p>
</b></i>

<p><small>На рисунке 18.6 следует обратить внимание на
то, что первый тайм-аут, 5,8 секунды, близок к 6
секундам, однако не равен 6 секундам, тогда как
второй тайм-аут практически точно равен 24
секундам. Было исполнено еще десять подобных
тестов, причем в каждом из них значение первого
тайм-аута колебалось в диапазоне от 5,59 секунды до
5,93 секунды. Второй тайм-аут, однако, всегда был 24,00
секунды. </small></p>

<p><small>Это объясняется тем, что BSD реализации TCP
запускают таймер каждые 500 миллисекунд. Этот
500-миллисекундный таймер используется для
различных TCP тайм-аутов, все они будут описаны в
следующих главах. Когда мы вводим команду telnet,
устанавливается исходный 6-секундный таймер (12
тиков часов), однако он может истечь в любом месте
между 5,5 и 6 секундами. На рисунке 18.7 показано как
это происходит.<a NAME="t183001"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t18_7_20.jpg" WIDTH="536" HEIGHT="110"></small></p>


<p ALIGN="CENTER"><small>Рисунок 18.7 500-миллисекундный таймер
TCP.</small></p>

<p>&nbsp;</p>

<p><small>Так как таймер установлен в 12 тиков, первое
уменьшение таймера может произойти между 0 и 500
миллисекунд после его установки. С этого момента
таймер уменьшается примерно каждые 500
миллисекунд, однако первый период времени может
быть разным. (Мы используем слово &quot;примерно&quot;,
потому что время, когда TCP получает управление
каждые 500 миллисекунд, примерное, так как может
пройти другое прерывание, которое будет
обрабатываться ядром.) </small></p>

<p><small>Когда этот 6-секундный таймер истечет на
тике помеченном 0 на рисунке 18.7, таймер
переустанавливается в 24 секунды (48 тиков). Этот
следующий таймер будет равен 24 секундам, так как
он был установлен в тот момент времени, когда
500-миллисекундный таймер TCP был вызван ядром, а не
пользователем.</small></p>
<i><b>

<p>Поле типа сервиса</p>
</b></i>

<p><small>На рисунке 18.6 мы видим выражение [tos 0x10]. Это
поле типа сервиса (<a NAME="t183004"></a>TOS - type-of-service) в IP
датаграмме (<a HREF="tcp03.html#t032002">рисунок 3.2</a>). Telnet
клиент в <a NAME="t183005"></a>BSD/386 устанавливает это поле
таким образом, чтобы получить минимальную
задержку.</small></p>
<u><b>

<p><a NAME="t184000"></a>Максимальный размер сегмента</p>
</b></u>

<p><small>Максимальный размер сегмента (MSS) это самая
большая порция данных, которую TCP пошлет на
удаленный конец. Когда соединение
устанавливается, каждая сторона может объявить
свой MSS. Значения, которые мы видели, были 1024. IP
датаграмма, которая получится в результате,
обычно на 40 байт больше: 20 байт отводится под TCP
заголовок и 20 байт под IP заголовок. </small></p>

<p><small>В некоторых публикациях говорится, что эта
опция устанавливается &quot;по договоренности&quot;.
В действительности, договоренность в данном
случае не используется. Когда соединение
устанавливается, каждая сторона объявляет MSS,
которой она собирается принимать. (<a NAME="t184001"></a>Опция
MSS может быть использована только в SYN сегменте.)
Если одна сторона не принимает опцию MSS от другой
стороны, используется размер по умолчанию в 536
байт. (В этом случае, при 20-байтном IP заголовке и
20-байтном TCP заголовке, размер IP датаграммы будет
составлять 576 байт.) </small></p>

<p><small>В общем случае, чем больше MSS тем лучше, до
тех пор пока не происходит фрагментация. (Это не
всегда верно. Обратитесь к <a HREF="tcp24.html#t242001">рисунку
24.3</a> и <a HREF="tcp24.html#t242002">рисунку 24.4</a>, чтобы в этом
убедиться.) Большие размеры сегмента позволяют
послать больше данных в каждом сегменте, что
уменьшает относительную стоимость IP и TCP
заголовков. Когда TCP отправляет SYN сегмент, либо
когда локальное приложение хочет установить
соединение, или когда принят запрос на
соединение от удаленного хоста, может быть
установлено значение MSS равное MTU исходящего
интерфейса минус размер фиксированных TCP и IP
заголовков. Для <a NAME="t184002"></a>Ethernet MSS может
достигать 1460 байт. При использовании
инкапсуляции <a NAME="t184003"></a>IEEE 802.3 (глава 2, раздел <a HREF="tcp02.html#t022000">&quot;Ethernet и IEEE 802 инкапсуляция&quot;</a>)
MSS может быть до 1452 байт. </small></p>

<p><small>Значение 1024, которое мы видим в этой главе,
соответствует соединениям, в которых участвуют <a NAME="t184004"></a>BSD/386 и <a NAME="t184005"></a>SVR4, потому что
большинство BSD реализаций требует, чтобы MSS было
кратно 512. Другие системы, такие как <a NAME="t184006"></a>SunOS
4.1.3, <a NAME="t184007"></a>Solaris 2.2 и <a NAME="t184008"></a>AIX 3.2.2,
объявляют MSS равный 1460, когда обе стороны
находятся на одном Ethernet. Расчеты, приведенные в [<a NAME="t184009"></a>Mogul 1993], показывают, что MSS равный 1460
обеспечивают лучшую производительность на Ethernet,
чем MSS равный 1024. </small></p>

<p><small>Если IP адрес назначения <a NAME="t184010"></a>&quot;не
локальный&quot;, MSS обычно устанавливается по
умолчанию - 536. Является ли локальным или
нелокальным конечный пункт назначения можно
следующим образом. Пункт назначения, IP адрес
которого имеет тот же самый идентификатор сети и
ту же самую маску подсети, что и у отправителя
является локальным; пункт назначения, IP адрес
которого полностью отличается от идентификатора
сети, является нелокальным; пункт назначения с
тем же самым идентификатором сети, однако с
другой маской подсети, может быть как локальным,
так и нелокальным. Большинство реализаций
предоставляют опцию конфигурации (<a HREF="tcp_e.html">приложение
E</a> и <a HREF="tcp_e.html#t351001">рисунок Е.1</a>), которая
позволяет системному администратору указать,
какие подсети являются локальными, а какие
нелокальными. Установка этой опции определяет
максимальный анонсируемый MSS (который по
величине может достигать MTU исходящего
интерфейса), иначе используется значение по
умолчанию равное 536. </small></p>

<p><small>MSS позволяет хосту устанавливать размер
датаграмм, который будет отправляться удаленной
стороной. Если принять во внимание тот факт, что
хост также ограничивает размер датаграмм,
которые он отправляет, это позволяет избежать
фрагментации, когда хост подключен к сети с
меньшим MTU. </small></p>

<p><small>Представьте наш хост slip, который имеет SLIP
канал с MTU равным 296, подключенным к
маршрутизатору bsdi. На рисунке 18.8 показаны эти
системы и хост sun.<a NAME="t184011"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t18_8_20.jpg" WIDTH="354" HEIGHT="133"></small></p>


<p ALIGN="CENTER"><small>Рисунок 18.8 TCP соединение от sun к slip и
значения MSS.</small></p>

<p>&nbsp;</p>

<p><small>Мы установили TCP соединение от sun к slip и
просмотрели сегменты с использованием tcpdump. На
рисунке 18.9 показано только установление
соединения (объявления размера окна удалены).<a NAME="t184012"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.1093
&gt; slip.discard: S 517312000:517312000(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;mss
1460&gt;<br>
2&nbsp; 0.10 (0.00)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slip.discard &gt; sun.1093:
S 509556225:509556225(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ack
517312001 &lt;mss 256&gt;<br>
3&nbsp; 0.10 (0.00)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.1093 &gt; slip.discard:
. ack 1<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 18.9 Вывод tcpdump для установления
соединения от sun к slip.</small></p>

<p>&nbsp;</p>

<p><small>Здесь важно обратить внимание на то, что что
sun не может послать сегмент с порцией данных
больше чем 256 байт, так как он получил MSS равный 256
(строка&nbsp;2). Более того, так как slip знает что MTU
исходящего интерфейса равен&nbsp;296, даже если sun
объявит MSS равный 1460, он никогда не сможет послать
больше чем 256 байт данных, чтобы избежать
фрагментации. Однако, система может послать
данных меньше, чем MSS объявленный удаленной
стороной. </small></p>

<p><small>Избежать фрагментации таким образом можно
только если хост непосредственно подключен к
сети с MTU меньше чем 576. Если оба хоста подключены
к Ethernet и оба анонсируют MSS равный 536, однако
промежуточная сеть имеет MTU равный 296, будет
осуществлена фрагментация. Единственный способ
избежать этого - воспользоваться механизмом
определения транспортного MTU (глава 24, раздел <a HREF="tcp24.html#t242000">&quot;Определение транспортного
MTU&quot;</a>).</small></p>
<u><b>

<p><a NAME="t185000"></a>Наполовину закрытый TCP</p>
</b></u>

<p><small>TCP предоставляет возможность одному
участнику соединения прекратить передачу
данных, однако все еще получать данные от
удаленной стороны. Это называется наполовину
закрытый TCP. Как мы уже упоминали ранее, немногие
приложения могут пользоваться этой
возможностью. </small></p>

<p><small>Чтобы использовать эту характеристику
программного интерфейса, необходимо
предоставить возможность приложению сказать:
&quot;Я закончило передачу данных, поэтому посылаю
признак конца файла (end-of-file) (FIN) на удаленный
конец, однако я все еще хочу получать данные с
удаленного конца до тех пор, пока он мне не пошлет
признак конца файла (end-of-file) (FIN).&quot;</small></p>

<p>&nbsp;</p>


<p><a NAME="t185001"></a>Сокеты API
поддерживают полузакрытый режим, если
приложение вызовет <a NAME="t185002"></a>shutdown со вторым
аргументом равным 1 вместо вызова <a NAME="t185003"></a>close.
Большинство приложений, однако, разрывают
соединения в обоих направлениях вызовом close.</p>


<p>&nbsp;</p>

<p><small>На рисунке 18.10 показан стандартный сценарий
для полузакрытого TCP. Мы показали клиента с левой
стороны, он инициирует полузакрытый режим,
однако это может сделать любая сторона. Первые
два сегмента одинаковы: FIN от инициатора, за ним
следует ACK и FIN от принимающего. Однако дальше
сценарий будет отличаться от того, который
приведен на рисунке 18.4, потому что сторона,
которая приняла приказ &quot;полузакрыть&quot;, может
все еще посылать данные. Мы показали только один
сегмент данных, за которым следует ACK, однако в
этом случае может быть послано любое количество
сегментов данных. (Мы расскажем более подробно об
обмене сегментами данных и подтверждениями в <a HREF="tcp19.html">главе 19</a>.) Когда конец, который получил
приказ &quot;полузакрыть&quot;, осуществил передачу
данных, он закрывает свою часть соединения, в
результате чего посылается FIN, при этом признак
конца файла доставляется приложению, которое
инициировало &quot;полузакрытый&quot; режим. Когда
второй FIN подтвержден, соединение считается
полностью закрытым.<a NAME="t185004"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t18_10_3.jpg" WIDTH="533" HEIGHT="330"></small></p>


<p ALIGN="CENTER"><small>Рисунок 18.10 TCP в полузакрытом
режиме.</small></p>

<p>&nbsp;</p>

<p><small>Для чего может быть использован
полузакрытый режим? Одним из примеров может
являться команда Unix <a NAME="t185005"></a>rsh(1), которая
исполняет команду на другой системе. Команда</small></p>

<p>&nbsp;</p>


<p>sun % <b>rsh bsdi sort &lt; datafile</p>
</b>

<p>&nbsp;</p>

<p><small>запустит команду sort на хосте bsdi, причем
стандартный ввод команды rsh будет читаться из
файла с именем datafile. Команда rsh создает TCP
соединения между собой и программой, которая
будет исполнена на удаленном хосте. Затем rsh
функционирует довольно просто: команда копирует
стандартный ввод (datafile) в соединение и копирует
из соединения в стандартный вывод (наш терминал).
На рисунке 18.11 показано как это происходит. (Мы
помним, что TCP соединение <a NAME="t185006"></a>полнодуплексное.)<a NAME="t185007"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t18_11_2.jpg" WIDTH="416" HEIGHT="65"></small></p>


<p ALIGN="CENTER"><small>Рисунок 18.11 Команда: rsh bsdi sort &lt; datafile.</small></p>

<p>&nbsp;</p>

<p><small>На удаленном хосте bsdi сервер rshd исполняет
программу sort таким образом, что ее стандартный
ввод и стандартный вывод направлены в TCP
соединение. В главе 14 [Stevens 1990] приводится
подробное описание структуры процесса Unix,
который участвует здесь, однако нас интересует,
как используется TCP соединение и полузакрытый
режим TCP. </small></p>

<p><small>Программа sort не может начать генерацию
вывода до тех пор, пока весь ее ввод не будет
прочитан. Все исходные данные, поступающие по
соединению от клиента rsh на сервер sort, посылаются
в файл, который должен быть отсортирован. Когда
достигается метка конца файла во вводе (datafile),
клиент rsh осуществляет полузакрытие TCP
соединения. Затем сервер sort принимает метку
конца файла из своего стандартного ввода (TCP
соединение), сортирует файл и пишет результат в
свой стандартный вывод (TCP соединение). Клиент rsh
продолжает читать TCP соединение на своем конце,
копируя отсортированный файл в свой стандартный
вывод. </small></p>

<p><small>Без использования наполовину закрытого
режима требуется какая-либо дополнительная
техника, которая позволит клиенту сообщить
серверу, что он закончил посылку данных, однако
клиенту все еще разрешено получать данные от
сервера. Альтернативно необходимо использовать
два соединения, однако предпочительно
использование полузакрытого режима.</small></p>
<u><b>

<p><a NAME="t186000"></a>Диаграмма состояний передачи TCP</p>
</b></u>

<p><small>Мы описали несколько правил установления и
разрыва TCP соединения. Эти правила собраны в
диаграмму состояний передачи, которая приведена
на рисунке&nbsp;18.12. </small></p>

<p><small>Необходимо отметить, что эта диаграмма -
диаграмма стандартных состояний. Мы пометили
обычную передачу клиента сплошными жирными
стрелками, а обычную передачу сервера
пунктирными жирными стрелками. </small></p>

<p><small>Две передачи, ведущие к состоянию
УСТАНОВЛЕНО (<a NAME="t186009"></a>ESTABLISHED), соответствуют
открытию соединения, а две передачи, ведущие от
состояния УСТАНОВЛЕНО (ESTABLISHED), соответствуют
разрыву соединения. Состояние УСТАНОВЛЕНО
(ESTABLISHED) наступает в тот момент, когда появляется
возможность осуществить передачу данных между
двумя сторонами в обоих направлениях. В
следующих главах будет описано, что происходит в
этом состоянии. </small></p>

<p><small>Мы объединили четыре квадратика в левой
нижней части диаграммы внутри пунктирной рамки и
пометили их &quot;активное закрытие&quot; (active close). Два
других квадратика (ОЖИДАНИЕ_ЗАКРЫТИЯ - <a NAME="t186002"></a>CLOSE_WAIT
и ПОСЛЕДНЕЕ_ПОДТВЕРЖДЕНИЕ - <a NAME="t186003"></a>LAST_ACK)
объединены пунктирной рамкой и помечены как
&quot;пассивное закрытие&quot; (passive close). </small></p>

<p><small>Названия 11-ти состояний (ЗАКРЫТО - <a NAME="t186004"></a>CLOSED,
СЛУШАЕТ - <a NAME="t186005"></a>LISTEN, SYN_ОТПРАВЛЕН - <a NAME="t186006"></a>SYN_SENT,
и так далее) на этом рисунке выбраны таким
образом, чтобы соответствовать состояниям,
которые выводит команда <a NAME="t186007"></a>netstat. Имена
же netstat, в свою очередь, практически идентичны
именам, описанным в RFC 793. Состояние ЗАКРЫТО (CLOSED) в
действительности не является состоянием, однако
является стартовой и конечной точкой для
диаграммы. </small></p>

<p><small>Изменение состояния от СЛУШАЕТ (LISTEN) к
SYN_ОТПРАВЛЕН (SYN_SENT) теоретически возможно, однако
не поддерживается в реализациях Berkeley. </small></p>

<p><small>А изменение состояния от ПОЛУЧЕН_SYN (<a NAME="t186008"></a>SYN_RCVD) назад к СЛУШАЕТ (LISTEN) возможно
только в том случае, если в состояние ПОЛУЧЕН_SYN
(SYN_RCVD) вошли из состояния СЛУШАЕТ (LISTEN) (это
обычный сценарий), а не из состояния SYN_ОТПРАВЛЕН
(SYN_SENT) (одновременное открытие). Это означает, что
если мы осуществили пассивное открытие (вошли в
состояние СЛУШАЕТ - LISTEN), получили SYN, послали SYN с
ACK (вошли в состояние ПОЛУЧЕН_SYN - SYN_RCVD) и затем
получили сброс вместо ACK, конечная точка
возвращается в состояние СЛУШАЕТ (LISTEN) и ожидает
прибытия другого запроса на соединение.<a NAME="t186001"></a><a NAME="t186010"></a><a NAME="t186011"></a><a NAME="t186012"></a><a NAME="t186013"></a><a NAME="t186014"></a><a NAME="t186015"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t18_12_2.jpg" WIDTH="551" HEIGHT="714"></small></p>


<p ALIGN="CENTER"><small>Рисунок 18.12 Диаграмма изменений
состояния TCP.</small></p>

<p>&nbsp;</p>

<p><small>На рисунке 18.13 показано обычное
установление и закрытие TCP соединения. Также
подробно описаны разные состояния, через которые
проходят клиент и сервер.<a NAME="t186016"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t18_13_2.jpg" WIDTH="502" HEIGHT="453"></small></p>


<p ALIGN="CENTER"><small>Рисунок 18.13 Состояния TCP,
соответствующие обычному открытию и разрыву
соединения.</small></p>

<p>&nbsp;</p>

<p><small>На рисунке 18.13 мы предположили что клиент,
находящийся с левой стороны, осуществляет
активное открытие, а сервер, находящийся справа,
осуществляет пассивное открытие. Также мы
показали, что клиент осуществляет активное
закрытие, (как мы упоминали ранее, каждая сторона
может осуществить активное закрытие). </small></p>

<p><small>Вам следует проследить изменения состояний
на рисунке 18.13 с использованием датаграммы
изменения состояний, приведенной на рисунке 18.12,
что позволит понять, почему осуществляется то
или иное изменение состояния.</small></p>
<i><b>

<p><a NAME="t186017"></a>Состояние ожидания 2MSL</p>
</b></i>

<p><small>Состояние ВРЕМЯ_ОЖИДАНИЯ (TIME_WAIT) также
иногда называется состоянием ожидания 2MSL. В
каждой реализации выбирается значение для
максимального времени жизни сегмента (<a NAME="t186018"></a>MSL
- maximum segment lifetime) . Это максимальное время, в
течение которого сегмент может существовать в
сети, перед тем как он будет отброшен. Мы знаем,
что это время ограничено, так как TCP сегменты
передаются посредством IP датаграмм, а каждая IP
датаграмма имеет поле <a NAME="t186019"></a>TTL, которое
ограничивает время ее жизни.</small></p>

<p>&nbsp;</p>


<p>RFC 793 [<a NAME="t186020"></a>Postel
1981c] указывает, что MSL должно быть равно 2 минутам.
В разных реализациях эта величина имеет значение
30 секунд, 1 минута или 2 минуты.</p>


<p>&nbsp;</p>

<p><small>В <a HREF="tcp08.html">главе 8</a> говорилось, что время
жизни IP датаграммы ограничивается количеством
пересылок, а не таймером. </small></p>

<p><small>При использовании MSL действуют следующие
правила: когда TCP осуществляет активное закрытие
и посылает последний сегмент содержащий
подтверждение (ACK), соединение должно остаться в
состоянии TIME_WAIT на время равное двум MSL. Это
позволяет TCP повторно послать последний ACK в том
случае, если первый ACK потерян (в этом случае
удаленная сторона отработает тайм-аут и повторно
передаст свой конечный FIN). </small></p>

<p><small>Другое назначение <a NAME="t186021"></a>ожидания 2MSL
заключается в том, что пока TCP соединение
находится в ожидании 2MSL, <a NAME="t186022"></a>пара
сокетов, выделенная для этого соединения (IP адрес
клиента, номер порта клиента, IP адрес сервера и
номер порта сервера), не может быть повторно
использована. Это соединение может быть
использовано повторно только когда истечет
время ожидания 2MSL. </small></p>

<p><small>К сожалению, большинство реализаций (Berkeley
одна из них) подчиняются более жестким
требованиям. По умолчанию локальный номер порта
не может быть повторно использован, до тех пор
пока этот номер порта является локальным номером
порта пары сокетов, который находится в
состоянии ожидания 2MSL. Ниже мы рассмотрим
примеры общих требований.</small></p>

<p>&nbsp;</p>


<p>Некоторые реализации и
API предоставляют средства, которые позволяют
обойти эти ограничения. С использованием <a NAME="t186023"></a>API сокет может быть указана опция
сокета <a NAME="t186024"></a>SO_REUSEADDR. Она позволяет
вызывающему назначить себе номер локального
порта, который находится в состоянии 2MSL, однако
мы увидим, что правила TCP не позволяют этому
номеру порта быть использованным в соединении,
которое находится в состоянии ожидания 2MSL.</p>


<p>&nbsp;</p>

<p><small>Каждый задержанный сегмент, прибывающий по
соединению, которое находится в состоянии
ожидания 2MSL, отбрасывается. Так как соединение
определяется парой сокет в состоянии 2MSL, это
соединение не может быть повторно использовано
до того момента, пока мы не сможем установить
новое соединение. Это делается для того, чтобы
опоздавшие пакеты не были восприняты как часть
нового соединения. (Соединение определяется
парой сокет. Новое соединение называется <a NAME="t186025"></a>восстановлением или оживлением
данного соединения.) </small></p>

<p><small>Как мы уже показали на рисунке 18.13, обычно
клиент осуществляет активное закрытие и входит в
режим TIME_WAIT. Сервер обычно осуществляет
пассивное закрытие и не проходит через режим
TIME_WAIT. Можно сделать вывод, что если мы выключим
клиента и немедленно его перестартуем, этот
новый клиент не сможет использовать тот же самый
локальный номер порта. В этом нет никакой
проблемы, так как клиенты обычно используют
динамически назначаемые порты и не заботятся,
какой динамически назначаемый порт используется
в настоящее время. </small></p>

<p><small>Однако, с точки зрения сервера все иначе,
так как сервера используют заранее известные
порты. Если мы выключим сервер, который имеет
установленное соединение, и постараемся
немедленно перестартовать его, сервер не может
использовать свой заранее известный номер порта
в качестве конечной точки соединения, так как
этот номер порта является частью соединения,
находящегося в состоянии ожидания 2MSL. Поэтому
может потребоваться от 1 до 4 минут, перед тем как
сервер будет перестартован. </small></p>

<p><small>Пронаблюдать подобный сценарий можно с
использованием программы <a NAME="t186026"></a>sock. Мы
стартовали сервер, подсоединили к нему клиента, а
затем выключили сервер:</small></p>


<p><br>
sun % <b>sock -v -s 6666 </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; стартуем
сервер, слушающий порт 6666<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (запускаем
клиента на bsdi, который подсоединится к этому
порту)<br>
connection on 140.252.13.33.6666 from140.252.13.35.1081<br>
^<b>? </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим
символ прерывания, чтобы выключить сервер<br>
sun % <b>sock -s 6666 </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; и
стараемся немедленно перестартовать сервер на
тот же самый порт<br>
can't bind local address: Address already in use<br>
sun % <b>netstat </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; попробуем
проверить состояние соединения<br>
Active Internet сonnections<br>
Proto Recv-Q Send-Q&nbsp;&nbsp; Local Address&nbsp;&nbsp;&nbsp; Foreign Address
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (state)<br>
tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp; sun.6666&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1081
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; множество
строк удалено<br>
</p>


<p>&nbsp;</p>

<p><small>Когда мы стараемся перестартовать сервер,
программа выдает сообщение об ошибке,
указывающее на то, что она не может захватить
свой заранее известный номер порта, потому что он
уже используется (находится в состоянии <a NAME="t186028"></a>ожидания 2MSL). </small></p>

<p><small>Затем мы немедленно исполняем <a NAME="t186029"></a>netstat,
чтобы посмотреть состояние соединения и
проверить, что оно действительно находится в
состоянии TIME_WAIT.</small></p>

<p>&nbsp;</p>


<p>Если мы будем
продолжать попытки перестартовать сервер и
посмотрим время, когда это удастся, то можем
вычислить значение 2MSL. Для <a NAME="t186030"></a>SunOS 4.1.3, <a NAME="t186031"></a>SVR4, <a NAME="t186032"></a>BSD/386 и <a NAME="t186033"></a>AIX 3.2.2
перестартовка сервера займет 1 минуту, что
означает, что MSL равно 30 секундам. В <a NAME="t186034"></a>Solaris
2.2 эта перестартовка сервера занимает 4 минуты,
это означает, что MSL равно 2 минутам.</p>


<p>&nbsp;</p>

<p><small>Мы можем увидеть ту же самую ошибку,
сгенерированную клиентом, если клиент старается
захватить порт, который является частью
соединения, находящего в режиме ожидания 2MSL
(обычно клиент этого не делает):</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>sock -v bsdi echo </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; стартуем клиент,
который подсоединяется к серверу echo<br>
connected on 140.252.13.33.1162 to 140.252.13.35.7<br>
<b>hello there </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; печатаем
эту строку<br>
hello there
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; она
отражается эхом от сервера<br>
^<b>D </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим
символ конца файла, чтобы выключить клиента<br>
sun % <b>sock -b1162 bsdi echo</b><br>
can't bind local address: Address already in use<br>
</p>


<p>&nbsp;</p>

<p><small>При первом запуске клиента была указана
опция -v, которая позволяет посмотреть, какой
используется локальный номер порта (1162). При
втором запуске клиента, была указана опция <a NAME="t186035"></a>-b, которая сообщает клиенту о
необходимости назначить самому себе номер
локального порта 1162. Как мы и ожидали, клиент не
может этого сделать, так как этот номер порта
является частью соединения, которое находится в
состоянии 2MSL. </small></p>

<p><small>Здесь необходимо упомянуть об одной
особенности состояния ожидания 2MSL, к которой мы
вернемся в <a HREF="tcp27.html">главе 27</a>, когда будем
рассказывать о протоколе передачи файлов (FTP - File
Transfer Protocol). Как уже упоминалось раньше, в
состоянии ожидания 2MSL остается пара сокетов
(состоящая из локального IP адреса, локального
порта, удаленного IP адреса и удаленного порта).
Однако, множество реализаций позволяют процессу
повторно использовать номер порта, который
является частью соединения, находящегося в
режиме 2MSL (обычно с использованием опции <a NAME="t186036"></a>SO_REUSEADDR) , TCP не может позволить создать
новое соединение с той же самой парой сокет. Это
можно доказать с помощью следующего
эксперимента: </small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>sock -v -s 6666 </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; старт
сервера, слушающего порт 6666<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (запускаем
клиента на bsdi, который подсоединяется к этому
порту)<br>
connection on 140.252.13.33.6666 from 140.252.13.35.1098<br>
^<b>? </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим
символ прерывания, чтобы выключить сервер<br>
sun % <b>sock -b6666 bsdi 1098 </b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; стартуем
клиента с локальным портом 6666<br>
can't bind local address: Address already in use<br>
sun % <b>sock -A -b6666 bsdi 1098 </b>&nbsp;&nbsp;&nbsp; пытаемся снова, на
этот раз с опцией -A<br>
active open error: Address already in use<br>
</p>


<p>&nbsp;</p>

<p><small>В первый раз мы запустили нашу программу sock
как сервер на порт 6666 и подсоединили к нему
клиента с хоста bsdi. Номер динамически
назначаемого порта клиента 1098. Мы выключили
сервер, таким образом, он осуществил активное
закрытие. При этом 4 параметра - 140.252.13.33 (локальный
IP адрес), 6666 (локальный номер порта), 140.252.13.35
(удаленный IP адрес) и 1098 (удаленный номер порта) на
сервере попадают в состояние 2MSL. </small></p>

<p><small>Во второй раз мы запустили эту программу в
качестве клиента, указав локальный номер порта
6666, при этом была сделана попытка подсоединиться
к хосту bsdi на порт 1098. При попытке повторно
использовать локальный порт 6666 была
сгенерирована ошибка, так как этот порт
находится в состоянии <a NAME="t186037"></a>2MSL. </small></p>

<p><small>Чтобы избежать появления этой ошибки, мы
запустили программу снова, указав опцию <a NAME="t186038"></a>-A, которая активизирует опцию <a NAME="t186039"></a>SO_REUSEADDR. Это позволило программе
назначить себе номер порта 6666, однако была
получена ошибка, когда программа попыталась
осуществить активное открытие. Даже если
программа сможет назначить себе номер порта 6666,
она не сможет создать соединения с портом 1098 на
хосте bsdi, потому что пара сокетов, определяющая
это соединение, находится в состоянии ожидания
2MSL. </small></p>

<p><small>Что если мы попытаемся установить
соединение с другого хоста? Во-первых, мы должны
перестартовать сервер на sun с флагом -A, так как
порт, который ему необходим (6666), является частью
соединения, находящегося в состоянии ожидания
2MSL:</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>sock -A -s 6666 </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; стартуем
сервер, слушающий порт 6666<br>
</p>


<p>&nbsp;</p>

<p><small>Затем, перед тем как состояние ожидания 2MSL
закончится на sun, мы стартуем клиента на bsdi:</small></p>

<p>&nbsp;</p>


<p>bsdi % <b>sock -b1098 sun 6666<br>
</b>connected on 140.252.13.35.1098 to 140.252.13.33.6666&nbsp;</p>

<p>&nbsp;</p>

<p><small>К сожалению, это работает! Это является
недостатком TCP спецификации, однако
поддерживается большинством реализаций Berkeley.
Эти реализации воспринимают прибытие запроса на
новое соединение для соединения, которое
находится в состоянии TIME_WAIT, если новый номер
последовательности больше чем последний номер
последовательности, использованный в предыдущем
соединении. В этом случае <a NAME="t186040"></a>ISN для
нового соединения устанавливается равным
последнему номеру последовательности для
предыдущего соединения плюс 128000. Приложение к RFC
1185 <a NAME="t186041"></a>[Jacobson, Braden, and Zhang 1990] показывает
возможные недостатки подобной технологии. </small></p>

<p><small>Эта характеристика реализации позволяет
клиенту и серверу повторно использовать те же
самые номера порта для успешного восстановления
того же самого соединения, в том случае, однако,
если сервер не осуществил активное закрытие. Мы
увидим другой пример состояния ожидания 2MSL на <a HREF="tcp27.html#t273001">рисунке 27.8</a>, когда будем
обсуждать FTP. Также обратитесь к <a HREF="#t18C001">упражнению
5</a> этой главы.</small></p>
<i><b>

<p><a NAME="t186042"></a>Концепция тихого времени</p>
</b></i>

<p><small>Состояние ожидания 2MSL предоставляет защиту
от опоздавших пакетов, принадлежащих ранним
соединениям, при этом они не будут
интерпретироваться как часть нового соединения,
которое использует те же самые локальный и
удаленный IP адреса и номера портов. Однако это
работает только в том случае, если хост с
соединением в состоянии 2MSL не вышел из строя. </small></p>

<p><small>Что если хост с портами в состоянии 2MSL вышел
из строя, перезагрузился во время MSL и немедленно
установил новые соединения с использованием тех
же самых локальных и удаленных IP адресов и
номеров портов, соответствующих локальным
портам, которые были в состоянии 2MSL перед
поломкой? В этом случае опоздавшие сегменты из
соединения, которое существовало перед поломкой,
могут быть ошибочно интерпретированы как
принадлежащие новому соединению, созданному
после перезагрузки. Это может произойти вне
зависимости от того, какой исходный номер
последовательности выбран после перезагрузки. </small></p>

<p><small>Чтобы защититься от подобных нежелательных
сценариев, RFC 793 указывает, что TCP не должен
создавать новые соединения до истечения <a NAME="t186043"></a>MSL после момента загрузки. Это
называется тихое время (quiet time).</small></p>

<p>&nbsp;</p>


<p>В некоторых реализациях хосты
ожидают даже дольше, чем время MSL после
перезагрузки.</p>


<p>&nbsp;</p>
<i><b>

<p>Состояние ОЖИДАНИЕ_И_ПОДТВЕРЖДЕНИЕ_FIN (FIN_WAIT_2) </p>
</b></i>

<p><small>В состоянии <a NAME="t186044"></a>FIN_WAIT_2 мы посылаем
наш FIN, а удаленная сторона подтверждает его. Если
мы не находимся в состоянии полузакрытого
соединения, то ожидаем от приложения на
удаленном конце, что оно опознает прием признака
конца файла и закроет свою сторону соединения,
причем пошлет нам FIN. Только когда процесс на
удаленном конце осуществит это закрытие, наша
сторона перейдет из режима FIN_WAIT_2 в режим TIME_WAIT. </small></p>

<p><small>Это означает, что наша сторона соединения
может остаться в этом режиме навсегда. Удаленная
сторона все еще в состоянии <a NAME="t186045"></a>CLOSE_WAIT и
может оставаться в этом состоянии всегда, до тех
пор пока приложение не решит осуществить
закрытие.</small></p>

<p>&nbsp;</p>


<p>Большинство Berkeley
реализаций предотвращают подобное вечное
ожидание в состоянии FIN_WAIT_2 следующим образом.
Если приложение, которое осуществило активное
закрытие, осуществило полное закрытие, а не
полузакрытие, что указывает на то, что оно
ожидает приема данных, в этом случае
устанавливается таймер. Если соединение не
используется в течении 10 минут плюс 75 секунд, TCP
переводит соединение в режим ЗАКРЫТО (<a NAME="t186046"></a>CLOSED).
В комментариях говорится, что подобная
характеристика противоречит спецификации
протокола.</p>


<p><small><a NAME="t187000"></a>&nbsp;</small></p>
<u><b>

<p>Сегменты сброса (Reset) </p>
</b></u>

<p><small>Мы упоминали, что в TCP заголовке существует
бит, называемый <a NAME="t187013"></a>RST, что означает
&quot;сброс&quot; (reset). В общем случае сигнал
&quot;сброс&quot; (reset) посылается TCP в том случае, если
прибывающие сегменты не принадлежат указанному
соединению. (Мы используем термин &quot;указанное
соединение&quot; (referenced connection), который обозначает
соединение, идентифицируемое IP адресом
назначения и номером порта назначения, а также IP
адресом источника и номером порта источника. В RFC
793 это называется &quot;сокет&quot;.) </small></p>
<i><b>

<p>Запрос о соединении на несуществующий порт</p>
</b></i>

<p><small>Самый общий случай, при котором
генерируется сброс (reset), это когда запрос о
соединении прибывает и при этом не существует
процесса, который слушает порт назначения. В
случае UDP, как мы видели в разделе <a HREF="tcp06.html#t065000">&quot;ICMP
ошибка недоступности порта&quot;</a> главы 6, если
датаграмма прибывает на неиспользуемый порт
назначения - генерируется ошибка <a NAME="t187002"></a>ICMP о
недоступности порта. TCP вместо этого использует
сброс. </small></p>

<p><small>Мы приведем простой пример с
использованием Telnet клиента, указав номер порта,
который не используется на пункте назначения:</small></p>

<p>&nbsp;</p>


<p><br>
bsdi % <b>telnet svr4 20000</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; порт
20000 не используется<br>
Trying 140.252.13.34...<br>
telnet: Unable to connect to remote host: Connection refused<br>
</p>


<p>&nbsp;</p>

<p><small>Сообщение об ошибке выдается клиенту Telnet
немедленно. На рисунке 18.14 показан обмен
пакетами, соответствующий этой команде.<a NAME="t187003"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1087
&gt; svr4.20000: S 297416193:297416193(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; win
4096 &lt;mss 1024&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [tos
0x10]<br>
2&nbsp; 0.003771 (0.0038)&nbsp;&nbsp;&nbsp;&nbsp; svr4.20000 &gt; bsdi.1087: R 0:0 (0) ack
297416194 win 0<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 18.14 Генерация сброса при попытке
открыть соединение на несуществующий порт.</small></p>

<p>&nbsp;</p>

<p><small>Значения, которые нам необходимо более
подробно рассмотреть на этом рисунке, это поле
номера последовательности и поле номера
подтверждения в сбросе. Так как бит
подтверждения (ACK) не был установлен в прибывшем
сегменте, номер последовательности сброса
установлен в 0, а номер подтверждения установлен
во входящий исходный номер последовательности (<a NAME="t187004"></a>ISN) плюс количество байт данных в
сегменте. Несмотря на то, что в прибывшем
сегменте не присутствует реальных данных, бит SYN
логически занимает 1 байт в пространстве номера
последовательности; таким образом, в этом
примере номер подтверждения в сбросе
устанавливается в ISN плюс длина данных (0) плюс
один SYN бит.</small></p>
<i><b>

<p>Разрыв соединения</p>
</b></i>

<p><small>В разделе <a HREF="#t182000">&quot;Установление и
разрыв соединения&quot;</a> этой главы мы видели, что
обычный метод, используемый для разрыва
соединения, заключается в том, что одна из сторон
посылает FIN. Иногда это называется <a NAME="t187014"></a>правильным
освобождением (orderly release), так как FIN посылается
после того, как все данные, ранее поставленные в
очередь, были отправлены, и обычно при этом не
происходит потеря данных. Однако существует
возможность прервать соединение, послав сброс
(reset) вместо FIN. Иногда это называется <a NAME="t187005"></a>прерывающим
освобождением (abortive release). </small></p>

<p><small>Подобный разрыв соединения предоставляет
приложению две возможности: (1) любые данные,
стоящие в очереди - теряются, и сброс
отправляется немедленно, и (2) сторона, принявшая
RST, может сказать, что удаленная сторона
разорвала соединение, вместо того чтобы закрыть
его обычным образом. Программный интерфейс (API),
который используется приложением, должен
предоставлять способ сгенерировать подобный
сброс вместо нормального закрытия. </small></p>

<p><small>Мы можем посмотреть, что происходит в
случае подобного разрыва, с использованием нашей
программы <a NAME="t187006"></a>sock. <a NAME="t187007"></a>Сокеты API
предоставляют эту возможность с использованием
опции сокета &quot;задержки закрытия&quot; (linger on close) (<a NAME="t187008"></a>SO_LINGER). Мы указали опцию <a NAME="t187009"></a>-L
со временем задержки равным 0. Это означает, что
вместо обычного FIN будет послан сброс, чтобы
закрыть соединение. Мы подключимся к версии
программы sock, которая выступает в роли сервера,
на svr4:</small></p>

<p>&nbsp;</p>


<p><br>
bsdi % <b>sock -L0 svr4 8888 </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; это клиент;
сервер показан дальше<br>
<b>hello, world </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим
одну строку, которая будет отправлена на
удаленный конец<br>
^<b>D </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим
символ конца файла, чтобы выключить клиента<br>
</p>


<p>&nbsp;</p>

<p><small>На рисунке 18.15 показан вывод команды tcpdump
для этого примера. (Мы удалили все объявления
окон в этом рисунке, так как они не влияют на наши
рассуждения.)<a NAME="t187010"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1099
&gt; svr4.8888: S 671112193:671112193(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;mss
1024&gt;<br>
2&nbsp; 0.004975 (0.0050)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; svr4.8888 &gt; bsdi.1099: S
3224959489:3224959489(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ack
671112194 &lt;mss 1024&gt;<br>
3&nbsp; 0.006656 (0.0017)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1099 &gt; svr4.8888: .
ack 1<br>
4&nbsp; 4.833073 (4.8264)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1099 &gt; svr4.8888: P
1:14 (13) ack 1<br>
5&nbsp; 5.026224 (0.1932)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; svr4.8888 &gt; bsdi.1099: .
ack 14<br>
6&nbsp; 9.527634 (4.5014)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1099 &gt; svr4.8888: R
14:14 (0) ack 1<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 18.15 Разрыв соединения с
использованием сброса (RST) вместо FIN.</small></p>

<p>&nbsp;</p>

<p><small>В строках 1-3 показано обычное установление
соединения. В строке 4 отправляется строка
данных, которую мы напечатали (12 символов плюс Unix
символ новой строки), и в строке 5 прибывает
подтверждение о приеме данных. </small></p>

<p><small>Строка 6 соответствует введенному символу
конца файла (Control-D), с помощью которого мы
выключили клиента. Так как мы указали разрыв
вместо обычного закрытия (опция командной строки
-L0), TCP на bsdi пошлет RST вместо обычного FIN. RST сегмент
содержит номер последовательности и номер
подтверждения. Также обратите внимание на то, что
RST сегмент не ожидает ответа с удаленного конца -
он не содержит подтверждения вообще. Получатель
сброса прерывает соединение и сообщает
приложению, что соединение было прервано. </small></p>

<p><small>Мы получим следующую ошибку от сервера при
подобном обмене:</small></p>

<p>&nbsp;</p>


<p><br>
svr4 % <b>sock -s 8888 </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; запускаем
как сервер, слушаем порт 8888<br>
hello, world
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; это
то, что отправил клиент<br>
read error: Connection reset by peer<br>
</p>


<p>&nbsp;</p>

<p><small>Этот сервер читает из сети и копирует в
стандартный вывод все что получил. Обычно он
завершает свою работу, получив признак конца
файла от своего TCP, однако здесь мы видим, что он
получил ошибку при прибытии RST. Ошибка это как раз
то, что мы ожидали: соединение было разорвано
одним из участников соединения.</small></p>
<i><b>

<p>Определение полуоткрытого соединения</p>
</b></i>

<p><small>Считается, что TCP соединение <a NAME="t187011"></a>полуоткрыто,
если одна сторона закрыла или прервала
соединение без уведомления другой стороны. Это
может произойти в любое время, если один из двух
хостов выйдет из строя. Так как какое-то время не
будет попыток передать данные по полуоткрытому
соединению, одна из сторон будет работать, до тех
пор пока не определит что удаленная сторона
вышела из строя. </small></p>

<p><small>Еще одна причина, по которой может
возникнуть полуоткрытое соединение, заключается
в том, что на хосте клиента было выключено
питание, вместо того чтобы погасить приложение
клиента, а затем выключить компьютер. Это
происходит тогда, например, Telnet клиент
запускается на PC, и пользователи выключают
компьютер в конце рабочего дня. Если в момент
выключения PC не осуществлялась передача данных,
сервер никогда не узнает, что клиент исчез. Когда
пользователь приходит на следующее утро,
включает свой PC и стартует новый клиент Telnet, на
хосте сервера стартует новый сервер. Из-за этого
на хосте сервера может появиться очень много
открытых TCP соединений. (В <a HREF="tcp23.html">главе 23</a> мы
увидим способ, с помощью которого один конец TCP
соединения может определить, что другой исчез.
Это делается с использованием TCP опции
&quot;оставайся в живых&quot; (keepalive)). </small></p>

<p><small>Мы можем легко создать полуоткрытое
соединение. Запускаем клиента Telnet на bsdi и
подсоединяемся к discard серверу на svr4. Вводим одну
строку и смотрим с использованием <a NAME="t187012"></a>tcpdump,
как она проходит, а затем отсоединяем Ethernet кабель
от хоста сервера и перезапускаем его. Этим самым
мы имитировали выход из строя хоста сервера. (Мы
отсоединили Ethernet кабель перед перезагрузкой
сервера, чтобы тот не послал FIN в открытое
соединение, что делают некоторые TCP модули при
выключении.) После того как сервер
перезагрузился, мы подсоединили кабель и
попробовали послать еще одну строку от клиента
на сервер. Так как сервер был перезагружен и
потерял все данные о соединениях, которые
существовали до перезагрузки, он ничего не знает
о соединениях и не подозревает о том, какому
соединению принадлежат прибывшие сегменты. В
этом случае принимающая сторона TCP отвечает
сбросом (reset).</small></p>

<p>&nbsp;</p>


<p><br>
bsdi % <b>telnet svr4 discard </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; запуск
клиента<br>
Trying 140.252.13.34... <br>
Connected to svr4.<br>
Escape character is '^]'.<br>
<b>hi there </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; эта
строка послана нормально<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; в
этом месте мы перезагрузили хост сервера<br>
<b>another line </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; в
этом месте был осуществлен сброс (reset)<br>
Connection closed by foreign host.<br>
</p>


<p>&nbsp;</p>

<p><small>На рисунке 18.16 показан вывод tcpdump для этого
примера. (Мы удалили из вывода объявления окон,
информацию о типе сервиса и объявления MSS, так как
они не влияют на наши рассуждения.)<a NAME="t187001"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp;&nbsp;&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1102
&gt; svr4.discard: S 1591752193:1591752193(0)<br>
2&nbsp;&nbsp;&nbsp; 0.004811 (&nbsp; 0.0048)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; svr4.discard
&gt; bsdi.1102: S 26368001:26368001(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ack
1591752194<br>
3&nbsp;&nbsp;&nbsp; 0.006516 (&nbsp; 0.0017)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1102 &gt;
svr4.discard: . ack 1<br>
<br>
4&nbsp;&nbsp;&nbsp; 5.167679 (&nbsp; 5.1612)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1102 &gt;
svr4.discard: P 1:11 (10) ack 1<br>
5&nbsp;&nbsp;&nbsp; 5.201662 (&nbsp; 0.0340)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; svr4.discard
&gt; bsdi.1102: . ack 11<br>
<br>
6&nbsp; 194.909929 (189.7083)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1102 &gt; svr4.discard: P
11:25 (14) ack 1<br>
7&nbsp; 194.914957 (&nbsp; 0.0050)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp who-has bsdi tell
svr4<br>
8&nbsp; 194.915678 (&nbsp; 0.0007)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp reply bsdi is-at
0:0:c0:6f:2d:40<br>
9&nbsp; 194.918225 (&nbsp; 0.0025)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; svr4.discard &gt;
bsdi.1102: R 26368002:26368002(0)<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 18.16 Сброс в ответ на приход сегмента
данных при полуоткрытом соединении.</small></p>

<p>&nbsp;</p>

<p><small>В строках 1-3 осуществляется обычное
установление соединения. В строке 4 отправляется
строка &quot;hi there&quot; (это можно примерно перевести
как &quot;эй вы, там&quot;) на discard сервер, в строке 5
приходит подтверждение. </small></p>

<p><small>В этом месте мы отсоединили Ethernet кабель от
svr4, перезагрузили его и подсоединили кабель
снова. Вся процедура заняла примерно 190 секунд.
Затем мы напечатали следующую строку ввода на
клиенте (&quot;another line&quot;), и когда мы нажали клавишу
Return, строка была отправлена на сервер (строка 6 на
рисунке 18.16). При этом был получен ответ от
сервера, однако так как сервер был перезагружен,
его ARP кэш пуст, поэтому в строках 7 и 8 мы видим ARP
запрос и отклик. Затем в строке 9 был послан сброс
(reset). Клиент получил сброс и выдал, что соединение
было прервано удаленным хостом. (Последнее
сообщение вывода от клиента Telnet не столь
информативно как могло бы быть.)</small></p>
<u><b>

<p><a NAME="t188000"></a>Одновременное открытие</p>
</b></u>

<p><small>Для двух приложений существует возможность
осуществить активное открытие в одно и то же
время. С каждой стороны должен быть передан SYN, и
эти SYN должны пройти по сети навстречу друг другу.
Также требуется, чтобы каждая сторона имела
номер порта, который известен другой стороне. Это
называется одновременным открытием (simultaneous open). </small></p>

<p><small>Например, приложение на хосте А имеющее
локальный порт 7777 осуществляет активное
открытие на порт 8888 хоста В. Приложение на хосте В
имеющее локальный порт 8888 осуществляет активное
открытие на порт 7777 хоста А. </small></p>

<p><small>Это не то же самое что подсоединение Telnet
клиента с хоста А на Telnet сервер на хосте В, в то
время когда Telnet клиент с хоста В подсоединяется к
Telnet серверу на хосте А. В подобном сценарии оба
Telnet сервера осуществляют пассивное открытие, а
не активное, тогда как Telnet клиенты назначают себе
динамически назначаемые номера портов, а не
порты, которые заранее известны для удаленных
Telnet серверов. </small></p>

<p><small>TCP специально разработан таким образом,
чтобы обрабатывать одновременное открытие, при
этом результатом является одно соединение, а не
два. (В других семействах протоколов, например, в
транспортном уровне <a NAME="t188001"></a>OSI, в подобном
случае создается два соединения, а не одно.) </small></p>

<p><small>Когда осуществляется одновременное
открытие, изменения состояний протокола
отличаются от тех, которые показаны на рисунке
18.13. Оба конца отправляют SYN в одно и то же время,
при этом входят в состояние SYN_ОТПРАВЛЕН (<a NAME="t188002"></a>SYN_SENT). Когда каждая сторона принимает
SYN, состояние меняется на SYN_ПРИНЯТ (<a NAME="t188003"></a>SYN_RCVD)
(см. рисунок 18.12), и каждый конец повторно
отправляет SYN с подтверждением о том, что SYN
принят. Когда каждый конец получает SYN плюс ACK,
состояние меняется на УСТАНОВЛЕНО (<a NAME="t188004"></a>ESTABLISHED).
Изменения состояний приведены на рисунке&nbsp;18.17.<a NAME="t188005"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t18_17_2.jpg" WIDTH="510" HEIGHT="150"></small></p>


<p ALIGN="CENTER"><small>Рисунок 18.17 Обмен сегментами в
процессе одновременного открытия.</small></p>

<p>&nbsp;</p>

<p><small>Одновременное открытие требует обмена
четырьмя сегментами, на один больше чем при
&quot;трехразовом рукопожатии&quot;. Также обратите
внимание на то, что мы не называем один из концов
клиентом, а другой сервером, потому что в данном
случае оба выступают и как клиент и как сервер.</small></p>
<i><b>

<p>Пример</p>
</b></i>

<p><small>Осуществить одновременное открытие
возможно, однако достаточно сложно. Обе стороны
должны быть стартованы примерно в одно и то же
время, таким образом, чтобы SYN пересеклись друг с
другом. В данном случае может помочь большое
время возврата между двумя участниками
соединения, что позволяет SYN пересечься. Чтобы
получить это, мы используем в качестве одного
участника соединения хост bsdi, а другого хост
vangogh.cs.berkeley.edu. Так как между ними находится SLIP
канал с дозвоном, время возврата должно быть
достаточно большим (несколько сотен
миллисекунд), что позволяет SYN пересечься. </small></p>

<p><small>Один конец (bsdi) назначает себе локальный
порт 8888 (опция командной строки <a NAME="t188006"></a>-b) и
осуществляет активное открытие на порт 7777
другого хоста:</small></p>

<p>&nbsp;</p>


<p><br>
bsdi % <b>sock -v -b8888 vangogh.cs.berkeley.edu 7777</b><br>
connected on 140.252.13.35.8888 to 128.32.130.2.7777<br>
TCP_MAXSEG = 512<br>
<b>hello, world </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим
эту строку<br>
and hi there
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; эта
строка была напечатана на другом конце<br>
connection closed by peer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; это
вывод, когда был получен FIN<br>
</p>


<p>&nbsp;</p>

<p><small>Другой конец был стартован примерно в это
же самое время, он назначил себе номер локального
порта 7777 и осуществил активное открытие на порт
8888:</small></p>

<p>&nbsp;</p>


<p><br>
vangogh % <b>sock -v -b7777 bsdi.tuc.noao.edu 8888</b><br>
connected on 128.32.130.2.7777 to 140.252.13.35.8888<br>
TCP_MAXSEG = 512<br>
hello, world
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; это
введено на другом конце<br>
<b>and hi there </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; мы
напечатали эту строку<br>
^<b>D </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; и
затем ввели символ конца файла EOF<br>
</p>


<p>&nbsp;</p>

<p><small>Мы указали флаг <a NAME="t188008"></a>-v в командной
строке программы <a NAME="t188009"></a>sock, чтобы проверить
IP адреса и номера портов для каждого конца
соединений. Этот флаг также печатает MSS,
используемый на каждом конце соединения. Мы
также напечатали в качестве ввода по одной
строке на каждом конце, которые были отправлены
на удаленный конец и напечатаны там, чтобы
убедиться, что оба хоста &quot;видят&quot; друг друга. </small></p>

<p><small>На рисунке 18.18 показан обмен сегментами для
этого соединения. (Мы удалили некоторые новые
опции TCP, появившиеся в исходных SYN, пришедших от
vangogh, которая работает под управлением <a NAME="t188010"></a>4.4BSD.
Мы опишем эти новые опции в разделе <a HREF="#t18A000">&quot;Опции
TCP&quot;</a> этой главы.) Обратите внимание, что за
двумя SYN (строки 1 и 2) следуют два SYN с ACK (строки 3 и
4). При этом происходит одновременное открытие. </small></p>

<p><small>В строке 5 показана введенная строка &quot;hello,
world&quot;, которая идет от bsdi к vangogh с подтверждением
в строке 6. Строки 7 и 8 соответствуют строке &quot;and
hi there&quot;, которая идет в другом направлении. В
строках 9-12 показано обычное закрытие соединения.</small></p>

<p>&nbsp;</p>


<p>Большинство реализаций
Berkeley не поддерживают корректно одновременное
открытие. В этих системах, если Вы можете
добиться того, что SYN пересекутся, все закончится
обменом сегментов, каждый с SYN и ACK, в обоих
направлениях. В большинстве реализаций не всегда
осуществляется переход от состояния SYN_SENT в
состояние SYN_RCVD, показанный на рисунке 18.12.<a NAME="t188011"></a></p>


<p>&nbsp;</p>


<p><br>
1&nbsp;&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.8888
&gt; vangogh.7777: S 91904001:91904001(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; win
4096 &lt;mss 512&gt;<br>
2&nbsp;&nbsp; 0.213782 (0.2138)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vangogh.7777 &gt;
bsdi.8888: S 1058199041:1058199041(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; win
8192 &lt;mss 512&gt;<br>
3&nbsp;&nbsp; 0.215399 (0.0016)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.8888 &gt;
vangogh.7777: S 91904001:91904001(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ack
1058199042 win 4096<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;mss
512&gt;<br>
4&nbsp;&nbsp; 0.340405 (0.1250)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vangogh.7777 &gt;
bsdi.8888: S 1058199041:1058199041(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ack
91904002 win 8192<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;mss
512&gt;<br>
5&nbsp;&nbsp; 5.633142 (5.2927)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.8888 &gt;
vangogh.7777: P 1:14 (13) ack 1 win 4096<br>
6&nbsp;&nbsp; 6.100366 (0.4672)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vangogh.7777 &gt;
bsdi.8888: . ack 14 win 8192<br>
<br>
7&nbsp;&nbsp; 9.640214 (3.5398)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vangogh.7777 &gt;
bsdi.8888: P 1:14 (13) ack 14 win 8192<br>
8&nbsp;&nbsp; 9.796417 (0.1562)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.8888 &gt;
vangogh.7777: . ack 14 win 4096<br>
<br>
9&nbsp; 13.060395 (3.2640)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vangogh.7777 &gt;
bsdi.8888: F 14:14 (0) ack 14 win 8192<br>
10&nbsp; 13.061828 (0.0014)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.8888 &gt;
vangogh.7777: . ack 15 win 4096<br>
11&nbsp; 13.079769 (0.0179)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.8888 &gt;
vangogh.7777: F 14:14 (0) ack 15 win 4096<br>
12&nbsp; 13.299940 (0.2202)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vangogh.7777 &gt;
bsdi.8888: . ack 15 win 8192<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 18.18 Обмен сегментами при
одновременном открытии.</small></p>

<p>&nbsp;</p>
<u><b>

<p><a NAME="t189000"></a>Одновременное закрытие</p>
</b></u>

<p><small>Как мы сказали ранее, с одной стороны (часто,
но не всегда, со стороны клиента) осуществляется
активное закрытие, при этом посылается первый FIN.
Также возможно для обеих сторон осуществить
активное закрытие, так как протокол TCP позволяет
осуществить одновременное закрытие (simultaneous close). </small></p>

<p><small>В терминах, приведенных на рисунке 18.12, оба
конца переходят от состояния УСТАНОВЛЕНО (<a NAME="t189001"></a>ESTABLISHED) к состоянию ОЖИДАНИЕ_FIN_1 (<a NAME="t189002"></a>FIN_WAIT_1) , когда приложение выдает сигнал
к закрытию. При этом оба посылают FIN, которые
возможно встретятся где-нибудь в сети. Когда FIN
принят, на каждом конце происходит переход из
состояния FIN_WAIT_1 в состояние ЗАКРЫВАЮ (<a NAME="t189003"></a>CLOSING)
и с каждой стороны посылается завершающий ACK.
Когда каждый конец получает завершающий ACK,
состояние меняется на <a NAME="t189004"></a>TIME_WAIT. На
рисунке 18.19 показаны изменения состояний.<a NAME="t189005"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t18_19_2.jpg" WIDTH="495" HEIGHT="150"></small></p>


<p ALIGN="CENTER"><small>Рисунок 18.19 Обмен сегментами в
процессе одновременного закрытия.</small></p>

<p>&nbsp;</p>

<p><small>При одновременном закрытии происходит
обмен таким же количеством пакетов, как и при
обычном закрытии. </small></p>
<u><b>

<p><a NAME="t18A000"></a>Опции TCP</p>
</b></u>

<p><small>TCP заголовок может содержать опции (<a HREF="tcp17.html#t172001">рисунок 17.2</a>). Единственные опции,
которые определены в оригинальной спецификации
TCP, следующие: конец списка опций, нет операции и
максимальный размер сегмента. Мы видели в наших
примерах, опцию MSS практически в каждом SYN
сегменте. </small></p>

<p><small>Более новые RFC, например RFC 1323 <a NAME="t18A001"></a>[Jacobson,
Braden, and Borman 1992], определяют дополнительные опции
TCP, большинство из которых можно обнаружить
только в более поздних реализациях. (Мы опишем
новые опции в <a HREF="tcp24.html">главе 24</a>.) На рисунке
18.20 показан формат текущих опций TCP - тех, которые
описаны в RFC 793 и RFC 1323.<a NAME="t18A002"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t18_20_2.jpg" WIDTH="523" HEIGHT="388"></small></p>


<p ALIGN="CENTER"><small>Рисунок 18.20 TCP опции.</small></p>

<p>&nbsp;</p>

<p><small>Каждая опция начинается с 1-байтового типа
(kind), который указывает на тип опции. Опции, тип
которых равен 0 и 1, занимают 1 байт. Другие опции
имеют длину (len) байт, который следует за байтом
типа. Длина - это полная длина, включающая байты
типа и длины. </small></p>

<p><small><a NAME="t18A003"></a>Опция &quot;нет операции&quot; (NOP)
добавлена, чтобы отправитель мог заполнить поля,
которые должны быть кратны 4 байтам. Если мы
установим TCP соединение от системы <a NAME="t18A004"></a>4.4BSD,
в начальном SYN сегменте с помощью tcpdump можно
увидеть следующие опции:</small></p>

<p>&nbsp;</p>


<p>&lt;mss 512, nop, wscale 0, nop, nop,
timestamp 146647 0&gt;</p>


<p>&nbsp;</p>

<p><small><a NAME="t18A005"></a>Опция MSS установлена в 512, за ней
следует NOP, за ней следует <a NAME="t18A006"></a>опция
размера окна. Первая опция NOP используется для
того, чтобы дополнить 3-байтовую опцию размера
окна до 4 байт. Точно так же, 10-байтовая <a NAME="t18A007"></a>опция
временной марки предваряется двумя NOP, чтобы
занимать 12 байт.</small></p>

<p>&nbsp;</p>


<p>Четыре другие опции,
которым соответствует тип равный 4, 5, 6 и 7,
называются опциями <a NAME="t18A008"></a>селективного ACK и
эхо опциями. Мы не показали их на рисунке 18.20,
потому что эхо опции заменены опцией временной
марки, а селективные ACK, как определено в
настоящее время, все еще находятся в обсуждении и
не были включены в RFC 1323. Надо отметить, что
предложение T/TCP для TCP транзакций (раздел <a HREF="tcp24.html#t247000">&quot;T/TCP: расширение TCP для
транзакций&quot;</a> главы 24) указывает еще три опции
с типами равными 11, 12 и 13.</p>


<p><small><a NAME="t18B000"></a>&nbsp;</small></p>
<u><b>

<p>Реализация TCP сервера</p>
</b></u>

<p><small>В разделе <a HREF="tcp01.html#t018000">&quot;Модель
Клиент-Сервер&quot;</a> главы 1 мы сказали, что
большинство TCP серверов - <a NAME="t18B001"></a>конкурентные.
Когда на сервер прибывает запрос об установлении
нового соединения, он принимает соединение и
запускает новый процесс, который будет
обслуживать нового клиента. В зависимости от
операционной системы используются различные
способы для создания нового сервера. В Unix
системах новый процесс создается с
использованием функции <a NAME="t18B002"></a>fork. </small></p>

<p><small>Нам необходимо обсудить, как TCP
взаимодействует с <a NAME="t18B003"></a>конкурентными
серверами. Хочется ответить на следующий вопрос:
как обрабатываются номера портов, когда сервер
получает запрос на новое соединение от клиента, и
что произойдет, если в одно и то же время прибудет
несколько запросов на соединение?</small></p>
<i><b>

<p><a NAME="t18B004"></a>Номера портов сервера TCP</p>
</b></i>

<p><small>Мы можем сказать, как TCP обрабатывает номера
портов, рассмотрев любой TCP сервер. Рассмотрим
Telnet сервер с использованием команды <a NAME="t18B005"></a>netstat.
Следующий вывод приведен для системы, у которых
нет активных Telnet соединений. (Мы удалили все
строки за исключением одной, которая показывает
Telnet сервер.) </small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>netstat -a -n -f inet</b><br>
Active Internet connections (including servers)<br>
Proto Recv-Q Send-Q&nbsp;&nbsp; Local Address
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Foreign Address
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (state)<br>
tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp; *.23
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *.*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LISTEN<br>
</p>


<p>&nbsp;</p>

<p><small>Флаг <a NAME="t18B006"></a>-a сообщает о всех конечных
точках сети, а не только о находящихся в
состоянии установлено (<a NAME="t18B007"></a>ESTABLISHED). Флаг <a NAME="t18B008"></a>-n печатает IP адреса в цифровом
десятичном представлении, вместо того чтобы
использовать DNS для конвертирования адресов в
имена, и печатает цифровые номера портов
(например, 23) вместо печати имен сервисов (в
данном случае Telnet). Опция <a NAME="t18B009"></a>-f inet
сообщает только о конечных точках TCP и UDP. </small></p>

<p><small>Локальный адрес выводится как *.23, где
звездочка обычно называется <a NAME="t18B010"></a>символом
подстановки или метасимволом. Это означает что
входящий запрос о соединении (SYN) будет принят с
любого локального интерфейса. Если хост имеет <a NAME="t18B011"></a>несколько интерфейсов, мы могли бы
указать один конкретный IP адрес в качестве
локального IP адреса (один из IP адресов хоста), и
только запросы на соединение, принятые с этого
интерфейса, будут обслужены. (Мы увидим, как это
делается, позже в этом разделе.) Локальный порт
равен 23, это заранее известный порт для Telnet. </small></p>

<p><small>Удаленный адрес показан как *.*, это
означает, что удаленный IP адрес и удаленный номер
порта пока не известны, потому что конечная точка
находится в состоянии СЛУШАЕТ (<a NAME="t18B012"></a>LISTEN),
ожидая прибытия запроса на соединение. </small></p>

<p><small>Сейчас мы стартуем Telnet клиента на хосте slip
(140.252.13.65), который подсоединится к этому серверу.
Здесь приведены соответствующие строки вывода
команды netstat:</small></p>

<p>&nbsp;</p>


<p><br>
Proto Recv-Q Send-Q&nbsp;&nbsp; Local Address
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Foreign Address
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (state)<br>
tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp; 140.252.13.33.23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 140.252.13.65.1029
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ESTABLISHED<br>
tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp; *.23
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *.*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LISTEN<br>
</p>


<p>&nbsp;</p>

<p><small>Первая строка для порта 23 это установленное
соединение (ESTABLISHED). Для этого соединения
заполнены все четыре элемента локального и
удаленного адресов: локальный IP адрес и номер
порта, и удаленный IP адрес и номер порта.
Локальный IP адрес соответствует интерфейсу, на
который прибыл запрос о соединении (Ethernet
интерфейс, 140.252.13.33). </small></p>

<p><small>Конечная точка осталась в состоянии LISTEN.
Это конечная точка, которую конкурентный сервер
использует, для того чтобы принимать запросы на
соединение, которые придут в будущем. В данном
случае TCP модуль, находящийся в ядре, создал новую
конечную точку в состоянии ESTABLISHED, в момент, когда
входящий запрос о соединении прибыл и был принят.
Также обратите внимание на то, что номер порта
для соединения, которое находится в состоянии
ESTABLISHED, не изменился: он равен 23, как и для
конечной точки, которая находится в состоянии
LISTEN. </small></p>

<p><small>Сейчас мы стартуем еще одного Telnet клиента с
того же самого клиента (slip) на этот сервер.
Соответствующий вывод команды <a NAME="t18B013"></a>netstat
будет выглядеть следующим образом:</small></p>

<p>&nbsp;</p>


<p><br>
Proto Recv-Q Send-Q&nbsp;&nbsp; Local Address
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Foreign Address
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (state)<br>
tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp; 140.252.13.33.23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 140.252.13.65.1030
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ESTABLISHED<br>
tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp; 140.252.13.33.23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 140.252.13.65.1029
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ESTABLISHED<br>
tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp; *.23
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *.*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LISTEN<br>
</p>


<p>&nbsp;</p>

<p><small>Сейчас мы видим два установленных (ESTABLISHED)
соединения с того же самого хоста на тот же самый
сервер. Оба имеют локальный номер порта равный 23.
Это не проблема для TCP, так как номера удаленных
портов различны. Они должны быть различны, потому
что каждый Telnet клиент использует динамически
назначаемый порт, а из определения динамически
назначаемого порта мы знаем, что динамически
назначенным может быть только тот порт, который
не используется в настоящее время на хосте (slip). </small></p>

<p><small>Этот пример показывает, что TCP <a NAME="t18B014"></a>демультиплексирует
входящие сегменты с использованием всех четырех
значений, которые сравниваются с локальным и
удаленным адресами: IP адрес назначения, номер
порта назначения, IP адрес источника и номер порта
источника. TCP не может определить, какой процесс
получил входящий сегмент, просматривая только
номер порта назначения. Также только одна из трех
конечных точек на порту 23, которая находится в
состоянии LISTEN, принимает входящие запросы на
соединения. Конечные точки, находящиеся в
состоянии ESTABLISHED, не могут принимать сегменты SYN,
а конечная точка, находящаяся в состоянии LISTEN, не
может принимать сегменты данных. </small></p>

<p><small>Сейчас мы стартуем еще одного клиента Telnet с
хоста solaris, который пройдет через SLIP канал от sun, а
не через Ethernet.</small></p>

<p>&nbsp;</p>


<p><br>
Proto Recv-Q Send-Q&nbsp;&nbsp; Local Address
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Foreign Address
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (state)<br>
tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp; 140.252.1.29.23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 140.252.1.32.34603
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ESTABLISHED<br>
tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp; 140.252.13.33.23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 140.252.13.65.1030
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ESTABLISHED<br>
tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp; 140.252.13.33.23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 140.252.13.65.1029
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ESTABLISHED<br>
tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp; *.23
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *.*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LISTEN<br>
</p>


<p>&nbsp;</p>

<p><small>Локальный IP адрес для первого
установленного (ESTABLISHED) соединения теперь
соответствует адресу интерфейса SLIP канала на
многоинтерфейсном хосте sun (140.252.1.29). </small></p>
<i><b>

<p><a NAME="t18B015"></a>Ограничение локальных IP адресов</p>
</b></i>

<p><small>Мы можем посмотреть, что произойдет, когда
сервер не использует символы подстановки в
качестве своих локальных IP адресов, устанавливая
вместо этого один конкретный адрес локального
интерфейса. Если мы укажем IP адрес (или имя хоста)
нашей программе sock, когда используем ее в
качестве сервера, этот IP адрес станет локальным IP
адресом слушающей конечной точки. Например</small></p>

<p>&nbsp;</p>


<p>sun % <b>sock -s 140.252.1.29 8888</p>
</b>

<p>&nbsp;</p>

<p><small>ограничивает этот сервер только для
соединений, прибывающих с SLIP интерфейса (140.252.1.29).
Вывод команды netstat покажет следующее: </small></p>

<p>&nbsp;</p>


<p><br>
Proto Recv-Q Send-Q&nbsp;&nbsp; Local Address
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Foreign Address
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (state)<br>
tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp; 140.252.1.29.8888&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *.*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LISTEN<br>
</p>


<p>&nbsp;</p>

<p><small>Если мы подсоединимся к этому серверу через
SLIP канал с хоста solaris, это сработает.</small></p>

<p>&nbsp;</p>


<p><br>
Proto Recv-Q Send-Q&nbsp;&nbsp; Local Address
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Foreign Address
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (state)<br>
tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp; 140.252.1.29.8888&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 140.252.1.32.34614
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ESTABLISHED<br>
tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp; 140.252.1.29.8888&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *.*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LISTEN<br>
</p>


<p>&nbsp;</p>

<p><small>Однако если мы постараемся подсоединиться
к этому серверу с хоста через Ethernet (140.252.13), запрос
на соединение не будет принят TCP модулем. Если мы
посмотрим с помощью tcpdump, то увидим что на SYN
получен отклик RST, как показано на рисунке 18.21.<a NAME="t18B016"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1026
&gt; sun.8888: S 3657920001:3657920001(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; win
4096 &lt;mss 1024&gt;<br>
2&nbsp; 0.000859 (0.0009)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.8888 &gt; bsdi.1026: R
0:0 (0) ack 3657920002 win 0<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 18.21 Ограничение запросов на
соединения, основанное на локальном IP адресе
сервера.</small></p>

<p>&nbsp;</p>

<p><small>Приложение, работающее на сервере, никогда
не увидит запрос на соединение - ограничение
осуществляется TCP модулем в ядре на основе
локального IP адреса, указанного приложением.</small></p>
<i><b>

<p><a NAME="t18B017"></a>Ограничение удаленного IP адреса</p>
</b></i>

<p><small>В разделе <a HREF="tcp11.html#t11C000">&quot;Сервер UDP&quot;</a>
главы 11 мы видели, что UDP сервер может определить
удаленный IP адрес и номер порта, в дополнение к
указанным локальному IP адресу и номеру порта.
Функции интерфейса, приведенные в RFC 793, позволяют
серверу осуществлять пассивное открытие на
основе полностью описанного удаленного сокета (в
этом случае ожидается запрос на активное
открытие от конкретного клиента) или не
указанного удаленного сокета (в этом случае
ожидается запрос на соединение от любого
клиента). </small></p>

<p><small>К сожалению, большинство API не
предоставляют таких возможностей. Сервер должен
оставлять удаленный сокет неконкретизированным,
ожидая прибытия соединения, а затем проверяя IP
адрес и номер порта клиента. </small></p>

<p><small>На рисунке 18.22 показаны три типа адресов и
взаимосвязи адресов с портами, которые TCP сервер
может установить для себя. Во всех случаях lport это
заранее известный порт сервера, а localIP должен
быть IP адресом локального интерфейса. Порядок, в
котором расположены три строки в таблице,
соответствует порядку, в котором TCP модуль
пытается определить, которая локальная конечная
точка примет входящий запрос на соединение.
Сначала осуществляется попытка, соответствующая
первой строке таблицы (если поддерживается), и
затем остальные спецификации (последняя строка с
IP адресами, указанными в виде символов
подстановки) пробуются последней.<a NAME="t18B018"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="636">
  <tr>
    <td WIDTH="19%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Локальный
    адрес</small></td>
    <td WIDTH="24%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Удаленный
    адрес</small></td>
    <td WIDTH="57%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Описание</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><p ALIGN="CENTER"><small>localIP.lport</small></td>
    <td WIDTH="24%" VALIGN="TOP"><p ALIGN="CENTER"><small>foreignIP.fport</small></td>
    <td WIDTH="57%" VALIGN="TOP"><small>ограничено одним
    клиентом (обычно не поддерживается)</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><p ALIGN="CENTER"><small>localIP.lport</small></td>
    <td WIDTH="24%" VALIGN="TOP"><p ALIGN="CENTER"><small>*.*</small></td>
    <td WIDTH="57%" VALIGN="TOP"><small>ограничено
    соединениями, прибывающими с одного локального
    интерфейса: localIP</small></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><p ALIGN="CENTER"><small>*.lport</small></td>
    <td WIDTH="24%" VALIGN="TOP"><p ALIGN="CENTER"><small>*.*</small></td>
    <td WIDTH="57%" VALIGN="TOP"><small>принимает все
    соединения, посланные на lport</small></td>
  </tr>
</table>


<p><small>Рисунок 18.22 Указание локального и
удаленного IP адресов и номеров порта для TCP
сервера.</small></p>
<i><b>

<p><a NAME="t18B019"></a>Входящая очередь запросов на
соединение</p>
</b></i>

<p><small><a NAME="t18B020"></a>Конкурентный сервер запускает
новый процесс, который обслуживает каждого
клиента, поэтому слушающий сервер должен быть
всегда готов обработать следующий входящий
запрос на соединение. Это основная причина, по
которой используются конкурентные серверы.
Однако, существует вероятность того, что
несколько запросов на соединение прибудут как
раз в тот момент, когда слушающий сервер создает
новый процесс, или когда операционная система
занята обработкой другого процесса с более
высоким приоритетом. Как TCP обрабатывает эти
входящие запросы на соединение, пока слушающее
приложение занято? </small></p>

<p><small>Реализации Berkeley используют следующие
правила.</small></p>

<p><small>&nbsp;</small> 

<ol>
  <li><small>Каждая слушающая конечная точка имеет
    фиксированную длину очереди соединений, которые
    могут быть приняты TCP (&quot;трехразовое
    рукопожатие&quot; завершено), однако еще не
    принятые приложением. Будьте внимательны,
    проводя различие между принятием соединения TCP и
    помещением его в очередь, и приложением,
    принимающем соединения из этой очереди.</small></li>
  <li><small>Приложение указывает ограничение или
    предел для этой очереди, который обычно
    называется backlog. Это ограничение должно быть в
    диапазоне от 0 до 5. (Большинство приложений
    указывают максимальное значение равное 5.)</small></li>
  <li><small>Когда прибывает запрос на соединение (SYN
    сегмент), TCP просматривает текущее количество
    соединений, поставленных в настоящий момент в
    очередь для этой слушающей конечной точки, при
    этом он выясняет, можно ли принять соединение. Мы
    ожидаем, что значение backlog, указанное
    приложением, будет максимальным, то есть,
    разрешено поставить в очередь максимальное
    количество соединений для этой точки, хотя это и
    не очень просто. На рисунке 18.23 показано
    взаимоотношение между значением backlog и реальным
    максимальным количеством соединений, которые
    можно поставить в очередь в традиционных Berkeley
    системах и <a NAME="t18B021"></a>Solaris 2.2.<a NAME="t18B022"></a></small><p><small>&nbsp;
    </small></p>
    <table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="366">
      <tr>
        <td WIDTH="32%" VALIGN="TOP" ROWSPAN="2" BGCOLOR="#ffffff"><p ALIGN="CENTER">&nbsp;</p>
        <p ALIGN="CENTER"><small>значение backlog</small></p>
        <p>&nbsp;</td>
        <td WIDTH="68%" VALIGN="TOP" COLSPAN="2" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Максимальное количество соединений,
        поставленных в очередь</small></td>
      </tr>
      <tr>
        <td WIDTH="39%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Традиционный
        BSD</small></td>
        <td WIDTH="29%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Solaris
        2.2</small></td>
      </tr>
      <tr>
        <td WIDTH="32%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
        <td WIDTH="39%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
        <td WIDTH="29%" VALIGN="TOP"><p ALIGN="CENTER"><small>0</small></td>
      </tr>
      <tr>
        <td WIDTH="32%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
        <td WIDTH="39%" VALIGN="TOP"><p ALIGN="CENTER"><small>2</small></td>
        <td WIDTH="29%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
      </tr>
      <tr>
        <td WIDTH="32%" VALIGN="TOP"><p ALIGN="CENTER"><small>2</small></td>
        <td WIDTH="39%" VALIGN="TOP"><p ALIGN="CENTER"><small>4</small></td>
        <td WIDTH="29%" VALIGN="TOP"><p ALIGN="CENTER"><small>2</small></td>
      </tr>
      <tr>
        <td WIDTH="32%" VALIGN="TOP"><p ALIGN="CENTER"><small>3</small></td>
        <td WIDTH="39%" VALIGN="TOP"><p ALIGN="CENTER"><small>5</small></td>
        <td WIDTH="29%" VALIGN="TOP"><p ALIGN="CENTER"><small>3</small></td>
      </tr>
      <tr>
        <td WIDTH="32%" VALIGN="TOP"><p ALIGN="CENTER"><small>4</small></td>
        <td WIDTH="39%" VALIGN="TOP"><p ALIGN="CENTER"><small>7</small></td>
        <td WIDTH="29%" VALIGN="TOP"><p ALIGN="CENTER"><small>4</small></td>
      </tr>
      <tr>
        <td WIDTH="32%" VALIGN="TOP"><p ALIGN="CENTER"><small>5</small></td>
        <td WIDTH="39%" VALIGN="TOP"><p ALIGN="CENTER"><small>8</small></td>
        <td WIDTH="29%" VALIGN="TOP"><p ALIGN="CENTER"><small>5</small></td>
      </tr>
    </table>
    <p><small>Рисунок 18.23 Максимальное
    количество принимаемых соединений для слушающей
    конечной точки.</small></p>
    <p><small>Запомните, что это значение backlog указывает
    только на максимальное количество соединений,
    поставленных в очередь для одной слушающей
    конечной точки, все из которых уже приняты TCP и
    ожидают того, чтобы быть принятыми приложением.
    Значение backlog не оказывает какого-либо влияния на
    максимальное количество соединений, которое
    может быть установлено системой, или на
    количество клиентов, которое может обслужить
    конкурентный сервер.</small></p>
    <p>&nbsp;</p>
    <p>Значения для
    Solaris на этом рисунке именно такие, как мы и
    ожидали. Традиционные значения для BSD (по каким-то
    непонятным причинам) равны значению backlog,
    умноженному на 3, поделенному на 2, плюс 1.</p>
    <p>&nbsp;</p>
  </li>
  <li><small>Если в очереди для данной слушающей
    конечной точки есть место для нового соединения
    (см. рисунок 18.23), TCP модуль подтверждает (ACK)
    пришедший SYN и устанавливает соединение.
    Приложение сервера со слушающей конечной точкой
    не увидит этого нового соединения до тех пор,
    пока не будет принят третий сегмент из
    &quot;трехразового рукопожатия&quot;. Также клиент
    может считать, что сервер готов принять данные,
    когда активное открытие клиента завершено
    успешно, перед тем как приложение сервера будет
    уведомлено о новом соединении. (Если это
    произойдет, сервер TCP просто поставит в очередь
    входящие данные.)</small></li>
  <li><small>Если не хватает места, для того чтобы
    поставить в очередь новое соединение, TCP просто
    игнорирует принятый SYN. В ответ ничего не
    посылается (не посылается даже RST сегмент). Если
    слушающий сервер не может отказаться от приема
    некоторых уже принятых соединений, которые
    заполнили собой очередь до предела, активное
    открытие клиента будет прервано по тайм-ауту.</small></li>
</ol>

<p>&nbsp;</p>

<p><small>Мы можем посмотреть этот сценарий с
использованием программы sock. Запустим ее с новой
опцией (<a NAME="t18B023"></a>-O), которая сообщает о
необходимости сделать паузу после создания
слушающей конечной точки, перед приемом любого
запроса на соединение. Если затем мы запустим
несколько клиентов в течение этой паузы, сервер
будет вынужден поставить в очередь принятые
соединения, а то, что произойдет, мы увидим с
использованием команды tcpdump.</small></p>

<p>&nbsp;</p>


<p>bsdi % <b>sock -s -v -q1 -O30 5555</p>
</b>

<p>&nbsp;</p>

<p><small>Опция <a NAME="t18B024"></a>-q1 устанавливает backlog
слушающей конечной точки в значение 1, для
традиционной BSD системы это будет
соответствовать двум запросам на соединение
(рисунок 18.23). Опция -O30 заставляет программу
&quot;проспать&quot; 30 секунд перед приемом любого
соединения от клиента. Это дает нам 30 секунд,
чтобы стартовать несколько клиентов, которые
заполнят очередь. Мы стартуем четырех клиентов
на хосте sun. </small></p>

<p><small>На рисунке 18.24 показан вывод программы tcpdump,
этот вывод начинается с первого SYN от первого
клиента. (Мы удалили объявления размера окна и
объявления MSS. Также мы выделили номера портов
клиента жирным шрифтом, когда TCP соединение
устанавливается - &quot;трехразовое
рукопожатие&quot;.) </small></p>

<p><small>Первый запрос на соединение от клиента,
пришедший с порта 1090, принимается TCP модулем
(сегменты 1-3). Второй запрос на соединение от
клиента с порта 1091 также принимается TCP модулем
(сегменты 4-6). Приложение сервера все еще
&quot;спит&quot; и не приняло ни одного соединения. Все
проделанное было осуществлено TCP модулем в ядре.
Также надо отметить, что два клиента успешно
осуществили активное открытие, то есть
&quot;трехразовое рукопожатие&quot; было успешно
завершено.<a NAME="t18B025"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp;&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.<b>1090</b>
&gt; bsdi.7777: S 1617152000:1617152000(0)<br>
2&nbsp;&nbsp; 0.002310 ( 0.0023)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.7777 &gt; sun.<b>1090</b>: S
4164096001:4164096001(0)<br>
3&nbsp;&nbsp; 0.003098 ( 0.0008)&nbsp;&nbsp;&nbsp;&nbsp; sun.<b>1090</b> &gt; bsdi.7777: .
ack 1617152001<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ack
1<br>
4&nbsp;&nbsp; 4.291007 ( 4.2879)&nbsp;&nbsp;&nbsp;&nbsp; sun.<b>1091</b> &gt; bsdi.7777: S
1617792000:1617792000(0)<br>
5&nbsp;&nbsp; 4.293349 ( 0.0023)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.7777 &gt; sun.<b>1091</b>: S
4164672001:4164672001(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ack
1617792001<br>
6&nbsp;&nbsp; 4.294167 ( 0.0008)&nbsp;&nbsp;&nbsp;&nbsp; sun.<b>1091</b> &gt; bsdi.7777: .
ack 1<br>
7&nbsp;&nbsp; 7.131981 ( 2.8378)&nbsp;&nbsp;&nbsp;&nbsp; sun.1092 &gt; bsdi.7777: S
1618176000:1618176000(0)<br>
8&nbsp; 10.556787 ( 3.4248)&nbsp;&nbsp;&nbsp;&nbsp; sun.1093 &gt; bsdi.7777: S
1618688000:1618688000(0)<br>
9&nbsp; 12.695916 ( 2.1391)&nbsp;&nbsp;&nbsp;&nbsp; sun.1092 &gt; bsdi.7777: S
1618176000:1618176000(0)<br>
10&nbsp; 16.195772 ( 3.4999)&nbsp;&nbsp;&nbsp;&nbsp; sun.1093 &gt; bsdi.7777: S
1618688000:1618688000(0)<br>
11&nbsp; 24.695571 ( 8.4998)&nbsp;&nbsp;&nbsp;&nbsp; sun.1092 &gt; bsdi.7777: S
1618176000:1618176000(0)<br>
12&nbsp; 28.195454 ( 3.4999)&nbsp;&nbsp;&nbsp;&nbsp; sun.<b>1093</b> &gt; bsdi.7777: S
1618688000:1618688000(0)<br>
13&nbsp; 28.197810 ( 0.0024)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.7777 &gt; sun.<b>1093</b>: S
4167808001:4167808001(0)<br>
14&nbsp; 28.198639 ( 0.0008)&nbsp;&nbsp;&nbsp;&nbsp; sun.<b>1093</b> &gt; bsdi.7777: . ack
1618688001<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ack
1<br>
15&nbsp; 48.694931 (20.4963)&nbsp;&nbsp;&nbsp;&nbsp; sun.<b>1092</b> &gt; bsdi.7777: S
1618176000:1618176000(0)<br>
16&nbsp; 48.697292 ( 0.0024)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.7777 &gt; sun.<b>1092</b>: S
4170496001:4170496001(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ack
1618176001<br>
17&nbsp; 48.698145 ( 0.0009)&nbsp;&nbsp;&nbsp;&nbsp; sun.<b>1092</b> &gt; bsdi.7777: . ack
1<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 18.24 Вывод программы tcpdump для примера
использования backlog.</small></p>

<p>&nbsp;</p>

<p><small>Мы попытались стартовать третьего клиента
в сегменте 7 (порт 1092) и четвертого в сегменте 8
(порт 1093). TCP игнорировало оба SYN, так как очередь
для этой слушающей конечной точки заполнена. Оба
клиента повторно передали свои SYN в сегментах 9, 10,
11, 12 и 15. Третья повторная передача четвертого
клиента принята (сегменты 12-14), потому что
30-секундная пауза сервера закончилась, и сервер
удалил два соединения, которые были приняты,
очистив очередь. (Причина, по которой это
произошло, заключается в том, что это соединение
было принято сервером в момент времени 28.19, а не в
момент времени, который больше чем 30; это
произошло потому, что потребовалось несколько
секунд, чтобы стартовать первого клиента
[сегмент 1, время старта в выводе] после старта
сервера.) Четвертая повторная передача третьего
клиента также принята (сегменты 15-17). Соединение
четвертого клиента (порт 1093) принято сервером
перед соединением третьего клиента (порт 1092)
из-за совпадения времени между окончанием
30-секундной паузы и повторной передачей клиента.</small></p>

<p>&nbsp;</p>


<p>Мы могли ожидать, что
очередь принятых соединений будет обработана
приложением в соответствии с принципом <a NAME="t18B026"></a>FIFO
(первый вошел, первый вышел). Таким образом, после
того как TCP принял приложение на порты 1090 и 1091, мы
ожидали, что приложение получит соединение
сначала на порт 1090, а затем соединение на порт 1091.
Однако, в большинстве реализаций Berkeley существует
ошибка (bug), в результате чего используется
порядок <a NAME="t18B027"></a>LIFO (последний вошел, первый
вышел). Производители много раз пытались
исправить эту ошибку, однако она до сих пор
существует в таких системах как SunOS&nbsp;4.1.3.</p>


<p>&nbsp;</p>

<p><small>TCP игнорирует входящее SYN, когда очередь
заполнена, и не отвечает с использованием RST,
из-за ошибки. Обычно очередь заполнена, потому
что приложение или операционная система заняты,
поэтому приложение не может обработать входящие
соединения. Подобное состояние может измениться
за короткий промежуток времени. Однако, если TCP
сервер ответил сбросом (reset), активное открытие
клиента будет прервано (как раз это произойдет,
если сервер не был стартован). Так как SYN
игнорирован, TCP клиент будет вынужден повторно
передать SYN позже, в надежде на то, что в очереди
появится место для нового соединения. </small></p>

<p><small>В этом месте необходимо обсудить еще одну
очень важную деталь, которая присутствует
практически во всех реализациях TCP/IP. Она
заключается в том, что TCP принимает входящий
запрос на соединение (SYN) в том случае, если в
очереди есть место. При этом приложение не может
посмотреть, от кого пришел запрос (IP адрес
источника и номер порта источника). Это не
требуется TCP, это всего лишь общая техника,
используемая в реализациях. Если API, такой как TLI
(раздел <a HREF="tcp01.html#t01F000">&quot;Интерфейсы
прикладного программирования&quot;</a> главы 1),
уведомляет приложение о прибытии запроса на
соединение и позволяет приложению выбрать,
принять это соединение или нет, то при
использовании TCP получается так, что когда
приложению сообщается, что соединение только что
прибыло, в действительности TCP уже завершил
&quot;трехразовое рукопожатие&quot;! В других
транспортных уровнях существует возможность
разграничить прибывшее и принятое соединения (<a NAME="t18B028"></a>OSI транспортный уровень), однако TCP
такой возможности не предоставляет.</small></p>

<p>&nbsp;</p>


<p><a NAME="t18B029"></a>Solaris 2.2
предоставляет опцию, которая не позволяет TCP
принимать входящий запрос на соединение до тех
пор, пока ему это не разрешит приложение (<a NAME="t18B030"></a>tcp_eager_listeners в разделе <a HREF="tcp_e.html#t354000">&quot;Solaris
2.2&quot;</a> приложения E).</p>


<p>&nbsp;</p>

<p><small>Это поведение также означает, что TCP сервер
не может сделать так что активное открытие
клиента будет прервано. Когда соединение от
нового клиента попадает к приложению сервера,
&quot;трехстороннее рукопожатие&quot; TCP уже
закончено и активное открытие клиента завершено
успешно. Если сервер затем смотрит на IP адрес
клиента и номер порта и решает, что он не хочет
обслуживать этого клиента, все сервера могут
просто закрыть соединение (при этом будет послан
FIN) или сбросить соединение (будет послан RST). В
любом случае клиент будет считать, что с сервером
все нормально, так как завершилось активное
открытие, и, вполне возможно, уже послал серверу
какой-либо запрос.</small></p>
<u><b>

<p><a NAME="t18C000"></a>Краткие выводы</p>
</b></u>

<p><small>Перед тем как два процесса смогут
обмениваться данными с использованием TCP, они
должны установить соединение между собой. Когда
работа между ними закончена, соединение должно
быть разорвано. В этой главе детально
рассмотрено то, как устанавливается соединение с
использованием &quot;трехразового рукопожатия&quot;
и как оно разрывается с использованием четырех
сегментов. </small></p>

<p><small>Мы использовали <a NAME="t18C014"></a>tcpdump, чтобы
показать все поля в заголовке TCP. Мы также
посмотрели, как установленное соединение может
быть прервано по тайм-ауту, как сбрасывается
соединение, что происходит с полуоткрытым
соединением и как TCP предоставляет полузакрытый
режим, одновременное открытие и одновременное
закрытие. </small></p>

<p><small>Для того чтобы понять функционирование TCP,
необходимо рассмотреть фундаментальную
диаграмму изменения состояний TCP. Мы рассмотрели
по пунктам, как устанавливается и разрывается
соединение, и какие при этом происходят
изменения в состоянии. Также мы рассмотрели, как
TCP серверы осуществляют установление соединений
TCP. </small></p>

<p><small>TCP соединения уникально идентифицируются 4
параметрами: локальным IP адресом, локальным
номером порта, удаленным IP адресом и удаленным
номером порта. Если соединение разрывается, одна
сторона все равно должна помнить об этом
соединении, в этом случае мы говорим что работает
режим <a NAME="t18C002"></a>TIME_WAIT. Правило гласит, что эта
сторона может осуществить активное открытие,
войдя в этот режим, после того как истекло
удвоенное время MSL, принятое для данной
реализации. </small></p>


<p>&nbsp;</p>
<i><b>

<p><a NAME="t18C001"></a>Упражнения</b></i> 

<ol>
  <li>В разделе <a HREF="#t182000">&quot;Установление
    и разрыв соединения&quot;</a> мы сказали, что
    исходный номер последовательности (<a NAME="t18C003"></a>ISN)
    обычно устанавливается в 1 и увеличивается на 64000
    каждые полсекунды и каждый раз когда
    осуществляется активное открытие. Это означает,
    что младшие три цифры в ISN всегда будут 001. Однако
    на рисунке 18.3 эти младшие три цифры для каждого
    направления равны 521. Как это произошло?</li>
  <li>На рисунке 18.15 мы напечатали 12 символов, но
    видели что TCP послал 13 байт. На рисунке 18.16 мы
    напечатали 8 символов, однако TCP отправил 10 байт.
    Почему в первом случае был добавлен 1 байт, а во
    втором 2 байта?</li>
  <li>В чем заключается отличие между полуоткрытым
    соединением и полузакрытым соединением?</li>
  <li>Если мы стартуем программу <a NAME="t18C004"></a>sock в
    качестве сервера, а затем прервем ее работу (при
    этом к ней не было подключено ни одного клиента),
    мы можем немедленно перестартовать сервер. Это
    означает, что он не будет находиться в состоянии
    ожидания <a NAME="t18C005"></a>2MSL. Объясните это в терминах
    диаграммы изменения состояний.</li>
  <li>В разделе <a HREF="#t186000">&quot;Диаграмма состояний
    передачи TCP&quot;</a> мы показали, что клиент не может
    повторно использовать тот же самый локальный
    номер порта, пока порт является частью
    соединения в состоянии ожидания 2MSL. Однако, если
    мы запустим программу sock дважды подряд в
    качестве клиента, подсоединяясь к серверу
    времени, мы можем использовать тот же самый
    локальный номер порта. В дополнение, мы можем
    создать новое соединение, которое будет в
    состоянии ожидания 2MSL. Как это происходит?<p><br>
    sun % <b>sock -v bsdi daytime</b><br>
    connected on 140.252.13.33.1163 to 140.252.13.35.13<br>
    Wed Jul 7 07:54:51 1993<br>
    connection closed by peer<br>
    <br>
    sun % <b>sock -v -b1163 bsdi daytime</b>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; повторное
    использование того же номера локального порта<br>
    connected on 140.252.13.33.1163 to 140.252.13.35.13<br>
    Wed Jul 7 07:55:01 1993<br>
    connection closed by peer<br>
    </p>
    </li>
  <li>В конце раздела <a HREF="#t186000">&quot;Диаграмма
    состояний передачи TCP&quot;</a>, когда мы описывали
    состояние <a NAME="t18C006"></a>FIN_WAIT_2, мы указали, что
    большинство реализаций переводит соединение из
    этого состояния в состояние <a NAME="t18C007"></a>CLOSED, если
    приложение осуществило полное закрытие (не
    наполовину закрытый) примерно через 11 минут. Если
    другая сторона (в состоянии <a NAME="t18C008"></a>CLOSE_WAIT)
    ждет 12 минут перед осуществлением закрытия
    (отправка своего FIN), что его TCP получит в ответ на
    FIN?</li>
  <li>Какая сторона в телефонном разговоре
    осуществляет активное открытие, а какая
    осуществляет пассивное открытие? Возможно ли
    одновременное открытие? Возможно ли
    одновременное закрытие?</li>
  <li>На рисунке 18.6 мы не видели ARP запрос или ARP
    отклик. Однако аппаратный адрес хоста svr4 должен
    быть в ARP кэше bsdi. Что изменится на этом рисунке,
    если этот пункт в ARP кэше отсутствует?</li>
  <li>Объясните следующий вывод команды tcpdump.
    Сравните его с рисунком 18.13.<p><br>
    1&nbsp; 0.0
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; solaris.32990
    &gt; bsdi.discard: S 40140288:40140288 (0)<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; win
    8760 &lt;mss 1460&gt;<br>
    2&nbsp; 0.003295 (0.0033)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.discard &gt; solaris.32990: S
    4208081409:4208081409 (0)<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ack
    40140289 win 4096<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;mss
    1024&gt;<br>
    3&nbsp; 0.419991 (0.4167)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; solaris.32990 &gt; bsdi.discard: P
    1:257 (256) ack 1 win 9216<br>
    4&nbsp; 0.449852 (0.0299)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; solaris.32990 &gt; bsdi.discard: F
    257:257 (0) ack 1 win 9216<br>
    5&nbsp; 0.451965 (0.0021)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.discard &gt; solaris.32990: .
    ack 258 win 3840<br>
    6&nbsp; 0.464569 (0.0126)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.discard &gt; solaris.32990: F
    1:1 (0) ack 258 win 4096<br>
    7&nbsp; 0.720031 (0.2555)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; solaris.32990 &gt; bsdi.discard: .
    ack 2 win 9216<br>
    </p>
    </li>
  <li>Почему бы серверу на рисунке
    18.4 не скомбинировать ACK на FIN клиента со своим
    собственным FIN, уменьшив тем самым количество
    сегментов до трех?</li>
  <li>На рисунке 18.16, почему номер последовательности
    RST равен 26368002?</li>
  <li>Скажите, основан ли запрос TCP к канальному
    уровню о его MTU на принципе разбиения на уровни?</li>
  <li>Представьте, что на <a HREF="tcp14.html#t149001">рисунке 14.16</a>
    каждый DNS запрос отправляется с использованием TCP
    вместо UDP. Скажите, сколькими пакетами будет
    осуществлен обмен?</li>
  <li>Если <a NAME="t18C009"></a>MSL равно 120 секунд, через какое
    максимальное время система может инициировать
    новое соединение, а затем осуществить активное
    закрытие?</li>
  <li>Прочитайте RFC 793, чтобы посмотреть что
    произойдет, когда конечная точка, находящаяся в
    режиме <a NAME="t18C010"></a>TIME_WAIT, получает повторный FIN,
    который помещает ее в это состояние.</li>
  <li>Прочитайте RFC 793, чтобы посмотреть что
    произойдет, когда конечная точка, которая
    находится в состоянии TIME_WAIT, получает RST.</li>
  <li>Прочитайте требования к хостам <a NAME="t18C011"></a>Host
    Requirements RFC, чтобы получить определение <a NAME="t18C012"></a>полудуплексного
    TCP закрытия.</li>
  <li>На <a HREF="tcp01.html#t017001">рисунке 1.8</a> мы показали, что
    входящие TCP сегменты <a NAME="t18C013"></a>демультиплексируются
    на основе номера порта назначения TCP. Правильно
    ли это?</li>
</ol>

<hr>

</body>
</html>

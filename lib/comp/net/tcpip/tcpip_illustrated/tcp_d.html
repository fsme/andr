<html>

<head>
<title>Решения и ответы на упражнения</title>

<meta http-equiv="Content-type" content="text/html; charset=koi8-r">
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>


<b>

<p><a NAME="t340000"></a>Приложение D Решения и ответы на
упражнения</p>
</b>

<p><small><a HREF="tcp01.html">Глава 1</a></small>

<ol>
  <li><small>Значение равно 2<sup>7</sup> - 2 (126) плюс 2<sup>14</sup> - 2
    (16382) плюс 2<sup>21</sup> - 2 (2097150), что составит 2113658. Мы
    вычитаем 2 при каждом расчете, так как
    идентификатор сети, состоящий из всех нулевых
    битов или всех единичных битов, не может
    существовать.</small></li>
  <li><small>На рисунке D.1 точками показаны значения до
    августа 1993 года.<a NAME="t340001"></a></small><p ALIGN="CENTER"><small><img SRC="tD_10000.jpg" WIDTH="493" HEIGHT="218"></small></p>
    <p ALIGN="CENTER"><small>Рисунок D.1 Количество
    сетей в сети <a NAME="t340002"></a>NSFNET.</small></p>
    <p><small>&nbsp;</small></p>
    <p><small>Пунктирная линия примерно показывает
    максимальное количество сетей, которое будет
    достигнуто к 2000 году, если продолжится
    экспоненциальный рост количества сетей.</small></p>
  </li>
  <li><small><a NAME="t340003"></a>&quot;Будь либеральным к тому, что
    принимаешь, и требовательным к тому, что
    отправляешь.&quot;</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp03.html">Глава 3</a></small>

<ol>
  <li><small>Нет, любой адрес класса сети с
    идентификатором, начинающимся со 127, имеет право
    существовать, однако большинство систем
    использует 127.0.0.1.</small></li>
  <li><small>kpno имеет пять интерфейсов: три канала
    точка-точка и два Ethernetа. R10 имеет четыре
    интерфейса Ethernet. gateway имеет три интерфейса: два
    канала точка-точка и один Ethernet. И netb имеет один
    интерфейс Ethernet и два канала точка-точка.</small></li>
  <li><small>Нет никакой разницы: оба имеют маски подсети
    255.255.255.0, как адреса класса С, которые не поделены
    на подсети.</small></li>
  <li><small>Можно. Это называется <a NAME="t340004"></a>непересекающиеся
    сетевые маски, так как 16 бит, выделенные под маску
    подсети, не пересекаются. RFC, однако, рекомендует
    не использовать непересекающиеся сетевые маски.</small></li>
  <li><small>Так сложилось исторически. Значение
    получилось как 1024 + 512 при этом напечатанные
    значения MTU включают все требуемые заголовки. <a NAME="t340005"></a>Solaris 2.2 устанавливает <a NAME="t340006"></a>MTU для
    <a NAME="t340007"></a>loopback интерфейса равный 8232 (8192 + 40), что
    вмещает в себя 8192 байта пользовательских данных
    вместе с обычным 20-байтовым IP заголовком и
    20-байтовым TCP заголовком.</small></li>
  <li><small>Во-первых, с датаграммами значительно легче
    работать маршрутизаторам. Во-вторых, на основе
    датаграмм могут быть основаны и ненадежные (UDP) и
    надежные (TCP) транспортные уровни. В-третьих,
    датаграммы представляют собой минимальное
    представление сетевого уровня, что позволяет
    использовать разнообразные канальные уровни.</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp04.html">Глава 4</a></small>

<ol>
  <li><small>Исполнение команды <a NAME="t340008"></a>rsh
    устанавливает TCP соединение с удаленным хостом.
    При этом начинается обмен IP датаграммами между
    двумя хостами. При этом требуется, чтобы на
    удаленном хосте была запись в ARP кэше. Даже если ARP
    кэш был пуст перед исполнением команды rsh, можно
    гарантировать, что запись для нашего хоста в ARP
    кэше появится, перед тем как сервер rsh исполнит
    команду <a NAME="t340009"></a>arp.</small></li>
  <li><small>Убедитесь, что ваш хост не имеет записи в
    своем ARP кэше для какого-либо другого хоста в той
    же Ethernet сети, скажем foo. Убедитесь, что foo посылает
    &quot;беспричинный&quot; ARP запрос при загрузке. Это
    можно сделать, запустив <a NAME="t340010"></a>tcpdump на
    другом хосте, когда загружается foo. Затем
    погасите хост foo и внесите неверный пункт в ARP кэш
    на вашей системе для foo. Используйте команду arp и
    не забудьте указать опцию temp. Загрузите foo, и
    когда он загрузился, посмотрите ваш ARP кэш на
    предмет того, была ли исправлена неверная запись.</small></li>
  <li><small>Прочитайте раздел 2.3.2.2 в требованиях к
    хостам <a NAME="t340011"></a>Host Requirements RFC и раздел <a HREF="tcp11.html#t119000">&quot;Взаимодействие между UDP и ARP&quot;</a>
    главы 11 этой книги.</small></li>
  <li><small>Допустим, у клиента существовала полная ARP
    запись для сервера, когда сервер был выключен.
    Если мы будем продолжать попытки подсоединиться
    к серверу (выключенному), тайм-аут ARP будет
    продлен еще на 20 минут. Когда сервер окончательно
    перезагрузится с новым аппаратным адресом, и
    если он не разошлет &quot;беспричинный&quot; ARP, старая
    неверная ARP запись будет все еще останется у
    клиента. У нас не будет возможности
    подсоединиться к серверу на его новый аппаратный
    адрес до тех пор, пока мы вручную не удалим запись
    в ARP кэше или прекратим на 20 минут попытки
    достучаться до сервера.</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp05.html">Глава 5</a></small>

<ol>
  <li><small>Разные типы фреймов это не абсолютное
    требование, так как поле op на <a HREF="tcp04.html#t044001">рисунке
    4.3</a> имеет различные значения для всех четырех
    операций (ARP запрос, ARP отклик, RARP запрос и RARP
    отклик). Однако отличить реализацию RARP сервера от
    ARP сервера, находящегося в ядре, значительно
    легче с разными полями в поле типа фрейма.</small></li>
  <li><small>Каждый RARP сервер может осуществить
    маленькую задержку на случайный момент времени,
    перед тем как отправить ответ. В качестве
    усовершенствования, один RARP сервер может быть
    назначен как первичный, а все остальные как
    вторичные. Первичный сервер может отвечать без
    задержки, а вторичные со случайными задержками.
    Еще одно усовершенствование. В случае
    использования первичных и вторичных серверов,
    вторичные сервера могут быть запрограммированы
    таким образом, чтобы отвечать только на
    повторные запросы, принятые за короткие
    промежутки времени. При этом подразумевается,
    что причина появления повторных запросов
    заключается в том, что первичный сервер выключен.</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp06.html">Глава 6</a></small>

<ol>
  <li><small>Если бы на одном локальном кабеле
    находилась сотня хостов, каждый попробовал бы
    послать <a NAME="t340012"></a>ICMP ошибку о недоступности
    порта примерно в одно и то же время. Это привело
    бы к коллизиям (если используется Ethernet), при этом
    сеть станет практически бесполезной в течение
    секунды или двух.</small></li>
  <li><small>В этом случае &quot;следует&quot;.</small></li>
  <li><small>ICMP ошибка всегда отправляется с <a NAME="t340013"></a>TOS
    равным 0, как показано на <a HREF="tcp03.html#t032002">рисунке
    3.2</a>. <a NAME="t340014"></a>ICMP запрос может быть отправлен с
    любым TOS, но соответствующий отклик должен быть
    отправлен с тем же самым TOS.</small></li>
  <li><small>Команда <a NAME="t340015"></a>netstat <a NAME="t340016"></a>-s
    обычно используется для того, чтобы посмотреть
    статистику по протоколам. На хосте <a NAME="t340017"></a>SunOS
    4.1.1 (gemini), который получил 48 миллионов IP датаграмм,
    ICMP статистика следующая:</small><p><small>&nbsp;</small></p>
    <pre>
Output histogram:
       echo reply: 1757
       destination unreachable: 700
       time stamp reply: 1
Input histogram:
       echo reply: 211
       destination unreachable: 3071
       source quench: 249
       routing redirect: 2789
       echo: 1757
       #10: 21
       time exceeded: 56
       time stamp: 1
</pre>
    <p><small>&nbsp;</small></p>
    <p><small>21 входное сообщение с типом 10 - это
    требования к маршрутизатору, которые не
    поддерживаются SunOS 4.1.1. </small></p>
    <p><small>При использовании SNMP (<a HREF="tcp25.html#t258028">рисунок
    25.26</a>) некоторые системы, как, например, <a NAME="t340018"></a>Solaris
    2.2, генерируют вывод netstat -s, который использует
    имена переменных SNMP.</small></p>
  </li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp07.html">Глава 7</a></small>

<ol>
  <li><small>86 байт поделенные на 960 байт/сек, умноженные
    на 2 дают 179,2 миллисекунды. Когда <a NAME="t340019"></a>ping
    запущен с этой скоростью, печатаются значения
    равные 180 миллисекундам.</small></li>
  <li><small>(86 + 48) байт поделенные на 960 байт/сек,
    умноженные на 2 дают 279,2 миллисекунды. Появление
    дополнительных 48 байт объясняются тем, что
    последние 48 байт из 56 байт в части данных должны
    быть экранированы: 0xc0 это символ END в протоколе
    SLIP.</small></li>
  <li><small><a NAME="t340020"></a>CSLIP сжимает только TCP и IP
    заголовки в TCP сегментах. Он не влияет на ICMP
    сообщения, которые используются программой ping.</small></li>
  <li><small>На SPARCstation ELC ping на <a NAME="t340021"></a>loopback адрес
    дает RTT равное 1,310 миллисекунды, тогда как ping на
    Ethernet адрес хоста дает RTT равное 1,460 милисекунды.
    Эта разница объясняется дополнительной
    обработкой, осуществляемой Ethernet драйвером,
    который определяет, что датаграмма
    действительно предназначена локальному хосту.
    Вам потребуется версия ping, которая дает
    микросекундное разрешение, чтобы оценить
    подобную разницу.</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp08.html">Глава 8</a></small>

<ol>
  <li><small>Если входящая датаграмма имеет <a NAME="t340022"></a>TTL
    равное 0, вычитание единицы и затем проверка
    могут установить TTL в значение 255 и продлить
    существование датаграммы. Несмотря на то, что
    маршрутизатор никогда не должен получать
    датаграммы с TTL равным 0, это может произойти.</small></li>
  <li><small><a NAME="t340023"></a>Мы заметили, что traceroute сохраняет
    12 байт данных из раздела данных UDP датаграммы,
    которые содержат время отправки датаграммы.
    Однако, из <a HREF="tcp06.html#t065005">рисунка 6.9</a> видно, что
    ICMP возвращает только первые 8 байт IP датаграммы,
    которая вызвала ошибку, там находилось 8 байт UDP
    заголовка. То есть, значение времени, сохраненное
    traceroute, не возвратилось в ICMP сообщение об ошибке.
    traceroute сохранила время, при отправке пакета, а
    когда был получен ICMP отклик, определила текущее
    время и, использовав эти два значения, получила
    RTT. Из <a HREF="tcp07.html">главы 7</a> мы видим, что ping
    сохраняет время в исходящем <a NAME="t340024"></a>ICMP эхо
    запросе, а сервер отражает эти данные. Это
    позволяет ping напечатать корректный RTT, даже если
    пакеты вернулись беспорядочно.</small></li>
  <li><small>Первая строка вывода корректна и указывает
    на R1. Следующая проба стартует с TTL равным 2, оно
    уменьшается на единицу в R1. Когда R2 получает
    датаграмму с уменьшенным на единицу TTL (от 1 до 0),
    то некорректно перенаправляет ее в R3. R3 видит, что
    входящий TTL равен 0 и отправляет назад ошибку об
    истечении времени. Это означает, что вторая
    строка вывода (для TTL равного 2) указывает на R3, а
    не на R2. Третья строка вывода корректно указывает
    на R3. Ошибка присутствует в двух
    последовательных строках вывода, которые
    указывают на один и тот же маршрутизатор.</small></li>
  <li><small><a NAME="t340025"></a>В данном случае TTL равное 1
    указывает на R1, TTL равное 2 указывает на R2, а TTL
    равное 3 указывает на R3; однако, когда TTL равно 4, UDP
    датаграммы достигает пункта назначения со
    входящим TTL равным 1. Генерируется ICMP ошибка о <a NAME="t340026"></a>недоступности порта, однако TTL
    сообщение об ошибке равно 1 (некорректно
    скопировано из входящего TTL). ICMP сообщение идет на
    R3, где TTL уменьшается на единицу, и сообщение
    отбрасывается. <a NAME="t340027"></a>ICMP ошибка об
    истечении времени не генерируется, так как
    датаграмма, которая была отброшена, - это ICMP
    сообщение об ошибке (<a NAME="t340028"></a>порт
    недоступен). Тоже происходит и с пробой, TTL
    которой равен 5, однако на этот раз исходящая
    ошибка о недоступности порта стартует с TTL равным
    2 (скопировано из входящего TTL), и доходит до R2, где
    отбрасывается. Ошибка о недоступности порта,
    соответствующая пробе с TTL равным 6, доходит до R1,
    где тоже отбрасывается. И, в конце концов, ошибка
    о недоступности порта для пробы с TTL равным 7
    проходит полный путь и возвращается назад с
    входящим TTL равным 1. (traceroute считает, что
    прибывающее ICMP сообщение с TTL равным 0 или 1 это
    одно и то же, поэтому она печатает
    восклицательный знак после RTT.) И в завершение,
    строки с TTL равными 1, 2 и 3 корректно
    идентифицируют R1, R2 и R3, затем следуют три строки,
    каждая из которых содержит три тайм-аута, за
    которым следует строка для TTL равного 7, которая
    идентифицирует пункт назначения.</small></li>
  <li><small><a NAME="t340029"></a>Все эти маршрутизаторы
    установили исходящий TTL ICMP сообщения в значение
    255. Это общепринятая практика. Как мы и ожидали,
    входящее значение от netb равно 255, однако значение
    равное 253 от butch означает, что возможно где-то есть
    &quot;невидимый&quot; маршрутизатор. Иначе в этой
    точке появился бы входящий TTL равный 254. Точно так
    же, от enss142.UT.westnet.net мы ожидаем значение равное 252,
    а не 249. Это означает, что и здесь есть
    &quot;невидимые&quot; маршрутизаторы, которые
    некорректно обработали UDP датаграмму, однако они
    корректно уменьшили TTL и вернули ICMP сообщение. </small><p><small>Необходимо
    достаточно внимательно просматривать исходящий
    TTL, так как иногда значение отличается от
    ожидаемого. Это может объясняться тем, что ICMP
    сообщение возвращается по другому пути, нежели
    ушла исходящая UDP датаграмма. В этом примере,
    однако, существуют именно &quot;невидимые&quot;
    маршрутизаторы, которые traceroute не нашла при
    использовании <a NAME="t340030"></a>опции свободной
    маршрутизации от источника.</small></p>
  </li>
  <li><small>Клиент ping устанавливает в поле
    идентификатора в ICMP эхо запросе (<a HREF="tcp07.html#t072001">рисунок
    7.1</a>) свой идентификатор процесса. ICMP эхо отклик
    содержит это поле идентификатора. Каждый клиент
    просматривает возвращенное поле идентификатора
    и обрабатывает только те, которые он послал. </small><p><small>Клиент
    traceroute устанавливает номер порта источника UDP в
    логическое ИЛИ со своим идентификатором
    процесса и 32768. Так как возвращенное ICMP сообщение
    всегда содержит первые 8 байт IP датаграммы, на
    которую сгенерирована ошибка (<a HREF="tcp06.html#t065005">рисунок
    6.9</a>), что включает целиком UDP заголовок, этот
    номер порта источника возвращается в ICMP ошибке.</small></p>
  </li>
  <li><small>Клиент ping помещает в необязательную часть
    данных ICMP эхо запроса время, когда был отправлен
    пакет. Эти необязательные данные должны быть
    возвращены в ICMP эхо отклике. Это позволяет ping
    рассчитать точное время возврата, даже если
    пакеты пришли в беспорядке. </small><p><small>Клиент
    traceroute не может поступить подобным образом,
    потому что все, что возвращается в ICMP ошибке, - это
    UDP заголовок (<a HREF="tcp06.html#t065005">рисунок 6.9</a>), а не UDP
    данные. Таким образом, traceroute должна помнить,
    когда она посылает запрос, дождаться отклика и
    рассчитать разницу во времени. </small></p>
    <p><small>Это иллюстрирует еще одно различие между Ping
    и Traceroute: Ping отправляет один пакет в секунду, вне
    зависимости от того, получены ли какие-либо
    отклики, тогда как Traceroute отправляет запрос и
    затем ожидает, придет ли отклик или будет
    отработан тайм-аут перед отправкой следующего
    запроса.</small></p>
  </li>
  <li><small>Так как <a NAME="t340031"></a>Solaris 2.2 стартует на
    динамически назначаемом UDP порте с номером
    равным 32768 по умолчанию, существует значительно
    большая вероятность того, что будет занят порт
    назначения на хосте назначения.</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp09.html">Глава 9</a></small>

<ol>
  <li><small>Когда впервые был разработан стандарт ICMP, RFC
    792 [<a NAME="t340032"></a>Postel 1981b], разделение на подсети не
    использовалось. Также, использование
    перенаправления в одну сеть вместо
    перенаправления на N хостов (для всех N хостов,
    находящихся в сети назначения) сохраняет
    некоторое пространство в таблице маршрутизации.</small></li>
  <li><small>Эта запись не требуется, однако если она
    удалена, все IP датаграммы, предназначенные slip,
    посылаются на маршрутизатор по умолчанию (sun),
    который затем перенаправляет их на
    маршрутизатор bsdi. Так как sun перенаправляет
    датаграммы по тому же интерфейсу, по которому они
    были получены, он отправляет <a NAME="t340033"></a>ICMP
    перенаправление хосту svr4. При этом создается та
    же самая запись в таблице маршрутизации хоста svr4,
    которая была удалена, однако в этот раз она
    создается путем перенаправления, вместо того
    чтобы создаваться в момент загрузки машины.</small></li>
  <li><small>Когда хост <a NAME="t340034"></a>4.2BSD получает
    датаграмму, предназначаемую для 140.1.255.255, он
    определяет, что у него есть маршрут к сети (140.1),
    поэтому он старается направить датаграмму. Чтобы
    сделать это, он посылает широковещательный
    запрос ARP в поисках 140.1.255.255. Так как на запрос не
    приходит отклик, датаграмма отбрасывается. Если
    на кабеле существует несколько хостов 4.2BSD,
    каждый отправляет этот ARP широковещательный
    запрос в одно и то же время, при этом сеть
    временно становится практически недоступной.</small></li>
  <li><small>В этом случае отклик приходит на каждый ARP
    запрос, где сообщается, что каждому хосту 4.2BSD
    необходимо послать датаграмму на указанный
    аппаратный адрес (широковещательный запрос
    Ethernet). Если существует k хостов 4.2BSD на этом кабеле,
    все получают свой собственный ARP отклик, в
    результате чего, каждый из них генерирует еще
    один широковещательный запрос. Каждый хост
    получает каждую широковещательную IP датаграмму,
    направляемую на 140.1.255.255, а так как каждый хост
    сейчас имеет запись в ARP кэше, датаграмма снова
    направляется на широковещательный адрес. Это
    продолжается и генерирует так называемое <a NAME="t340035"></a>половодье Ethernet (meltdown). [<a NAME="t340036"></a>Manber
    1990] описывает другие формы цепных реакций в
    сетях.</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp10.html">Глава 10</a></small>

<ol>
  <li><small>Тринадцать из этих маршрутов пришли от kpno:
    все, за исключением 140.252.101.0 и 140.252.104.0 - это сети, к
    которым gateway подключен непосредственно.</small></li>
  <li><small>Перед тем как 25 маршрутов, объявленных в
    потерянной датаграмме, будут обновлены пройдет
    шестьдесят секунд. В этом нет никакой проблемы,
    потому что RIP объявляет маршрут умершим только в
    том случае, если в течение 3-х минут не было
    обновлений.</small></li>
  <li><small><a NAME="t340037"></a>RIP работает поверх UDP, а <a NAME="t340038"></a>UDP
    предоставляет необязательную контрольную сумму
    для данных, находящихся в UDP датаграмме (глава 11,
    раздел&nbsp;<a HREF="tcp11.html#t113000">&quot;Контрольная сумма
    UDP&quot;</a>). OSPF, однако, работает поверх IP. <a NAME="t340039"></a>Контрольная
    сумма IP охватывает только IP заголовок, таким
    образом, <a NAME="t340040"></a>OSPF должен добавлять свое
    собственное поле контрольной суммы.</small></li>
  <li><small>Балансировка загруженности уменьшает
    вероятность того, что пакеты будут доставлены в
    беспорядке, что может исказить времена возврата,
    рассчитанные транспортным уровнем.</small></li>
  <li><small>Это называется простым &quot;расщепленным
    горизонтом&quot; (технология расщепленных
    горизонтов основывается на том факте, что
    бессмысленно отправлять информацию о маршрутах
    в том направлении, откуда она пришла).</small></li>
  <li><small>На <a HREF="tcp12.html#t121005">рисунке 12.1</a> мы показали,
    что каждый из ста хостов обрабатывает
    широковещательную UDP датаграмму через драйвер
    устройства, IP уровень и UDP уровень, где она будет
    окончательно отброшена, когда будет обнаружено,
    что UDP порт 520 не обслуживается.</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp11.html">Глава 11</a></small>

<ol>
  <li><small>Так как при использовании инкапсуляции <a NAME="t340041"></a>IEEE 802 в заголовке находится 8
    дополнительных байт, 1465 байт пользовательских
    данных - это наименьший размер, который вызовет
    фрагментацию.</small></li>
  <li><small>Для IP посылается 8200 байт, 8192 байта
    пользовательских данных и 8 байт UDP заголовка.
    Используя форму записи <a NAME="t340042"></a>tcpdump, первый
    фрагмент это 1480@+ (1480 байт данных, смещение 0 и
    установлен бит &quot;дальше следуют еще
    фрагменты&quot;). Второй это 1480@1480+, третий 1480@2960+,
    четвертый 1480@4440+, пятый 1480@5920+ и шестой 800@7400. 1480 x 5 +
    800 = 8200 это количество байт, которые необходимо
    отправить.</small></li>
  <li><small>Каждый фрагмент размером 1480 байт поделен на
    три части: два фрагмента по 528 байт и один
    фрагмент 424 байта. Максимальное число кратное 8,
    меньшее чем 532 (552 - 20), это 528. Фрагмент размером 800
    байт делится на две части: фрагмент размером 528
    байт и фрагмент размером 272 байта. Таким образом,
    из исходной датаграммы размером 8192 байта
    получается 17 фреймов, которые передаются по SLIP
    каналу.</small></li>
  <li><small>Нет. Проблема заключается в том, что когда
    приложение осуществляет тайм-аут и повторную
    передачу, IP датаграмма, сгенерированная при
    повторной передаче, имеет новое поле
    идентификации. Промежуточная сборка
    осуществляется только для фрагментов, которые
    имеют одинаковое поле идентификации.</small></li>
  <li><small><a NAME="t340043"></a>Поле идентификации в IP
    заголовке одно и то же (47942).</small></li>
  <li><small>Во-первых, из <a HREF="tcp11.html#t113010">рисунка 11.4</a> мы
    видим, что у gemini выключен расчет исходящей
    контрольной суммы UDP. Вполне возможно, что
    операционная система на этом хосте (<a NAME="t340044"></a>SunOS
    4.1.1) это одна из тех, что никогда не проверяют
    входящую контрольную сумму UDP, если не включен
    расчет исходящей контрольной суммы UDP. Во-вторых,
    вполне возможно, что большинство UDP траффика это
    локальный траффик, а не траффик по глобальным
    сетям. Поэтому нет необходимости исполнять все
    прихоти свойственные глобальным сетям.</small></li>
  <li><small><a NAME="t340045"></a>Опции свободной и жесткой
    маршрутизации от источника копируются в каждый
    фрагмент. <a NAME="t340046"></a>Опция временной марки и <a NAME="t340047"></a>опция записи маршрута не копируются в
    каждый фрагмент - они присутствуют только в
    первом фрагменте.</small></li>
  <li><small>Нет. Мы видели в разделе <a HREF="tcp11.html#t11C000">&quot;Сервер
    UDP&quot;</a> главы 11, что большинство реализаций могут
    фильтровать входящие датаграммы, направляемые
    на заданный номер порта UDP, на основании IP адреса
    назначения, IP адреса источника и номера порта
    источника.</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp12.html">Глава 12</a></small>

<ol>
  <li><small>Широковещательные запросы сами по себе не
    увеличивают сетевой траффик, однако они требуют
    дополнительной обработки на хостах.
    Широковещательные запросы могут вызвать
    увеличение сетевого траффика, если получающие
    хосты некорректно отвечают с помощью ошибок,
    таких как <a NAME="t340048"></a>ICMP ошибки о недоступности
    порта. Маршрутизаторы обычно не перенаправляют
    широковещательные пакеты, однако их
    перенаправляют <a NAME="t340049"></a>мосты, таким образом,
    широковещательные запросы в сетях, построенных
    на основе мостов, могут уйти значительно дальше,
    чем в сетях, построенных на маршрутизаторах.</small></li>
  <li><small>Каждый хост получает копию каждого
    широковещательного запроса. Интерфейсный
    уровень получает фрейм и передает его в драйвер
    устройства. Если поле типа принадлежит
    какому-либо другому протоколу, драйвер
    устройства отбрасывает фрейм.</small></li>
  <li><small>Сначала исполним <a NAME="t340050"></a>netstat -r, чтобы
    посмотреть таблицу маршрутизации. Она покажет
    имена всех интерфейсов. Затем запустим <a NAME="t340051"></a>ifconfig
    (глава 3, раздел <a HREF="tcp03.html#t038000">&quot;Команда
    ifconfig&quot;</a>) для каждого интерфейса: флаги
    расскажут нам, поддерживает ли интерфейс
    широковещательные запросы, и если да, то в выводе
    также будут показаны широковещательные адреса.</small></li>
  <li><small>Berkeley реализации не позволяют
    фрагментировать широковещательные датаграммы.
    Когда мы указываем длину равную 1472 байта,
    результирующая IP датаграмма будет длиной ровно
    1500 байт, что равно MTU Ethernet. Запрет на фрагментацию
    широковещательных датаграмм это политическое
    решение. Технической причины не существует (а
    именно, никакой другой причины, нежели просто
    уменьшить количество широковещательных
    пакетов).</small></li>
  <li><small>В зависимости от того, поддерживается ли
    групповая рассылка в различных сетевых платах
    Ethernet на 100 хостах, групповая датаграмма может
    быть игнорирована сетевой платой или отброшена
    драйвером устройства.</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp13.html">Глава 13</a></small>

<ol>
  <li><small>Используйте некоторые уникальные значения
    для хоста при генерации случайных значений. IP
    адрес и адрес канального уровня это два значения,
    которые должны отличаться на каждом хосте. Время
    дня это плохой выбор, особенно если все хосты
    используют, например, протокол <a NAME="t340052"></a>NTP для
    синхронизации своих часов.</small></li>
  <li><small>Они добавляют заголовок протокола
    приложения, который включает номер
    последовательности и временную марку.</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp14.html">Глава 14</a></small>

<ol>
  <li><small>Разборщик - это всегда клиент, однако сервер
    имен это и клиент, и сервер.</small></li>
  <li><small>Возвращенный вопрос, он рассчитан для
    первых 44 байт. Единственный ответ занимает
    оставшийся 31 байт: 2-байтный указатель на имя
    домена (указатель на имя домена в вопросе), 10 байт
    на поля фиксированного размера (тип, класс, TTL и
    длина ресурса) и 19 байт для данных ресурса (имя
    домена). Обратите внимание, что имя домена в
    данных ресурса (svr4.tuc.noao.edu.) не делит суффикс с
    именем домена в вопросе (34.13.252.140.in-addr.arpa.), таким
    образом, указатель не может быть использован.</small></li>
  <li><small>Использование обратного порядка означает
    использование, во-первых, DNS, и затем, если это не
    сработает, попытку конвертировать аргумент в
    номер, состоящий из десятичных чисел,
    разделенных точками (форма записи IP адреса). Это
    означает, что каждый раз, когда используется
    адрес в виде десятичных цифр, разделенных
    точками, используется DNS, при этом привлекается DNS
    сервер. На это тратятся дополнительные ресурсы.</small></li>
  <li><small>Раздел 4.2.2 RFC 1035 указывает, что перед
    реальным DNS сообщением должна стоять 2-байтовая
    длина.</small></li>
  <li><small>Когда сервер имен стартует, он обычно читает
    (вполне возможно, устаревший) список <a NAME="t340053"></a>корневых
    серверов из дискового файла. Затем он старается
    установить контакт с одним из этих корневых
    серверов, запрашивая записи сервера имен (тип
    запроса <a NAME="t340054"></a>NS) для корневого домена. При
    этом возвращается текущий список корневых
    серверов. Минимум, что необходимо для этого, это
    чтобы хотя бы одна запись в стартовом файле на
    диске соответствовала текущему положению.</small></li>
  <li><small>Регистрационный сервер <a NAME="t340055"></a>InterNIC
    обновляет корневые сервера три раза в неделю.</small></li>
  <li><small>Разборщик функционирует как приложение;
    если система сконфигурирована таким образом,
    чтобы использовать несколько DNS серверов,
    разборщик не может отслеживать времена возврата
    до различных DNS серверов. Это может привести к
    возникновению тайм-аутов на слишком короткие
    запросы разборщика, при этом будут происходить
    ненужные повторные передачи.</small></li>
  <li><small>Сортировка записей А должна осуществляться
    разборщиком, а не сервером имен, так как
    разборщик обычно знает больше, чем сервер, о
    топологии сети клиента. (Новые релизы <a NAME="t340056"></a>BIND
    предоставляют разборщику возможность
    сортировать А записи.)</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp15.html">Глава 15</a></small>

<ol>
  <li><small>TFTP запросы, посылаемые на широковещательный
    адрес, должны быть игнорированы. Как указывается
    в требованиях к хостам <a NAME="t340057"></a>Host Requirements RFC,
    ответы на широковещательные запросы могут
    создать значительные проблемы в безопасности.
    Проблема, однако, заключается в том, что не все
    реализации и API предоставляют адрес назначения
    для UDP датаграмм для процессов, которые получают
    датаграммы (глава 11, раздел <a HREF="tcp11.html#t11C000">&quot;Сервер
    UDP&quot;</a>). По этой причине многие TFTP серверы не
    следуют этому ограничению.</small></li>
  <li><small>К сожалению, RFC ничего не говорит о подобном
    переходе номера блоков. Реализации должны иметь
    возможность передавать файлы размером до 33553920
    байт (65535 x 512). Большинство реализаций выдают
    ошибку, когда размер файла превышает 16776704 (32767 x
    512), так как они некорректно определяют
    количество блоков в виде 16-битного целого со
    знаком, вместо того чтобы использовать целое без
    знака.</small></li>
  <li><small>Это упрощает реализацию TFTP клиента, что
    позволяет поместить его в ПЗУ, потому что сервер
    является отправителем загрузочных файлов, таким
    образом, сервер должен осуществлять тайм-ауты и
    повторные передачи.</small></li>
  <li><small>Так как TFTP - <a NAME="t340058"></a>протокол с
    остановкой и ожиданием отклика, он может
    передавать максимум 512 байт за одну посылку от
    клиента серверу. Максимальная пропускная
    способность TFTP составляет в таком случае 512 байт,
    поделенных на время возврата между клиентом и
    сервером. В случае Ethernet (представим время
    возврата равное 3 миллисекундам), максимальная
    пропускная способность будет составлять
    примерно 170000 байт в секунду.</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp16.html">Глава 16</a></small>

<ol>
  <li><small>Маршрутизатор должен перенаправлять RARP
    запросы на какой-либо другой хост, находящийся в
    другой сети, подключенной к маршрутизатору,
    однако отправка отклика может вызвать некоторые
    проблемы. Маршрутизатор также должен
    перенаправлять RARP отклики.</small><p><small>BOOTP не имеет
    этих проблем с откликами, так как адрес отклика
    это обычный IP адрес, причем маршрутизатор всегда
    знает, как перенаправить информацию на этот
    адрес. Проблема заключается в том, что RARP
    использует адреса только канального уровня, а
    маршрутизаторы обычно не знают этих значений для
    хостов, находящихся в других, не подключенных
    непосредственно, сетях.</small></p>
  </li>
  <li><small>Он должен использовать свой собственный
    аппаратный адрес, который должен быть уникальным
    и который устанавливается в запросе и
    возвращается в отклике.</small></li>
</ol>


<p><small><a HREF="tcp17.html">Глава 17</a></small>

<ol>
  <li><small>Все обязательные, за исключением <a NAME="t340059"></a>UDP
    контрольной суммы. <a NAME="t340060"></a>Контрольная сумма
    IP охватывает только IP заголовок, тогда как
    остальные захватывают все непосредственно после
    IP заголовка.</small></li>
  <li><small>IP адрес источника, номер порта источника или
    <a NAME="t340061"></a>поле протокола должны быть
    повреждены.</small></li>
  <li><small>Большинство приложений Internet используют
    возврат каретки и пропуск строки, чтобы указать
    на конец каждой записи от приложения. Это
    кодирование <a NAME="t340062"></a>NVT ASCII (глава 26, раздел <a HREF="tcp26.html#t264000">&quot;Протокол Telnet&quot;</a>).
    Альтернативным способом является установка
    префикса перед каждой записью, содержащего
    счетчик байтов, который используется в DNS (<a HREF="tcp04.html#t049001">упражнение 4</a> главы 14) и Sun RPC (глава
    29, раздел <a HREF="tcp29.html#t292000">&quot;Вызов удаленной
    процедуры Sun&quot;</a>).</small></li>
  <li><small>Как мы видели в разделе <a HREF="tcp06.html#t065000">&quot;ICMP
    ошибка недоступности порта&quot;</a> главы 6, ICMP
    ошибка должна вернуть по крайней мере первые 8
    байт, находящиеся позади IP заголовка в IP
    датаграмме, которая вызвала ошибку. Когда TCP
    получает ICMP ошибку, он должен проверить два
    номера порта, чтобы определить какому соединению
    соответствует ошибка, поэтому номер порта должен
    находиться в первых 8 байтах TCP заголовка.</small></li>
  <li><small>Существуют опции, находящиеся в конце TCP
    заголовка, однако в UDP заголовке не существует
    опций.</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp18.html">Глава 18</a></small>

<ol>
  <li><small><a NAME="t340063"></a>ISN это 32-битный счетчик, который
    перескакивает со значения примерно 4294912000 на 8704,
    приблизительно через 9,5 часов после того, как
    система была загружена. По прошествию еще
    примерно 9,5 часов он перескакивает на 17408, затем
    на 26112 еще после 9,5 часов, и так далее. Так как ISN
    стартует с 1, когда система загружается, и так как
    минимальный порядок циклов цифр через 4, 8, 2, 6 и 0,
    ISN всегда должен быть нечетным числом.</small></li>
  <li><small>В первом случае мы использовали нашу
    программу <a NAME="t340064"></a>sock, а она по умолчанию
    передает Unix символ новой строки так, как он есть -
    один <a NAME="t340065"></a>ASCII символ 012 (восьмеричный). Во
    втором случае мы использовали Telnet клиента, а он
    конвертирует Unix символ новой строки в два ASCII
    символа - возврат каретки (восьмеричный 015), за
    которым следует пропуск строки (восьмеричный 012).</small></li>
  <li><small>В случае полузакрытого соединения один
    конец отправляет FIN и ожидает данные или FIN с
    удаленного конца. Полуоткрытое соединение это
    когда один конец вышел из строя, но это
    неизвестно удаленному концу.</small></li>
  <li><small>Соединение может войти в состояние ожидания
    <a NAME="t340066"></a>2MSL только в том случае, если оно уже
    было в состоянии <a NAME="t340067"></a>ESTABLISHED.</small></li>
  <li><small>Во-первых, сервер дневного времени
    осуществляет активное закрытие TCP соединения
    после того, как он выдал дату и время клиенту. Это
    ясно из сообщения, напечатанного нашей
    программой sock: &quot;connection closed by peer&quot; (соединение
    закрыто удаленным концом). Клиент в этом
    соединении прошел через состояние пассивного
    закрытия. Это помещает <a NAME="t340068"></a>пару сокетов в
    состояние <a NAME="t340069"></a>TIME_WAIT на сервере, но не на
    клиенте. Затем, как показано на <a HREF="tcp18.html#t183002">рисунке
    18.6</a>, большинство Berkeley реализаций позволяют
    прибыть новому запросу на соединение на пару
    сокетов, находящуюся в состоянии TIME_WAIT, это как
    раз то, что произошло в данном случае.</small></li>
  <li><small>Сброс посылается в ответ на FIN, потому что FIN
    прибывает для соединения, которое было в
    состоянии <a NAME="t340070"></a>CLOSED.</small></li>
  <li><small>Сторона, которая набирает номер,
    осуществляет активное открытие. Сторона, на
    которой звонит телефон, осуществляет пассивное
    открытие. Одновременное открытие не разрешено,
    однако разрешено одновременное закрытие.</small></li>
  <li><small>Мы бы увидели только ARP запросы, а не TCP
    сегменты SYN, однако ARP запросы имеют то же
    временное расписание, как и на рисунке.</small></li>
  <li><small>Клиент это хост solaris, а сервер это хост bsdi.
    Подтверждение клиента (ACK) на SYN сервера
    комбинируется с первым сегментом данных от
    клиента (строка 3). Это полностью допустимо по
    правилам TCP, однако большинство реализаций так не
    поступают. Затем клиент посылает свой FIN (строка 4)
    не дождавшись ACK на свои данные. Это позволяет
    серверу подтвердить и данные, и FIN в строке 5. Этот
    обмен (отправка одного сегмента данных от
    клиента к серверу) требует 7 сегментов. Обычное
    установление и прекращение соединения (<a HREF="tcp18.html#t186016">рисунок 18.13</a>), вместе с одним
    сегментом данных и его подтверждением, требуют 9
    сегментов.</small></li>
  <li><small>Во-первых, подтверждение сервера (ACK) на FIN
    клиента обычно не задерживается (мы обсуждаем
    задержанные ACK в разделе <a HREF="tcp19.html#t193000">&quot;Задержанные
    подтверждения&quot;</a> главы 19), а отправляется
    сразу же, по прибытию FIN. В этом случае, когда
    приложение получает EOF, оно сообщает своему TCP о
    необходимости закрыть свой конец соединения.
    Во-вторых, сервер, который получил FIN, не должен
    закрывать свой конец соединения по получении FIN
    от клиента. Как мы видели в разделе <a HREF="tcp18.html#t185000">&quot;Наполовину закрытый TCP&quot;</a>
    главы 18, данные все еще могут быть отправлены.</small></li>
  <li><small>Если прибывающий сегмент, на который
    сгенерирован RST, имеет поле ACK, номер
    последовательности RST берется из поле ACK
    прибывшего сегмента. Значение ACK равное 1 в строке
    6 соответствует ISN равному 26368001 в строке 2.</small></li>
  <li><small>См. [<a NAME="t340071"></a>Crowcroft et al. 1992] для получения
    комментариев о создании уровней.</small></li>
  <li><small>Выдается пять запросов. Представьте, что три
    пакета используются для установления
    соединения, один для запроса, один для
    подтверждения (ACK) запроса, один для отклика, один
    для ACK на отклик и четыре для того, чтобы закрыть
    соединение. Это означает, что используется 11
    пакетов на один запрос, то есть всего 55 пакетов.
    При использовании UDP это значение уменьшается до
    10 пакетов. </small><p><small>Оно может быть уменьшено до 10
    пакетов на запрос, если ACK на запрос
    комбинируется с откликом (глава 19, раздел <a HREF="tcp19.html#t193000">&quot;Задержанные подтверждения&quot;</a>).</small></p>
  </li>
  <li><small>Предел составляет примерно 268 соединений в
    секунду: максимальное количество номеров TCP
    порта (65536 - 1024 = 64512, игнорируя заранее известные
    порты) поделенное на продолжительность
    состояния TIME_WAIT <a NAME="t340072"></a>2MSL.</small></li>
  <li><small>Дублированный FIN подтверждается, и
    перестартовывается таймер 2MSL.</small></li>
  <li><small>Получение RST, пока соединение находится в
    состоянии TIME_WAIT, приводит к тому, что это
    состояние преждевременно разрывается. Это
    называется <a NAME="t340073"></a>убийство TIME_WAIT. RFC 1337 [<a NAME="t340074"></a>Braden 1992a] обсуждает это более подробно и
    показывает потенциальные проблемы. Простое
    решение этой проблемы, предложенное в RFC,
    заключается в том, чтобы игнорировать сегменты
    RST, пока соединение находится в состоянии TIME_WAIT.</small></li>
  <li><small>Это когда реализация не поддерживает
    полузакрытое состояние. Если приложение требует,
    чтобы был отправлен FIN, приложение уже не может
    больше читать из соединения.</small></li>
  <li><small>Нет. Входящие сегменты данных <a NAME="t340075"></a>демультиплексируются
    с использованием IP адреса источника, номера
    порта источника, IP адреса назначения и номера
    порта назначения. Для входящих запросов на
    соединение, мы видели в разделе&nbsp;<a HREF="tcp18.html#t18B000">&quot;Реализация TCP сервера&quot;</a>
    главы 18, что TCP сервер обычно может не принять
    соединение, основываясь на IP адресе назначения.</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp19.html">Глава 19</a></small>

<ol>
  <li><small>Две записи приложения, за которыми следует
    чтение, вызывают задержку, потому что, скорее
    всего, используется алгоритм Нагла. Первый
    сегмент (с 8 байтами данных) отправляется, на него
    ожидается ACK перед отправкой 12 байт данных. Если
    сервер поддерживает задержанные ACK, он может
    осуществить задержку до 200 миллисекунд (плюс RTT),
    перед тем как этот ACK будет получен.</small></li>
  <li><small>В случае 5-байтовых <a NAME="t340076"></a>CSLIP
    заголовков (IP и TCP) и 2-х байт данных, RTT по SLIP каналу
    для этих сегментов составит примерно 14,5
    миллисекунды. Это RTT по Ethernet (обычно 5-10
    миллисекунд), к которому необходимо добавить
    время маршрутизации на sun и bsdi. Таким образом,
    приведенное время выглядит вполне
    правдоподобно.</small></li>
  <li><small>На <a HREF="tcp19.html#t194010">рисунке 19.6</a> разница во
    времени между сегментами 6 и 9 составляет
    примерно 533 миллисекунды. На <a HREF="tcp19.html#t194014">рисунке
    19.8</a> разница во времени между сегментами 8 и 12
    составляет 272 миллисекунды. (Мы рассчитали время
    для клавиши F2, а не для клавиши F1, так как первое
    эхо для клавиши F1 на втором рисунке было
    потеряно.)</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp20.html">Глава 20</a></small>

<ol>
  <li><small>Байт с номером 0 это SYN, а байт с номером 8193
    это FIN. SYN и FIN занимают по одному байту в
    пространстве номеров последовательности.</small></li>
  <li><small>Первая запись, которую осуществляет
    приложение, вызывает отправку первого сегмента с
    флагом PUSH. Так как <a NAME="t340077"></a>BSD/386 всегда
    использует медленный старт, она ожидает первый ACK
    перед отправкой остальных данных. В течение
    этого времени приложение осуществляет следующие
    три записи, в это же время в TCP буферы
    записываются данные, которые необходимо
    отправить. Следующие три сегмента не содержат
    флага PUSH, так как в буфере данных достаточно для
    отправки. Здесь к записям приложения начинается
    применяться медленный старт, при этом каждая
    запись приложения вызывает отправку сегмента, а
    так как этот сегмент является последним в буфере,
    устанавливается флаг PUSH.</small></li>
  <li><small><a NAME="t340078"></a>Необходимо определить емкость,
    для чего надо решить уравнения ширины
    пропускания в зависимости от задержки.
    Результаты будут следующими: 1920 байт в первом
    случае и 2062 для спутникового канала. Похоже,
    принимающий TCP объявляет окно равное всего лишь
    2048 байт.</small><p><small>Насытить спутниковый канал
    можно при использовании окна большего, чем 16000
    байт.</small></p>
  </li>
  <li><small>Нет, потому что TCP может <a NAME="t340079"></a>пересобрать
    пакеты данных после тайм-аута, как мы увидим в
    разделе <a HREF="tcp21.html#t21B000">&quot;Пересборка
    пакетов&quot;</a> главы 21.</small></li>
  <li><small>Сегмент 15 это обновление окна, которое
    посылается TCP модулем автоматически, так как
    приложение считало данные, поэтому окно было
    открыто. Это напоминает сегмент 9 на этом же
    рисунке. Появление сегмента 16 вызвано тем, что
    приложение закрыло свой конец соединения.</small></li>
  <li><small>При этом отправитель может направить пакеты
    в сеть с большей скоростью, чем сеть может в
    действительности обработать. Это называется <a NAME="t340080"></a>компрессией ACK или пустым ACK [<a NAME="t340081"></a>Mogul
    1993, Sec. 15.8.13]. Эта ссылка означает, что в Internet
    использовалась компрессия ACK, хотя это редко
    приводит к переполнению.</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp21.html">Глава 21</a></small>

<ol>
  <li><small>Следующий тайм-аут устанавливается в 48
    секунд: 0 + 4 x 12. Коэффициент равный 4 это следующий
    множитель при <a NAME="t340082"></a>экспотенциальном
    наращивании.</small></li>
  <li><small>Похоже, что SVR4 все еще использует
    коэффициент 2D вместо 4D при расчете <a NAME="t340083"></a>RTO.</small></li>
  <li><small><a NAME="t340084"></a>Протокол с остановкой и
    ожиданием подтверждения, который используется в
    TFTP, ограничен отправкой 512 байт данных за время
    возврата. 32768/512 x 1,5 это 96 секунд.</small></li>
  <li><small>Показано четыре сегмента, пронумерованные
    как 1, 2, 3 и 4. Представьте, что они приняты в
    следующем порядке: 1, 3, 2 и 4. Подтверждения,
    сгенерированные получателем, будут ACK 1
    (нормальный ACK), ACK 1 (дублированный ACK, когда принят
    сегмент 3, который пришел не в свое время), ACK 3,
    когда принят сегмент 2 (подтверждающий оба
    сегмента 2 и 3), и затем ACK 4. В этом случае
    сгенерирован один дублированный ACK. Если порядок
    приема будет 1, 3, 4, 2, то будет сгенерировано два
    дублированных ACK.</small></li>
  <li><small>Нет, потому что наклон все еще вправо-вверх,
    а не вниз.</small></li>
  <li><small>См. <a HREF="tcp_e.html#t351001">рисунок E.1</a>.</small></li>
  <li><small>На <a HREF="tcp21.html#t214007">рисунке 21.2</a> сегменты
    содержат 256 байт данных, передача по по <a NAME="t340085"></a>CSLIP
    каналу со скоростью 9600 бит/сек между slip и bsdi,
    занимает примерно 250 миллисекунд. Представим, что
    сегменты данных не были поставлены в очередь
    где-нибудь между bsdi и vangogh, они прибыли на vangogh
    примерно через 250 миллисекунд. Так как это больше
    чем 200 миллисекунд (величина таймера
    задержанного ACK), каждый сегмент подтверждается,
    когда истекает следующий таймер задержанного ACK.</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp22.html">Глава 22</a></small>

<ol>
  <li><small>Подтверждения (ACK), возможно, все задержаны
    на хосте bsdi, потому что нет необходимости
    посылать их немедленно. Именно поэтому
    соответственные времена имеют 0,170 и 0,370 в дробной
    части. Также, похоже на то, что 200-миллисекундный
    таймер на bsdi запущен примерно на 18 миллисекунд
    позже, чем тот же самый таймер на sun.</small></li>
  <li><small>Флаг FIN, так же как флаг SYN, занимает 1 байт в
    пространстве номеров последовательности.
    Объявленное окно будет на 1 байт меньше, потому
    что TCP предоставляет место для 1 байта номера
    последовательности занятого флагом FIN.</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp23.html">Глава 23</a></small>

<ol>
  <li><small>Обычно легче активизировать опцию <a NAME="t340086"></a>&quot;оставайся
    в живых&quot;, нежели пробы из приложения; пробы
    &quot;оставайся в живых&quot; требуют меньшей ширины
    пропускания сети, нежели пробы приложения (так
    как пробы &quot;оставайся в живых&quot; и ответы не
    содержат данных); пробы не посылаются, если
    соединение используется для передачи.</small></li>
  <li><small>Опция &quot;оставайся в живых&quot; может
    привести к тому, что абсолютно нормальное
    соединение будет разорвано, потому что сеть
    временно вышла из строя; интервал между пробами (2
    часа) обычно не конфигурируется с точки зрения
    приложений;</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp24.html">Глава 24</a></small>

<ol>
  <li><small>Это означает, что отправляющий TCP
    поддерживает опцию масштабирования окна, однако
    не нуждается в том, чтобы масштабировать свое
    окно для этого соединения. Удаленная сторона
    (которая получила этот SYN) может затем установить
    коэффициент масштабирования окна (который может
    быть равен 0 или нет).</small></li>
  <li><small>64000: размер <a NAME="t340087"></a>принимающего буфера
    (128000) сдвигается вправо на 1 бит. 55000: размер
    принимающего буфера (220000) сдвигается вправо на 2
    бита.</small></li>
  <li><small>Нет. Проблема заключается в том, что
    подтверждения доставляются ненадежно (за
    исключением тех случаев, когда они двигаются
    вместе с данными), поэтому изменение шкалы,
    находящееся в ACK, может быть потеряно.</small></li>
  <li><small>2<sup>32</sup> x 8 / 120 равно 286 Мбит/сек, что в 2,86 раза
    больше чем скорость данных <a NAME="t340088"></a>FDDI.</small></li>
  <li><small>Каждый TCP должен помнить последнюю
    временную марку, полученную по любому соединению
    от каждого хоста. Прочитайте приложение B.2 в RFC 1323
    для получения более подробной информации.</small></li>
  <li><small>Приложение должно установить размер
    принимающего буфера перед установлением
    соединения с удаленным концом, так как опция
    масштабирования окна посылается в исходном SYN
    сегменте.</small></li>
  <li><small>Если получатель подтверждает каждый второй
    сегмент данных, пропускная способность
    составляет 1118881 байт в секунду. При использовании
    окна размером 62 сегмента, с подтверждением
    каждого 31 сегмента, значение составляет 1158675.</small></li>
  <li><small>Когда опция временной марки отражается эхом
    в ACK, она всегда берется из сегмента, который
    подтверждается. В данном случае нет никакой <a NAME="t340089"></a>двусмысленности по поводу того, какому
    повторно переданному сегменту принадлежит ACK,
    однако другая часть <a NAME="t340090"></a>алгоритма Karnа,
    имеющая отношение к <a NAME="t340091"></a>экспотенциальному
    наращиванию передачи, все еще требуется.</small></li>
  <li><small>Получающий TCP ставит данные в очередь,
    однако они не могут быть переданы приложению до
    тех пор, пока не завершится трехразовое
    рукопожатие: когда получающий TCP переходит в
    состояние <a NAME="t340092"></a>ESTABLISHED.</small></li>
  <li><small>Осуществляется обмен пятью сегментами:</small><ol>
      <li><small>От клиента к серверу: SYN, данные (запрос) и FIN.
        Сервер должен поставить в очередь данные, как
        описано в предыдущем упражнении.</small></li>
      <li><small>От сервера к клиенту: SYN и ACK на SYN клиента. </small></li>
      <li><small>От клиента к серверу: ACK на SYN сервера и FIN
        клиента (снова). Это приводит к тому, что сервер
        переходит в состояние ESTABLISHED, а данные,
        поставленные в очередь с сегмента 1, передаются
        приложению сервера.</small></li>
      <li><small>От сервера к клиенту: ACK на FIN клиента
        (который также подтверждает данные клиента),
        данные (отклик сервера) и FIN сервера. Здесь
        подразумевается, что SPT достаточно короток, чтобы
        позволить этот задержанный ACK. Когда TCP клиент
        получает этот сегмент, отклик передается
        приложению клиента, однако полное время будет
        равно удвоенному RTT плюс SPT.</small></li>
      <li><small>От клиента к серверу: ACK на FIN сервера.</small></li>
    </ol>
  </li>
  <li><small>16128 транзакций в секунду (64512 поделено на 4).</small></li>
  <li><small>Время транзакций, используемое T/TCP, не может
    быть меньше, чем время, необходимое для обмена UDP
    датаграммами между двумя хостами. T/TCP всегда
    работает дольше, так как он еще осуществляет
    обработку состояний, чего не делает UDP.</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp25.html">Глава 25</a></small>

<ol>
  <li><small>Если система запускает и менеджера, и
    агента, это скорее всего разные процессы.
    Менеджер слушает UDP порт 162 на предмет прихода
    ловушек, а агент слушает UDP порт 161 для запросов.
    Если один и тот же порт используется и для
    ловушек, и для запросов, отделить менеджера от
    агента будет достаточно сложно.</small></li>
  <li><small>Обратитесь к разделу &quot;Таблица доступа&quot;
    в разделе <a HREF="tcp25.html#t257000">&quot;Простые примеры&quot;</a>
    главы 25.</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp26.html">Глава 26</a></small>

<ol>
  <li><small>Мы ожидаем, что сегменты 2, 4 и 9 от сервера
    будут задержаны. Разница во времени между
    сегментами 2 и 4 составляет 190,7 миллисекунды, а
    разница во времени между сегментами 2 и 9
    составляет 400,7 миллисекунды.</small><p><small>Все ACK от
    клиента к серверу будут задержаны: сегменты 6, 11,
    13, 15, 17 и 19. Разница во времени последних пяти от
    сегмента 6 составляет 400,0; 600,0; 800,0; 1000,0 и 2600
    миллисекунд.</small></p>
  </li>
  <li><small>Если один конец соединения находится в <a NAME="t340093"></a>режиме срочности TCP, то каждый раз,
    когда сегмент принимается, один отправляется.
    Этот сегмент не сообщает получателю ничего
    нового (он не подтверждает новые данные,
    например) и не содержит данных, а всего лишь
    подтверждает, что соединение находится в срочном
    режиме.</small></li>
  <li><small>Наличие 512 <a NAME="t340094"></a>зарезервированных
    портов (512-1023) ограничивают количество Rlogin
    клиентов. Их может быть не больше 512. В реальной
    жизни значение меньше чем 512, так как некоторые из
    портов в этом диапазоне используются в качестве
    заранее известных портов различными сервисами,
    такими, например, как Rlogin сервер. </small><p><small>Ограничение
    TCP заключается в том, что <a NAME="t340107"></a>пара
    сокетов, выделенная для соединения, должна быть
    уникальной. Так как Rlogin сервер всегда использует
    один и тот же заранее известный порт (513),
    несколько Rlogin клиентов на данном хосте могут
    использовать один и тот же зарезервированный
    порт, только если они подсоединены к различным
    серверам. Клиенты Rlogin, однако, не используют эту
    технику повторного использования
    зарезервированных портов. Если эта техника
    используется, теоретический лимит максимального
    количества соединений составляет 512 Rlogin
    клиентов, в одно и то же время подсоединенных к
    одному и тому же хосту сервера.</small></p>
    <p><small>&nbsp;</small></p>
  </li>
</ol>


<p><small><a HREF="tcp27.html">Глава 27</a></small>

<ol>
  <li><small>Теоретически соединение не может быть
    установлено, пока пара сокетов находится в
    состоянии ожидания <a NAME="t340095"></a>2MSL на каком-либо
    из концов. В действительности, однако, мы видели в
    разделе <a HREF="tcp18.html#t186000">&quot;Диаграмма состояний
    передачи TCP&quot;</a> главы 18, что большинство Berkeley
    реализаций принимают все-таки новый SYN для
    соединения, находящегося в состоянии <a NAME="t340096"></a>TIME_WAIT.</small></li>
  <li><small>Эти строки не являются частью отклика
    сервера, который всегда начинается с 3-циферного
    кода отклика.</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp28.html">Глава 28</a></small>

<ol>
  <li><small><a NAME="t340097"></a>domain literal это IP адрес в виде
    десятичных цифр, разделенных точками, внутри
    квадратных скобок. Например: mail rstevens@ [140.252.1.54].</small></li>
  <li><small>Шесть: команда HELO, MAIL, RCPT, DATA, тело сообщения и
    QUIT.</small></li>
  <li><small>Это вполне законно и называется pipelining [<a NAME="t340098"></a>Rose 1993, Sec. 4.4.4]. К сожалению, существуют
    &quot;сумасшедшие&quot; реализации SMTP, которые
    очищают свой входной буфер после обработки
    каждой команды, из-за чего подобная техника не
    работает. Если эта техника используется, клиент
    не может отбросить сообщение до тех пор, пока все
    отклики не будут проверены на предмет того, что
    сообщение было принято сервером.</small></li>
  <li><small>Рассмотрим первые пять сетевых обменов из
    упражнения 28.2. Каждый является маленькой
    командой (возможно, одним сегментом), который
    совсем немножко загружает сеть. Если все пять
    пройдут на сервер без повторных передач, окно
    переполнения должно быть равно шести сегментам,
    когда отправляется тело. Если тело большое,
    клиент может послать первые шесть сегментов за
    раз, что сеть, может быть, не сможет обработать.</small></li>
  <li><small>Новые реализации <a NAME="t340099"></a>BIND смешивают MX
    записи с тем же самым значением, что и форма
    балансировки загрузки.</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp29.html">Глава 29</a></small>

<ol>
  <li><small>Нет, потому что <a NAME="t340100"></a>tcpdump не может
    отличить RPC запрос или отклик от любой другой UDP
    датаграммы. Единственное случай, когда
    интерпретируется содержание UDP датаграммы как NFS
    пакет, это когда номер порта источника или
    назначения равен 2049. Случайные RPC запросы и
    отклики могут использовать номер динамически
    назначаемого порта на каждом конце.</small></li>
  <li><small>Из раздела <a HREF="tcp01.html#t019000">&quot;Номера
    портов&quot;</a> главы 1 известно, что процесс должен
    иметь привилегии суперпользователя, чтобы
    назначить самому себе номер порта меньше чем 1024
    (заранее известный порт). Несмотря на то, что это
    нормально для серверов, запускаемых системой,
    таких как Telnet сервер, FTP сервер и Port Mapper сервер,
    нет необходимости использовать это ограничение
    для всех RPC серверов.</small></li>
  <li><small>Две концепции, заложенные в этом примере,
    заключаются в том, что клиент игнорирует любые
    отклики от сервера, которые не имеют <a NAME="t340101"></a>XID,
    ожидаемые клиентом, а UDP ставит в очередь
    полученные датаграммы (до определенного предела)
    до тех пор, пока приложение считывает эти
    датаграммы. XID не изменяются при <a NAME="t340102"></a>тайм-аутах
    и повторных передачах, они изменяются только
    когда вызывается еще одна процедура сервера.</small><p><small>События,
    осуществляемые stubом клиента, следующие: момент
    времени 0: отправка запроса 1; момент времени 4:
    тайм-аут и повторная передача запроса 1; момент
    времени 5: получение отклика 1 от сервера,
    возвращение отклика приложению; момент времени 5:
    отправка запроса 2; момент времени 9: тайм-аут и
    повторная передача запроса 2; момент времени 10:
    получение отклика 1 от сервера, однако он
    игнорируется, так как мы ожидаем отклик 2; момент
    времени 11: получение отклика 2 от сервера,
    возвращение отклика приложению.</small></p>
    <p><small>События на сервере следующие: момент
    времени 0: получение запроса 1, начало операции;
    момент времени 5: отправка отклика 1; момент
    времени 5: получение запроса 1 (от повторной
    передачи клиента в момент времени 4), начало
    операции; момент времени 10: отправка отклика 1;
    момент времени 10: получение запроса 2 (от передачи
    клиента в момент времени 5), начало операции;
    момент времени 11: отправка отклика 2; момент
    времени 11: получение запроса 2 (от повторной
    передачи клиента в момент времени 9), начало
    операции; момент времени 12: отправка отклика 2.
    Этот последний отклик сервера просто поставлен
    клиентским UDP в очередь для следующего приема,
    осуществляемого клиентом. Когда клиент
    считывает его, XID будет неверен, и клиент его
    проигнорирует.</small></p>
  </li>
  <li><small>Замена сетевой платы Ethernet меняет физический
    адрес сервера. Даже несмотря на то, что мы видели
    в разделе <a HREF="tcp04.html#t047000">&quot;Беспричинный ARP&quot;</a>
    главы 4, что SVR4 не посылает &quot;беспричинный&quot; ARP
    при загрузке, он все равно должен отправить ARP
    запрос, чтобы узнать физический адрес sun, перед
    тем как сможет отправить отклик на его NFS запросы.
    Так как sun уже имеет ARP запись для svr4, он обновит
    эту запись новым аппаратным адресом сервера из ARP
    запроса.</small></li>
  <li><small>Второй блок демона ввода-вывода клиента
    (считывание со смещением 73728) не синхронизирован
    с первым примерно на 0,74 секунды. Таким образом,
    второй демон отработает тайм-аут размером 0,74
    секунды после первого в строках 131-145. Сервер
    никогда видел запрос в строке 167, однако увидел
    запрос в строке 168. Второй блок демона
    ввода-вывода не будет передан до тех пор, пока не
    пройдет 0,74 секунды после строки 168, и в это
    определенное время первый блок демона
    ввода-вывода продолжает выдавать запросы.</small></li>
  <li><small>Если используется TCP, и TCP сегмент,
    содержащий отклик от сервера, потерян в сети, TCP
    модуль сервера осуществит тайм-аут и повторную
    передачу отклика, когда он не получит ACK от TCP
    модуля клиента. Возможно, сегмент прибудет в
    клиентскую часть TCP. Отличие здесь в том, что два
    TCP модуля осуществляют тайм-аут и повторную
    передачу, а не NFS клиент и сервер. (Когда
    используется UDP, NFS клиент осуществляет тайм-аут и
    повторную передачу.) Тем не менее, NFS клиент
    никогда не знает, что отклик был потерян и должен
    быть повторно передан.</small></li>
  <li><small>NFS сервера может получить другой номер порта
    после перезагрузки. Это может запутать клиента,
    потому что он должен знать, что сервер вышел из
    строя, установить контакт с преобразователем
    портов сервера после перезагрузки, чтобы найти
    новый номер порта NFS сервера.</small><p><small>Подобное,
    когда сервер выходит из строя и перезагружается,
    а приложение RPC сервера получает новый
    динамически назначаемый порт, может возникнуть с
    любым RPC приложением, которое не использует
    заранее известный порт.</small></p>
  </li>
  <li><small>Нет. NFS клиент может повторно использовать
    тот же самый локальный <a NAME="t340103"></a>зарезервированный
    номер порта для различных серверов. TCP требует,
    чтобы локальный IP адрес, локальный порт,
    удаленный IP адрес и удаленный порт были
    уникальными, а удаленный IP адрес отличаться от
    каждого хоста сервера.</small></li>
</ol>

<p><small>&nbsp;</small></p>


<p><small><a HREF="tcp30.html">Глава 30</a></small>

<ol>
  <li><small>Напечатайте <a NAME="t340104"></a>whois &quot;net 88&quot;.
    Идентификаторы сети класса А 64-95
    зарезервированы.</small></li>
  <li><small>Напечатайте whois whitehouse-dom. И команда <a NAME="t340105"></a>host,
    и <a NAME="t340106"></a>nslookup могут запросить DNS.</small></li>
  <li><small>Нет, xscope можно запустить на другом хосте (не
    на сервере). Если хосты разные, xscope может
    использовать TCP порт 6000 для входящих соединений.</small></li>
</ol>

<hr>

</body>
</html>

<html>

<head>
<title>FTP: протокол передачи файлов</title>

<meta http-equiv="Content-type" content="text/html; charset=koi8-r">
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>


<b>

<p><a NAME="t270000"></a>Глава 27 FTP: протокол передачи файлов</p>
<u>

<p><a NAME="t271000"></a>Введение</p>
</u></b>

<p><small><a NAME="t271001"></a>FTP это еще одно широко
используемое приложение. Оно является
стандартом Internet для передачи файлов. Необходимо
различать передачу файлов, именно то, что
предоставляет FTP, и доступ к файлам, что
предоставляется такими приложениями как NFS (<a HREF="tcp29.htm">Network File System</a>, <a HREF="tcp29.html">глава 29</a>).
Передача файлов заключается в копировании
целого файла из одной системы в другую. Чтобы
использовать FTP, необходимо иметь открытый
бюджет на сервере, или можно воспользоваться так
называемым анонимным FTP (anonymous FTP). </small></p>

<p><small>Как и Telnet, FTP был создан для того, чтобы
работать между хостами работающими под
управлением различных операционных систем,
использующих различные структуры файлов и,
возможно, различные наборы символов. Telnet, однако,
обеспечивает связь между разнородными
системами, заставляя каждого участника
соединения работать с одним и тем же стандартом:
NVT, использующий 7-битный <a NAME="t271002"></a>ASCII. FTP
сглаживает различия между системами с
использованием другого подхода. FTP поддерживает
ограниченное количество типов файлов (ASCII,
двоичное и так далее) и структуру файлов (поток
байтов или ориентированный на запись). </small></p>

<p><small>RFC 959 [Postel and <a NAME="t271003"></a>Reynolds 1985] является
официальной спецификацией FTP. Этот RFC описывает
историю и развитиие передачи файлов в течение
времени.</small></p>
<u><b>

<p><a NAME="t272000"></a>Протокол FTP</p>
</b></u>

<p><small>FTP отличается от других приложений тем, что
он использует два TCP соединения для передачи
файла.</small> 

<ol>
  <li><small><a NAME="t272001"></a>Управляющее соединение
    устанавливается как обычное соединение
    клиент-сервер. Сервер осуществляет пассивное
    открытие на заранее известный порт FTP (21) и
    ожидает запроса на соединение от клиента. Клиент
    осуществляет активное открытие на TCP порт 21,
    чтобы установить управляющее соединение.
    Управляющее соединение существует все время,
    пока клиент общается с сервером. Это соединение
    используется для передачи команд от клиента к
    серверу и для передачи откликов от сервера. <a NAME="t272002"></a>Тип IP сервиса для управляющего
    соединения устанавливается для получения
    &quot;минимальной задержки&quot;, так как команды
    обычно вводятся пользователем (рисунок 3.2).</small></li>
  <li><small><a NAME="t272003"></a>Соединение данных открывается
    каждый раз, когда осуществляется передача файла
    между клиентом и сервером. (Оно также открывается
    и в другие моменты, как мы увидим позже.) Тип
    сервиса IP для соединения данных должен быть
    &quot;максимальная пропускная способность&quot;, так
    как это соединение используется для передачи
    файлов.</small></li>
</ol>

<p><small>На рисунке 27.1 показано общение клиента и
сервера по двум соединениям.<a NAME="t272004"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t27_1000.jpg" WIDTH="548" HEIGHT="264"></small></p>


<p ALIGN="CENTER"><small>Рисунок 27.1 Процессы, участвующие в
передаче файлов.</small></p>

<p>&nbsp;</p>

<p><small>Из рисунка видно, что интерактивный
пользователь обычно не видит команды и отклики,
которые передаются по управляющему соединению.
Эти детали оставлены двум интерпретаторам
протокола. Квадратик, помеченный как
&quot;пользовательский интерфейс&quot;, это именно то,
что видит интерактивный пользователь
(полноэкранный интерфейс, основанный на меню,
командные строки и так далее). Интерфейс
конвертирует ввод пользователя в FTP команды,
которые отправляются по управляющему
соединению. Отклики, возвращаемые сервером по
управляющему соединению, конвертируются в
формат, удобный для пользователя. </small></p>

<p><small>Обратите внимание на то, что существуют два
интерпретатора протокола, которые по
необходимости используют две функции передачи
данных.</small></p>
<i><b>

<p><a NAME="t272005"></a>Представление данных</p>
</b></i>

<p><small>Протокол FTP предоставляет различные
способы управления передачей и хранения файлов.
Необходимо сделать выбор по четырем пунктам.</small>

<ol>
  <li><small>Тип файла.</small></li>
  <dl>
    <p><small>(а)</small></p>
    <dd><small><a NAME="t272007"></a>ASCII файлы.<br>
      (По умолчанию) Текстовый файл передается по
      соединению данных как <a NAME="t272008"></a>NVT ASCII. При этом
      требуется, чтобы отправитель конвертировал
      локальный текстовый файл в NVT ASCII, а получатель
      конвертировал NVT ASCII в текстовый файл. Конец
      каждой строки передается в виде NVT ASCII символа
      возврата каретки, после чего следует перевод
      строки. Это означает, что получатель должен
      просматривать каждый байт в поисках пары
      символов CR, LF. (Мы видели тот же сценарий в случае
      передачи ASCII файла с помощью TFTP в разделе <a HREF="tcp15.html#t152000">&quot;Протокол&quot;</a> главы 15.)</small></dd>
    <p><small>(b)</small></p>
    <dd><small>EBCDIC файлы.<br>
      Альтернативный способ передачи текстовых
      файлов, когда на обоих концах системы EBCDIC.</small></dd>
    <p><small>(c)</small></p>
    <dd><small>Двоичные или бинарные файлы. (Image.)<br>
      Данные передаются как непрерывный поток битов.</small></dd>
    <p><small>(d)</small></p>
    <dd><small>Локальный тип файлов.<br>
      Способ передачи бинарных файлов между хостами,
      которые имеют различный размер байта. Количество
      битов в байте определяется отправителем. Для
      систем, которые используют 8-битные байты,
      локальный тип файла с размером байта равным 8
      эквивалентен бинарному типу файла.</small></dd>
  </dl>
  <p>&nbsp;</p>
  <li><small><a NAME="t272009"></a>Управление форматом.
    Применяется только для ASCII и EBCDIC файлов.</small></li>
  <dl>
    <p><small>(a)</small></p>
    <dd><small>Nonprint. (По умолчанию)<br>
      Файл не содержит информацию вертикального
      формата.</small></dd>
    <p><small>(b)</small></p>
    <dd><small>Telnet format control. <br>
      Файл содержит управляющие символы вертикального
      формата Telnet, которые интерпретируются принтером.</small></dd>
    <p><small>(c)</small></p>
    <dd><small>Fortran carriage control. <br>
      Первый символ каждой строки это Fortran символ
      управления формата.</small></dd>
  </dl>
  <p>&nbsp;</p>
  <li><small><a NAME="t272010"></a>Структура. </small><dl>
      <p><small>(a)</small></p>
      <dd><small>Структура файла.<br>
        (По умолчанию) Файл воспринимается в виде
        непрерывного потока байтов. Файл не имеет
        внутренней структуры.</small></dd>
      <p><small>(b)</small></p>
      <dd><small>Структура записи.<br>
        Эта структура используется только в случае
        текстовых файлов (ASCII или EBCDIC).</small></dd>
      <p><small>(c)</small></p>
      <dd><small>Структура страницы.<br>
        Каждая страница передается с номером страницы,
        что позволяет получателю хранить страницы в
        случайном порядке. Предоставляется операционной
        системой TOPS-20. (Требование к хостам <a NAME="t272011"></a>Host
        Requirements RFC не рекомендует использовать эту
        структуру.)</small></dd>
    </dl>
    <p>&nbsp;</p>
  </li>
  <li><small><a NAME="t272012"></a>Режим передачи. Указывает на то,
    как файл передается по соединению данных. </small><dl>
      <p><small>(a)</small></p>
      <dd><small>Режим потока. <br>
        (По умолчанию) Файл передается как поток байтов.
        Для файловой структуры конец файла указывает на
        то, что отправитель закрывает соединение данных.
        Для структуры записи специальная 2-байтовая
        последовательность обозначает конец записи и
        конец файла.</small></dd>
      <p><small>(b)</small></p>
      <dd><small>Режим блоков. <br>
        Файл передается как последовательность блоков,
        перед каждым из них стоит один или несколько байт
        заголовков.</small></dd>
      <p><small>(c)</small></p>
      <dd><small>Сжатый режим. <br>
        Простое кодирование неоднократно встречающихся
        повторяющихся байт. В текстовых файлах обычно
        сжимаются пустые строки или строки из пробелов, а
        в бинарных строки из нулевых байт. (Этот режим
        поддерживается редко. Существуют более
        оптимальные способы сжатия файлов для FTP.)</small></dd>
    </dl>
  </li>
</ol>

<p>&nbsp;</p>

<p><small>Если посчитать количество комбинаций из
приведенных вариантов, то получится 72 способа
передачи и хранения файла. К счастью, можно
игнорировать многие из этих опций, потому что они
не поддерживаются в большинстве реализаций. </small></p>

<p><small>Самые распространенные Unix реализации FTP
клиента и сервера предоставляют следующий выбор:</small>

<ul>
  <li><small>Тип: <a NAME="t272013"></a>ASCII или двоичный. </small></li>
  <li><small>Управление форматом: только nonprint. </small></li>
  <li><small>Структура: только файловая структура. </small></li>
  <li><small>Режим передачи: только потоковый режим.</small></li>
</ul>

<p><small>Это ограничивает нас одним из двух режимов:
ASCII или двоичный.</small></p>

<p>&nbsp;</p>


<p>Подобная реализация
отвечает минимальным требованиям к хостам <a NAME="t272014"></a>Host Requirements RFC. (RFC также требует
обеспечить поддержку для структуры записи,
однако только если операционная система
поддерживает это, а Unix, как правило, не
поддерживает.)</p>

<p>Большинство не-Unix реализаций
предоставляет FTP возможности, которые позволяют
обрабатывать их собственные форматы файлов.
Требование к хостам Host Requirements RFC говорит:
&quot;Протокол FTP включает множество характеристик,
некоторые из которых распространены не очень
широко. Однако, для каждой характеристики в FTP
существует по меньшей мере одна реализация.&quot;</p>


<p>&nbsp;</p>
<i><b>

<p><a NAME="t272015"></a>Команды FTP</p>
</b></i>

<p><small>Команды и отклики передаются по
управляющему соединению между клиентом и
сервером в формате <a NAME="t272016"></a>NVT ASCII. В конце
каждой строки команды или отклика присутствует
пара CR, LF. </small></p>

<p><small>Единственные команды Telnet (начинающиеся с
IAC), которые могут быть отправлены клиентом
серверу - это команда прерывания процесса (&lt;IAC,
IP&gt;) и Telnet сигнал синхронизации (&lt;IAC, DM&gt; в режиме
срочности). Мы увидим, что эти две команды Telnet
используются для прекращения передачи файла или
для того, чтобы отправить серверу запрос в
процессе передачи. Если сервер получает от
клиента команду с Telnet опцией (WILL, WONT, DO или DONT), он
отвечает либо DONT, либо WONT. </small></p>

<p><small>Команды состоят из 3 или 4 байт, а именно из
заглавных ASCII символов, некоторые с
необязательными аргументами. Клиент может
отправить серверу более чем 30 различных FTP
команд. На рисунке 27.2 показаны некоторые
наиболее широко используемые команды,
большинство из которых мы рассмотрим в этой
главе.<a NAME="t272017"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="838">
  <tr>
    <td WIDTH="30%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Команда</small></td>
    <td WIDTH="70%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Описание</small></td>
  </tr>
  <tr>
    <td WIDTH="30%" VALIGN="TOP"><small>ABOR</small></td>
    <td WIDTH="70%" VALIGN="TOP"><small>прервать
    предыдущую команду FTP и любую передачу данных</small></td>
  </tr>
  <tr>
    <td WIDTH="30%" VALIGN="TOP"><small>LIST список файлов</small></td>
    <td WIDTH="70%" VALIGN="TOP"><small>список файлов или
    директорий</small></td>
  </tr>
  <tr>
    <td WIDTH="30%" VALIGN="TOP"><small>PASS пароль</small></td>
    <td WIDTH="70%" VALIGN="TOP"><small>пароль на сервере</small></td>
  </tr>
  <tr>
    <td WIDTH="30%" VALIGN="TOP"><small>PORT n1,n2,n3,n4,n5,n6</small></td>
    <td WIDTH="70%" VALIGN="TOP"><small>IP адрес клиента
    (n1.n2.n3.n4) и порт (n5 x 256 + n6)</small></td>
  </tr>
  <tr>
    <td WIDTH="30%" VALIGN="TOP"><small>QUIT</small></td>
    <td WIDTH="70%" VALIGN="TOP"><small>закрыть бюджет на
    сервере</small></td>
  </tr>
  <tr>
    <td WIDTH="30%" VALIGN="TOP"><small>RETR имя файла</small></td>
    <td WIDTH="70%" VALIGN="TOP"><small>получить (get) файл</small></td>
  </tr>
  <tr>
    <td WIDTH="30%" VALIGN="TOP"><small>STOR имя файла</small></td>
    <td WIDTH="70%" VALIGN="TOP"><small>положить (put) файл</small></td>
  </tr>
  <tr>
    <td WIDTH="30%" VALIGN="TOP"><small>SYST</small></td>
    <td WIDTH="70%" VALIGN="TOP"><small>сервер возвращает
    тип системы</small></td>
  </tr>
  <tr>
    <td WIDTH="30%" VALIGN="TOP"><small>TYPE тип</small></td>
    <td WIDTH="70%" VALIGN="TOP"><small>указать тип файла: A
    для ASCII, I для двоичного</small></td>
  </tr>
  <tr>
    <td WIDTH="30%" VALIGN="TOP"><small>USER имя
    пользователя</small></td>
    <td WIDTH="70%" VALIGN="TOP"><small>имя пользователя
    на сервере</small></td>
  </tr>
</table>


<p><small>Рисунок 27.2 Распространенные FTP команды.</small></p>

<p>&nbsp;</p>

<p><small>В примерах мы увидим, что некоторые команды
полностью совпадают с тем, что вводит
интерактивный пользователь в качестве FTP команд.
В этом случае они передаются по управляющему
соединению, однако некоторые вводимые
пользователем команды генерируют несколько FTP
команд, которые, которые в свою очередь,
передаются по управляющему соединению.</small></p>
<i><b>

<p><a NAME="t272018"></a>FTP отклики</p>
</b></i>

<p><small>Отклики состоят из 3-циферных значений в
формате ASCII, и необязательных сообщений, которые
следуют за числами. Подобное представление
откликов объясняется тем, что программному
обеспечению необходимо посмотреть только
цифровые значения, чтобы понять, что ответил
процесс, а дополнительную строку может прочитать
человек. Поэтому пользователю достаточно просто
прочитать сообщение (причем нет необходимости
запоминать все цифровые коды откликов). </small></p>

<p><small>Каждая из трех цифр в коде отклика имеет
собственный смысл. (В <a HREF="tcp28.html">главе 28</a> мы
увидим, что протокол передачи почтовых сообщений
- SMTP, использует те же соглашения для своих команд
и откликов.) На рисунке 27.3 показаны значения
первых и вторых цифр в коде отклика.<a NAME="t272019"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="715">
  <tr>
    <td WIDTH="12%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Отклик</small></td>
    <td WIDTH="88%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Описание</small></td>
  </tr>
  <tr>
    <td WIDTH="12%" VALIGN="TOP"><small>1yz</small></td>
    <td WIDTH="88%" VALIGN="TOP"><small>Положительный
    предварительный отклик. Действие началось,
    однако необходимо дождаться еще одного отклика
    перед отправкой следующей команды.</small></td>
  </tr>
  <tr>
    <td WIDTH="12%" VALIGN="TOP"><small>2yz</small></td>
    <td WIDTH="88%" VALIGN="TOP"><small>Положительный
    отклик о завершении. Может быть отправлена новая
    команда.</small></td>
  </tr>
  <tr>
    <td WIDTH="12%" VALIGN="TOP"><small>3yz</small></td>
    <td WIDTH="88%" VALIGN="TOP"><small>Положительный
    промежуточный отклик. Команда принята, однако
    необходимо отправить еще одну команду.</small></td>
  </tr>
  <tr>
    <td WIDTH="12%" VALIGN="TOP"><small>4yz</small></td>
    <td WIDTH="88%" VALIGN="TOP"><small>Временный
    отрицательный отклик о завершении. Требуемое
    действие не произошло, однако ошибка временная,
    поэтому команду необходимо повторить позже.</small></td>
  </tr>
  <tr>
    <td WIDTH="12%" VALIGN="TOP"><small>5yz</small></td>
    <td WIDTH="88%" VALIGN="TOP"><small>Постоянный
    отрицательный отклик о завершении. Команда не
    была воспринята и повторять ее не стоит.</small></td>
  </tr>
  <tr>
    <td WIDTH="12%" VALIGN="TOP"><small>x0z</small></td>
    <td WIDTH="88%" VALIGN="TOP"><small>Синтаксическая
    ошибка.</small></td>
  </tr>
  <tr>
    <td WIDTH="12%" VALIGN="TOP"><small>x1z</small></td>
    <td WIDTH="88%" VALIGN="TOP"><small>Информация.</small></td>
  </tr>
  <tr>
    <td WIDTH="12%" VALIGN="TOP"><small>x2z</small></td>
    <td WIDTH="88%" VALIGN="TOP"><small>Соединения.
    Отклики имеют отношение либо к управляющему,
    либо к соединению данных.</small></td>
  </tr>
  <tr>
    <td WIDTH="12%" VALIGN="TOP"><small>x3z</small></td>
    <td WIDTH="88%" VALIGN="TOP"><small>Аутентификация и
    бюджет. Отклик имеет отношение к логированию или
    командам, связанным с бюджетом.</small></td>
  </tr>
  <tr>
    <td WIDTH="12%" VALIGN="TOP"><small>x4z</small></td>
    <td WIDTH="88%" VALIGN="TOP"><small>Не определено.</small></td>
  </tr>
  <tr>
    <td WIDTH="12%" VALIGN="TOP"><small>x5z</small></td>
    <td WIDTH="88%" VALIGN="TOP"><small>Состояние файловой
    системы.</small></td>
  </tr>
</table>


<p><small>Рисунок 27.3 Значения первой и второй цифр в
3-циферном коде отклика.</small></p>

<p>&nbsp;</p>

<p><small>Третья цифра дает дополнительное
объяснение сообщению об ошибке. Ниже приведены
некоторые типичные отклики с возможными
объясняющими строками. </small>

<ul>
  <li><small>125 Соединение данных уже открыто; начало
    передачи. </small></li>
  <li><small>200 Команда исполнена. </small></li>
  <li><small>214 Сообщение о помощи (для пользователя). </small></li>
  <li><small>331 Имя пользователя принято, требуется
    пароль. </small></li>
  <li><small>425 Невозможно открыть соединение данных. </small></li>
  <li><small>452 Ошибка записи файла. </small></li>
  <li><small>500 Синтаксическая ошибка (неизвестная
    команда). </small></li>
  <li><small>501 Синтаксическая ошибка (неверные
    аргументы). </small></li>
  <li><small>502 Нереализованный тип MODE.</small></li>
</ul>

<p><small>Обычно каждая FTP команда генерируют отклик
в одну строку. Например, команда QUIT сгенерирует
следующий отклик:</small></p>

<p>&nbsp;</p>


<p>221 Goodbye.</p>


<p>&nbsp;</p>

<p><small>Если необходим отклик в несколько строк,
первая строка содержит дефис вместо пробела
после 3-циферного кода отклика, а последняя
строка содержит тот же самый 3-циферный код
отклика, за которым следует пробел. Например,
команда HELP сгенерирует следующий отклик:</small></p>

<p>&nbsp;</p>


<p><br>
214- The following commands are recognized (* =&gt;'s unimplemented).<br>
&nbsp;&nbsp; USER&nbsp;&nbsp;&nbsp; PORT&nbsp;&nbsp;&nbsp; STOR&nbsp;&nbsp;&nbsp; MSAM*
&nbsp;&nbsp;&nbsp; RNTO&nbsp;&nbsp;&nbsp; NLST&nbsp;&nbsp;&nbsp; MKD
&nbsp;&nbsp;&nbsp;&nbsp; CDUP<br>
&nbsp;&nbsp; PASS&nbsp;&nbsp;&nbsp; PASV&nbsp;&nbsp;&nbsp; APPE&nbsp;&nbsp;&nbsp; MRSQ*
&nbsp;&nbsp;&nbsp; ABOR&nbsp;&nbsp;&nbsp; SITE&nbsp;&nbsp;&nbsp; XMKD
&nbsp;&nbsp;&nbsp; XCUP<br>
&nbsp;&nbsp; ACCT*&nbsp;&nbsp; TYPE&nbsp;&nbsp;&nbsp; MLFL*&nbsp;&nbsp; MRCP*
&nbsp;&nbsp;&nbsp; DELE&nbsp;&nbsp;&nbsp; SYST&nbsp;&nbsp;&nbsp; RMD
&nbsp;&nbsp;&nbsp;&nbsp; STOU<br>
&nbsp;&nbsp; SMNT*&nbsp;&nbsp; STRU&nbsp;&nbsp;&nbsp; MAIL*&nbsp;&nbsp; ALLO
&nbsp;&nbsp;&nbsp;&nbsp; CWD&nbsp;&nbsp;&nbsp;&nbsp; STAT&nbsp;&nbsp;&nbsp; XRMD
&nbsp;&nbsp;&nbsp; SIZE<br>
&nbsp;&nbsp; REIN*&nbsp;&nbsp; MODE&nbsp;&nbsp;&nbsp; MSND*&nbsp;&nbsp; REST
&nbsp;&nbsp;&nbsp;&nbsp; XCWD&nbsp;&nbsp;&nbsp; HELP&nbsp;&nbsp;&nbsp; PWD
&nbsp;&nbsp;&nbsp;&nbsp; MDTM<br>
&nbsp;&nbsp; QUIT&nbsp;&nbsp;&nbsp; RETR&nbsp;&nbsp;&nbsp; MSOM*&nbsp;&nbsp; RNFR
&nbsp;&nbsp;&nbsp;&nbsp; LIST&nbsp;&nbsp;&nbsp; NOOP&nbsp;&nbsp;&nbsp; XPWD<br>
214 Direct comments to ftp-bugs@bsdi.tuc.noao.edu.<br>
</p>


<p>&nbsp;</p>

<p><small>&nbsp;<a NAME="t272020"></a></small><i><b>Управление
соединением</p>
</b></i>

<p><small>Использовать соединение данных можно тремя
способами. </small>

<ol>
  <li><small>Отправка файлов от клиента к серверу.</small></li>
  <li><small>Отправка файлов от сервера к клиенту.</small></li>
  <li><small>Отправка списка файлов или директорий от
    сервера к клиенту.</small></li>
</ol>

<p><small>FTP сервер посылает список файлов по
соединению данных, вместо того чтобы посылать
многострочные отклики по управляющему
соединению. При этом появляется возможность
избежать любых ограничений в строках,
накладывающихся на размер списка директории, и
позволяет просто сохранить список директории в
файле, вместо того чтобы выдавать список на
терминал. </small></p>

<p><small>Мы сказали, что управляющее соединение
остается в активизированном состоянии все время,
пока установлено соединение клиент-сервер,
однако соединение данных может выключаться и
включаться по необходимости. Как выбираются
номера портов для соединения данных, и кто
осуществляет активное открытие, а кто пассивное
открытие? </small></p>

<p><small>Во-первых, как было сказано ранее,
распространенный режим передачи (в случае Unix это
единственный режим передачи) - это потоковый
режим. В этом режиме конец файла обозначает
закрытие соединения данных. Из этого следует, что
для передачи каждого файла или списка директории
требуется новое соединение данных. Обычная
процедура выглядит следующим образом:</small></p>

<p><small>&nbsp;</small> 

<ol>
  <li><small>Создание соединения данных осуществляется
    клиентом, потому что именно клиент выдает
    команды, которые требуют передать данные
    (получить файл, передать файл или список
    директории). </small></li>
  <li><small>Клиент обычно выбирает динамически
    назначаемый номер порта на хосте клиента для
    своего конца соединения данных. Клиент
    осуществляет пассивное открытие с этого порта. </small></li>
  <li><small>Клиент посылает этот номер порта на сервер
    по управляющему соединению с использованием
    команды PORT. </small></li>
  <li><small>Сервер принимает номер порта с управляющего
    соединения и осуществляет активное открытие на
    этот порт хоста клиента. Сервер всегда
    использует порт 20 для соединения данных. </small></li>
</ol>

<p>&nbsp;</p>

<p><small>На рисунке 27.4 показано состояние
соединений, пока осуществляется шаг номер 3. Мы
предполагаем, что динамически назначаемый порт
клиента для управляющего соединения имеет номер
1173, а динамически назначаемый порт клиента для
соединения данных имеет номер 1174. Команда,
посылаемая клиентом - PORT, а ее аргументы это шесть
десятичных цифр в формате ASCII, разделенные
запятыми. Четыре первых числа - это IP адрес
клиента, на который сервер должен осуществить
активное открытие (140.252.13.34 в данном примере), а
следующие два - это 16-битный номер порта. Так как
16-битный номер порта формируется из двух цифр,
его значение в этом примере будет 4 x 256 + 150 = 1174. </small></p>

<p><small>На рисунке 27.5 показано состояние
соединений, когда сервер осуществляет активное
открытие на конец клиента соединения данных.
Конечная точка сервера это порт 20.<a NAME="t272021"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t27_4000.jpg" WIDTH="463" HEIGHT="127"></small></p>


<p ALIGN="CENTER"><small>Рисунок 27.4 Команда PORT, передаваемая
по управляющему соединению FTP.</small></p>


<p ALIGN="CENTER"><small><img SRC="t27_5000.jpg" WIDTH="463" HEIGHT="139"></small></p>


<p ALIGN="CENTER"><small>Рисунок 27.5 FTP сервер осуществляет
активное открытие соединения данных.</small></p>

<p>&nbsp;</p>

<p><small>Сервер всегда осуществляет активное
открытие соединения данных. Обычно сервер также
осуществляет активное закрытие соединения
данных, за исключением тех случаев, когда клиент
отправляет файл на сервер в потоковом режиме,
который требует, чтобы клиент закрыл соединение
(что делается с помощью уведомления сервера о
конце файла). </small></p>

<p><small>Если клиент не выдает команду PORT, сервер
осуществляет активное открытие на тот же самый
номер порта, который использовался клиентом для
управляющего соединения (1173 в данном примере). В
этом случае все работает корректно, так как
номера порта сервера для двух соединений
различны: один 20, другой 21. Тем не менее, в
следующем разделе мы посмотрим, почему
современные реализации не поступают таким
образом.</small></p>
<u><b>

<p><a NAME="t273000"></a>Примеры FTP</p>
</b></u>

<p><small>Сейчас мы рассмотрим некоторые примеры
использования FTP: как осуществляется управление
соединением данных, как передаются текстовые
файлы с использованием <a NAME="t273002"></a>NVT ASCII, как в FTP
используется сигнал синхронизации Telnet для
прекращения процесса передачи. В завершение мы
рассмотрим &quot;анонимный FTP&quot; (anonymous FTP).</small></p>
<i><b>

<p>Управление соединением: динамически
назначаемый порт</p>
</b></i>

<p><small>Давайте, рассмотрим управление FTP
соединением на примере простой FTP сессии, в
течение которой просматривается список файлов
на сервере. Клиент запущен на хосте svr4 с флагом <a NAME="t273003"></a>-d (отладка). При этом печатаются
команды и отклики, которыми происходит обмен по
управляющему соединению. Все строки,
начинающиеся с ---&gt;, отправляются клиентом
серверу, а строки, которые начинаются с 3-циферных
чисел, это отклики от сервера. <a NAME="t273004"></a>Клиенту
выдается приглашение в виде ftp&gt;.</small></p>

<p>&nbsp;</p>


<p><br>
svr4 % <b>ftp -d bsdi </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; опция
-d для отладочного вывода<br>
Connected to bsdi.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; клиент
осуществляет активное открытие управляющего
соединения<br>
220 bsdi FTP server (Version 5.60) ready.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; сервер отвечает,
что он готов<br>
<br>
Name (bsdi:rstevens):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; клиент
спрашивает имя пользователя<br>
<br>
---&gt; USER rstevens
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим
RETURN, поэтому используется имя по умолчанию<br>
331 Password required for rstevens.<br>
<br>
Password:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим
наш пароль; он не отображается эхом<br>
<br>
---&gt; PASS XXXXXXX
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; клиент
передает пароль в виде открытого текста<br>
230 User rstevens logged in.<br>
<br>
ftp&gt; <b>dir hello.c </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; спрашиваем,
находится ли в директории указанный файл<br>
<br>
---&gt; PORT 140,252,13,34,4,150
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; см.
рисунок 27.4<br>
200 PORT command successful.<br>
<br>
---&gt; LIST hello.c<br>
150 Opening ASCII mode data connection for /bin/ls.<br>
<br>
-rw-r--r-- 1 rstevens staff 38 Jul 17 12:47 hello.c<br>
<br>
226 Transfer complete.<br>
<br>
remote: hello.c
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вывод
от клиента<br>
56 bytes received in 0.03 seconds (1.8 Kbytes/s)<br>
<br>
ftp&gt; <b>quit</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; мы
закончили<br>
<br>
---&gt; QUIT<br>
221 Goodbye.<br>
</p>


<p>&nbsp;</p>

<p><small>Когда FTP клиент просит нас ввести имя
пользователя, он выводит имя по умолчанию (наше
имя на хосте клиента). Когда мы нажимаем клавишу
RETURN, отправляется это имя по умолчанию. </small></p>

<p><small>Когда мы спрашиваем, присутствует ли
указанный файл в директории, устанавливается
соединение данных. Этот пример является
продолжением процедуры, показанной на рисунках
27.4 и 27.5. Клиент спрашивает свой TCP модуль о
динамически назначаемом номере порта для своего
конца соединения данных и отправляет этот номер
порта (1174) серверу в виде команды PORT. Мы также
видим, что одна команда, введенная пользователем
(dir) генерирует две FTP команды (PORT и LIST). </small></p>

<p><small>На рисунке 27.6 приведена временная
диаграмма, иллюстрирующая обмен пакетами по
управляющему соединению. (Мы удалили все, что
связано с установлением и прерыванием
управляющего соединения, вместе со всеми
объявлениями размера окна.) На этом рисунке
показано как открывается соединение данных,
используется и затем закрывается. </small></p>

<p><small>Рисунок 27.7 это временная диаграмма для
соединения данных. Времена на этом рисунке
начинаются с того же момента, как и на рисунке 27.6.
Мы удалили все объявления окна, однако оставили
поле типа сервиса, чтобы показать, что соединение
данных использует отличный тип сервиса
(максимальная пропускная способность), нежели
управляющее соединение (минимальная задержка).
(Значения <a NAME="t273005"></a>TOS приведены на рисунке 3.2.) </small></p>

<p><small>На этой временной диаграмме FTP сервер
осуществляет активное открытие соединения
данных с порта 20 (который называется ftp-data) на
номер порта из команды PORT (1174). Также в этом
примере, где сервер выдает информацию в
соединение данных, сервер осуществляет активное
закрытие соединения данных, тем самым сообщая
клиенту, когда список завершен.<a NAME="t273006"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t27_6000.jpg" WIDTH="508" HEIGHT="741"></small></p>


<p ALIGN="CENTER"><small>Рисунок 27.6 Пример управляющего
соединения FTP.</small></p>


<p ALIGN="CENTER"><small><img SRC="t27_7000.jpg" WIDTH="497" HEIGHT="340"></small></p>


<p ALIGN="CENTER"><small>Рисунок 27.7 Пример соединения
данных FTP.</small></p>

<p>&nbsp;</p>
<i><b>

<p>Управление соединением: порт данных по
умолчанию</p>
</b></i>

<p><small>Если клиент не посылает команду PORT на
сервер, чтобы указать номер порта для клиентской
стороны соединения данных, сервер использует тот
же номер порта для соединения данных, который был
использован для управляющего соединения. Это
может вызвать проблемы для клиента, который
использует потоковый режим (который Unix FTP клиенты
и сервера используют всегда), как мы покажем ниже.</small></p>

<p>&nbsp;</p>


<p>Требование к хостам <a NAME="t273007"></a>Host Requirements RFC рекомендует, чтобы FTP
клиент использовал потоковый режим, посылая
команду PORT, чтобы не использовать номер порта по
умолчанию перед каждым использованием
соединения данных.</p>


<p>&nbsp;</p>

<p><small>Давайте снова обратимся к предыдущему
примеру (рисунок 27.6). Что произойдет, если мы
попробуем узнать содержимое другой директории
через несколько секунд после того, как узнали
содержимое первой? Клиент попросит свое ядро
выбрать еще один динамически назначаемый порт
(может быть, с номером 1175), после чего будет
открыто следующее соединение данных между svr4
порт 1175 и bsdi порт 20. Однако на рисунке 27.7 сервер
осуществляет активное закрытие соединения
данных, и мы видели на рисунке 18.6, что сервер не в
состоянии назначить порт 20 для нового соединения
данных, так как считается, что локальный порта
используется предыдущим соединением, пока
находится в состоянии ожидания <a NAME="t273008"></a>2MSL. </small></p>

<p><small>Сервер обходит эту проблему, указывая опцию
<a NAME="t273009"></a>SO_REUSEADDR, которую мы упоминали в
разделе <a HREF="tcp18.html#t186000">&quot;Диаграмма состояний
передачи TCP&quot;</a> главы 18. Это позволяет ему
назначить порт 20 для нового соединения, которое
будет иметь другой номер удаленного порта (1175). В
состоянии ожидания 2MSL находится порт 1174. </small></p>

<p><small>Однако процедура открытия соединения
изменяется, если клиент не пошлет команду PORT,
указывая динамически назначаемый номер порта
клиента. Мы можем смоделировать подобную
ситуацию, исполнив пользовательскую команду
sendport на FTP клиенте. Unix FTP клиенты используют эту
команду, чтобы выключить отправку команд PORT на
сервер перед каждым использованием соединения
данных. </small></p>

<p><small>На рисунке 27.8 показана временная диаграмма
для соединений данных при использовании двух
команд LIST. Управляющее соединение установлено от
порта 1176 на хосте svr4, так что в случае отсутствия
команды PORT клиент и сервер используют тот же
самый номер порта для соединения данных. (Мы
удалили объявления окна и значения типа сервиса.)<a NAME="t273001"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t27_8000.jpg" WIDTH="502" HEIGHT="583"></small></p>


<p ALIGN="CENTER"><small>Рисунок 27.8 Соединение данных для
двух последовательных команд LIST.</small></p>

<p>&nbsp;</p>

<p><small>Последовательность событий в данном случае
следующая.</small></p>

<p><small>&nbsp;</small> 

<ol>
  <li><small>Управляющее соединение устанавливается от
    порта клиента 1176 на порт сервера 21. (Здесь это не
    показано.)</small></li>
  <li><small>Когда клиент осуществляет пассивное
    открытие для соединения данных на порт 1176, он
    должен указать опцию <a NAME="t273010"></a>SO_REUSEADDR, так как
    этот порт уже используется управляющим
    соединением клиента.</small></li>
  <li><small>Сервер осуществляет активное открытие
    соединения данных (сегмент 1) с порта 20 на порт 1176.
    Клиент принимает это (сегмент 2), даже если порт 1176
    уже используется клиентом, потому что две пары
    сокетов</small><p>&nbsp;</p>
    <p>&lt;svr4,
    1176, bsdi, 21&gt;<br>
    &lt;svr4, 1176, bsdi, 20&gt;</p>
    <p>&nbsp;</p>
    <p><small>различны (номер порта на bsdi отличается). TCP <a NAME="t273011"></a>демультиплексирует входящие сегменты,
    просматривая IP адрес источника, номер порта
    источника, IP адрес назначения и номер порта
    назначения, поэтому пока один из четырех
    элементов отличается, все в порядке.</small></p>
  </li>
  <li><small>Сервер осуществляет активное закрытие
    соединения данных (сегмент 5), при этом <a NAME="t273012"></a>пара
    сокетов на сервере</small><p>&nbsp;</p>
    <p>&lt;svr4,
    1176, bsdi, 20&gt;</p>
    <p>&nbsp;</p>
    <p><small>помещается в состояние ожидания <a NAME="t273013"></a>2MSL.</small></p>
  </li>
  <li><small>Клиент отправляет еще одну команду LIST по
    управляющему соединению. (Мы не показали этого.)
    Перед этим клиент осуществляет пассивное
    открытие порта 1176 на своем конце соединения
    данных. Клиент должен указать снова опцию <a NAME="t273014"></a>SO_REUSEADDR, так как номер порта 1176 уже
    используется.</small></li>
  <li><small>Сервер осуществляет активное открытие
    соединения данных с порта 20 на порт 1176. Перед тем
    как сделать это, сервер должен указать SO_REUSEADDR,
    так как локальный порт (20) связан с соединением,
    которое находится в состоянии ожидания 2MSL,
    однако, как мы показали в разделе <a HREF="tcp18.html#t186000">&quot;Диаграмма
    состояний передачи TCP&quot;</a> главы 18, соединение
    открыть не удасться. Дело в том, что пара сокет
    для требуемого соединения эквивалентна паре
    сокет из шага 4, которая все еще находится в
    состоянии ожидания 2MSL. Правила TCP запрещают
    серверу отправить SYN. Для сервера не существует
    способа игнорировать состояние 2MSL для пары
    сокетов, если ему понадобилось повторно
    использовать эту же пару сокетов.</small><p><small>В этом
    месте BSD серверы повторяют попытки установить
    соединение каждые 5 секунд, до 18 раз, что в целом
    составляет 90 секунд. Мы видим, что сегмент 9
    успешно прошел примерно через одну минуту. (Мы
    говорили в <a HREF="tcp18.html">главе 18</a>, что <a NAME="t273015"></a>SVR4
    использует MSL равное 30 секундам, при этом
    получается, что ожидание 2MSL составляет 1 минуту.)
    Мы не увидим ни одного SYN в это время на временной
    диаграмме, потому что активное открытие не
    удалось, и TCP модуль сервера даже не пытается
    посылать SYN.</small></p>
  </li>
</ol>

<p>&nbsp;</p>

<p><small>Причина, по которой требования к хостам <a NAME="t273016"></a>Host Requirements RFC рекомендуют использовать
команду PORT, заключается в том, что эта команда
позволяет обойти состояние ожидания 2MSL между
последовательными использованиями соединения
данных. Так как порты последовательно меняются
на одном конце, проблема, которую мы только что
показали, исчезает сама собой.</small></p>
<i><b>

<p>Передача текстовых файлов: представление NVT ASCII
или двоичное?</p>
</b></i>

<p><small>Давайте убедимся в том, что при передаче
текстовых файлов по умолчанию используется
формат <a NAME="t273017"></a>NVT ASCII. В этот раз мы не будем
использовать флаг -d, поэтому мы не увидим команды
клиента, однако клиент все еще печатает отклики
от сервера:</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>ftp bsdi</b><br>
Connected to bsdi.<br>
220 bsdi FTP server (Version 5.60) ready.<br>
<br>
Name (bsdi:rstevens):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим
RETURN<br>
331 Password required for rstevens.<br>
<br>
Password: вводим пароль<br>
230 User rstevens logged in.<br>
<br>
ftp&gt; <b>get hello.c </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; получаем
файл<br>
200 PORT command successful.<br>
<br>
150 Opening ASCII mode data connection for hello.c (38 bytes).<br>
226 Transfer complete.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; сервер
сообщает, что файл содержит 38 байт<br>
<br>
local: hello.c remote: hello.c
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вывод
от клиента<br>
42 bytes received in 0.0037 seconds (11 Kbytes/s)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 42
байта пришло по соединению данных<br>
<br>
ftp&gt; <b>quit</b><br>
221 Goodbye.<br>
<br>
sun % <b>ls -l hello.c</b><br>
-rw-rw-r-- 1 rstevens 38 Jul 18 08:48 hello.c
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; однако
файл содержит 38 байт<br>
<br>
sun % <b>wc -l hello.c</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; подсчет
строк в файле<br>
4 hello.c<br>
</p>


<p>&nbsp;</p>

<p><small>Сорок два байта было передано по соединению
данных, потому что файл содержит четыре строки.
Каждый Unix символ новой строки (\n) конвертируется
в 2-байтную последовательность NVT ASCII конец строки
(\r\n) сервером для передачи, а затем
конвертируется обратно клиентом при записи на
диск. </small></p>

<p><small>Более новые клиенты стараются определить,
используется ли подобная система на сервере, и
если да, передают файлы в двоичном виде (image тип
файла) вместо <a NAME="t273018"></a>ASCII. Это помогает в двух
случаях.</small> 

<ol>
  <li><small>Отправитель и получатель не должны
    просматривать каждый байт (это большая экономия
    времени и ресурсов). </small></li>
  <li><small>Передается меньше байт, если операционная
    система хоста использует меньше байтов в
    качестве символа конца строки, нежели 2-байтовая
    последовательность NVT ASCII (это меньшая часть
    экономии). </small></li>
</ol>

<p><small>Мы можем увидеть подобную оптимизацию с
использованием <a NAME="t273019"></a>BSD/386 клиента и
сервера. Включен отладочный режим, что позволяет
увидеть команды FTP клиента:</small></p>

<p>&nbsp;</p>


<p><br>
bsdi % <b>ftp -d slip </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; указываем
опцию -d, чтобы видеть команды клиента<br>
Connected to slip.<br>
220 slip FTP server (Version 5.60) ready.<br>
<br>
Name (slip:rstevens):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим
RETURN<br>
---&gt; USER rstevens<br>
331 Password required for rstevens.<br>
<br>
Password: вводим пароль<br>
---&gt; PASS XXXX<br>
230 User rstevens logged in.<br>
<br>
---&gt; SYST
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; это
клиент посылает автоматически<br>
215 UNIX Type: L8 Version: BSD-199103
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; отклик
сервера<br>
<br>
Remote system type is UNIX.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вывод
информации клиентом<br>
Using binary mode to transfer files.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вывод
информации клиентом<br>
<br>
ftp&gt; <b>get hello.c </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; получить
файл<br>
---&gt; TYPE I
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; это
клиент посылает автоматически<br>
200 Type set to I.<br>
<br>
---&gt; PORT 140,252,13,66,4,84
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; номер
порта = 4 х 256 + 84 = 1108<br>
200 PORT command successful.<br>
<br>
---&gt; RETR hello.c<br>
150 Opening BINARY mode data connection for hello.c (38 bytes).<br>
226 Transfer complete.<br>
<br>
38 bytes received in 0.035 seconds (1.1 Kbytes/s)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; в этот раз только 38
байт<br>
<br>
ftp&gt; <b>quit</b><br>
<br>
---&gt; QUIT<br>
221 Goodbye.<br>
</p>


<p>&nbsp;</p>

<p><small>После того как мы правильно ввели имя и
пароль серверу, FTP клиент автоматически посылает
команду SYST, в ответ на которую сервер сообщает
свой тип системы. Если отклик начинается со
строки &quot;215 UNIX Type: L8&quot;, и если клиент работает
под управлением Unix системы с 8-битными байтами,
для передачи всех файлов используется двоичный
(image) режим, если его не сменит пользователь. </small></p>

<p><small>Когда мы забираем файл hello.c, клиент
автоматически посылает команду TYPE I, чтобы
установить тип файла в двоичный. На этот раз по
соединению данных было передано 38 байт.</small></p>

<p>&nbsp;</p>


<p>Требования к хостам <a NAME="t273020"></a>Host Requirements RFC говорят, что FTP сервер
должен поддерживать команду SYST (это было
необязательным условием в RFC 959). Из систем
описанных в тексте (см. внутреннюю сторону
обложки) эту команду поддерживают <a NAME="t273021"></a>BSD/386
и <a NAME="t273022"></a>AIX 3.2.2. <a NAME="t273023"></a>SunOS 4.1.3 и <a NAME="t273024"></a>Solaris
2.x выдают на эту команду отклик 500 (команда
неизвестна). <a NAME="t273025"></a>SVR4 ведет себя совсем
по-дикому: отвечает 500 и закрывает управляющее
соединение! </p>


<p>&nbsp;</p>
<i><b>

<p><a NAME="t273026"></a>Прекращение передачи файла: сигнал
синхронизации Telnet</p>
</b></i>

<p><small>Сейчас мы посмотрим, как FTP клиент
прекращает передачу файла от сервера. Прекратить
передачу файла от клиента к серверу достаточно
просто - клиент прекращает посылку данных по
соединению данных и посылает ABOR на сервер по
управляющему соединению. Прекращение приема,
однако, более сложная задача, потому что клиент
хочет, чтобы сервер немедленно прекратил
передачу данных. Ранее мы упоминали, что для
этого используется <a NAME="t273027"></a>сигнал
синхронизации Telnet. </small></p>

<p><small>Мы начали прием, после чего ввели символ
прерывания. Ниже приведена интерактивная сессия,
процесс идентификации пользователя удален:</small></p>

<p>&nbsp;</p>


<p><br>
ftp&gt; <b>get a.out</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; получаем
большой файл<br>
<br>
---&gt; TYPE I
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; клиент
и сервер - Unix системы с 8-битными байтами<br>
<br>
200 Type set to I.<br>
<br>
---&gt; PORT 140,252,13,66,4,99<br>
200 PORT command successful.<br>
<br>
---&gt; RETR a.out<br>
150 Opening BINARY mode data connection for a.out (28672 bytes).<br>
<br>
^<b>?</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим
символ прерывания<br>
receive aborted
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вывод
от клиента<br>
waiting for remote to finish abort
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вывод
от клиента<br>
<br>
426 Transfer aborted. Data connection closed.<br>
226 Abort successful<br>
<br>
1536 bytes received in 1.7 seconds (0.89 Kbytes/s)<br>
</p>


<p>&nbsp;</p>

<p><small>После того как введен символ прерывания,
клиент немедленно сообщает, что он
инициализировал прерывание передачи файла и
ожидает, когда сервер его завершит. Сервер
посылает два отклика: 426 и 226. Оба отклика
посылаются Unix сервером, когда он принимает
срочные данные от клиента с командой ABOR. </small></p>

<p><small>На рисунках 27.9 и 27.10 показаны временные
диаграммы для этой сессии. Мы объединили вместе
управляющее соединение (сплошные линии) и
соединение данных (прерывистые линии), чтобы
показать взаимосвязь между ними.<a NAME="t273028"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t27_9000.jpg" WIDTH="515" HEIGHT="492"></small></p>


<p ALIGN="CENTER"><small>Рисунок 27.9 Прерывание передачи
файла (первая половина).</small></p>

<p>&nbsp;</p>

<p><small>Первые 12 сегментов на рисунке 27.9 как раз
такие, как мы ожидали. Команды и отклики по
управляющему соединению настраивают системы на
передачу файла, открывается соединение данных и
от сервера к клиенту посылается первый сегмент
данных.<a NAME="t273029"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t27_1001.jpg" WIDTH="515" HEIGHT="632"></small></p>


<p ALIGN="CENTER"><small>Рисунок 27.10 Прерывание передачи
файла (вторая половина).</small></p>

<p>&nbsp;</p>

<p><small>Сегмент 13 на рисунке 27.10 - это квитанция на
шестой сегмент данных от сервера по соединению
данных. Затем следует сегмент 14, который
сгенерирован нашим вводом символа прерывания.
Для того чтобы прервать передачу, клиент
посылает десять байт:</small></p>

<p>&nbsp;</p>

<p><small>&lt;IAC, IP, IAC, DM, A,
B, O, R, \r, \n&gt;</small></p>

<p>&nbsp;</p>

<p><small>Мы видим два сегмента (14 и 15), это связано с
проблемой определения положения <a NAME="t273030"></a>указателя
срочности TCP (подробно описанной в разделе <a HREF="tcp20.html#t208000">&quot;Режим срочности (Urgent Mode)&quot;</a>
главы 20). (На <a HREF="tcp26.html#t265040">рисунке 26.17</a> мы
видели, как Telnet решает эту проблему.) Требование к
хостам <a NAME="t273031"></a>Host Requirements RFC говорит, что
указатель срочности должен указывать на
последний байт срочных данных, тогда как
большинство Berkeley реализаций указывают на один
байт позади последнего байта срочных данных. FTP
клиент специально пишет первые 3 байта как
срочные данные, зная, что указатель срочности
будет (некорректно) указывать на следующий байт,
который будет записан (метка данных, DM, с номером
последовательности 54). Эта первая запись из 3 байт
срочных данных посылается немедленно, вместе с
указателем срочности, за ними следуют следующие 7
байт. (BSD FTP сервер не имеет проблемы с
интерпретацией указателя срочности, который
используется клиентом. Когда сервер принимает
срочные данные по управляющему соединению, он
читает следующую FTP команду, в поиске ABOR или STAT,
игнорируя любые вложенные команды Telnet.) </small></p>

<p><small>Несмотря на то, что сервер сообщил о
прекращении передачи (сегмент 18, по управляющему
соединению), клиент получил еще 14 сегментов
данных (номера последовательности 1537 - 5120) по
соединению данных. Эти сегменты, скорее всего,
были поставлены в очередь в драйвере сетевого
устройства на сервере, когда был принят сигнал о
прекращении передачи. Однако клиент печатает
&quot;1536 байт принято&quot;, а это означает, что он
проигнорировал эти сегменты данных (сегменты 17 и
позже), которые были приняты после отправки
прерывания передачи (сегменты 14 и 15). </small></p>

<p><small>В случае Telnet, когда пользователь вводит
символ прерывания (рисунок 26.17), Unix клиент по
умолчанию не посылает команду прерывания
процесса в виде срочных данных. В этом нет ничего
страшного, потому что существует очень маленькая
вероятность того, что поток данных от клиента к
серверу остановлен управлением потока данных. В
случае FTP клиент также посылает команду
прерывания процесса по управляющему соединению,
и так как используется два соединения,
существует очень небольшая вероятность того, что
управляющее соединение будет остановлено
управлением потока данных. Почему FTP посылает
команду прерывания процесса в виде срочных
данных, тогда как Telnet не делает этого? Дело в том,
что FTP использует два соединения, тогда как Telnet
использует одно, а для некоторых операционных
систем довольно сложно обработать информацию
приходящую по двум соединениям одновременно. FTP
подразумевает, что эти операционные системы по
крайней мере смогут понять, что по управляющему
соединению срочные прибыли данные, и что в свою
очередь позволит серверу переключиться от
обработки соединения данных на обработку
управляющего соединения.</small></p>
<i><b>

<p><a NAME="t273032"></a>Анонимный FTP</p>
</b></i>

<p><small>Существует невероятно популярная форма
использования FTP. Она называется анонимный FTP
(anonymous FTP). Если эта форма поддерживается сервером,
она позволяет любому получить доступ к серверу и
использовать FTP для передачи файлов. С помощью
анонимного FTP можно получить доступ к огромному
объему свободно распространяемой информации. </small></p>

<p><small>Тут возникает еще одна проблема, которая
заключается в том, что очень сложно найти то, что
нужно в этом море информации. Кратко это описано
в разделе <a HREF="tcp30.html#t304000">&quot;Archie, WAIS, Gopher, Veronica и
WWW&quot;</a> главы 30. </small></p>

<p><small>Воспользуемся анонимным FTP, чтобы получить
файл опечаток для этой книги с хоста ftp.uu.. Чтобы
использовать анонимный FTP, мы входим в систему с
именем пользователя &quot;anonymous&quot; (чтобы выучить,
как пишется это слово, попробуйте повторить его
несколько раз). Когда появляется приглашение
ввести пароль, мы вводим наш адрес электронной
почты.</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>ftp ftp.uu.net</b><br>
Connected to ftp.uu.net.<br>
220 ftp.UU.NET FTP server (Version 2.OWU(13) Fri Apr 9 20:44:32 EDT 1993) ready.<br>
<br>
Name (ftp.uu.net:rstevens): <b>anonymous</b><br>
331 Guest login ok, send your complete e-mail address as password.<br>
<br>
Password:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; мы
вводим rstevens@noao.edu; это не отображается эхом<br>
<br>
230-<br>
230- Welcome to the UUNET archive.<br>
230- A service of UUNET Technologies Inc, Falls Church, Virginia<br>
230- For information about UUNET, call +1 703 204 8000, or see the files<br>
230- in /uunet-info<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; здесь
еще несколько приветственных строк<br>
<br>
230 Guest login ok, access restrictions apply.<br>
<br>
ftp&gt; <b>cd published/books</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; переходим
в нужную директорию<br>
250 CWD command successful.<br>
<br>
ftp&gt; <b>binary</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; будем
использовать двоичный формат файла<br>
200 Type set to I.<br>
<br>
ftp&gt; <b>get stevens.tcpipiv1.errata.Z</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; получаем
файл<br>
200 PORT command successful.<br>
150 Opening BINARY mode data connection for stevens.tcpipiv1.errata.Z (105 bytes).<br>
226 Transfer complete. (у вас может быть другой размер
файла)<br>
<br>
local: stevens.tcpipiv1.errata.Z remote: stevens.tcpipiv1.errata.Z<br>
105 bytes received in 4.1 seconds (0.83 Kbytes/s)<br>
<br>
ftp&gt; <b>quit</b><br>
221 Goodbye.<br>
<br>
sun % <b>uncompress stevens.tcpipiv1.errata.Z</b><br>
<br>
sun % <b>more stevens.tcpipiv1.errata<br>
</p>
</b>

<p>&nbsp;</p>

<p><small>Программа <a NAME="t273033"></a>uncompress используется
потому, что большинство файлов, доступных через
анонимный FTP, сжаты с использованием Unix программы
<a NAME="t273034"></a>compress(1), такие файлы имеют расширение
.Z. Эти файлы должны быть переданы в виде двоичных
файлов, а не ASCII файлов.</small></p>
<i><b>

<p><a NAME="t273035"></a>Анонимный FTP с неизвестного IP
адреса</p>
</b></i>

<p><small>Мы можем объединить вместе некоторые
характеристики маршрутизации и системы имен (Domain
Name System) с использованием анонимного FTP. <a NAME="t273036"></a>В
разделе <a HREF="tcp14.html#t145000">&quot;Запросы указателя&quot;</a>
главы 14 мы говорили о <a NAME="t273037"></a>запросах
указателя в DNS - которые воспринимают IP адреса и
возвращают имя хоста. К сожалению, не все
администраторы систем корректно конфигурируют
свои DNS серверы таким образом, чтобы они отвечали
на запросы указателей. Они часто добавляют новые
хосты к файлам, необходимым для установления
соответствия имя-адрес, однако забывают добавить
их в файлы, устанавливающие соответствие
адрес-имя. С этим можно столкнуться, работая с
программой <a NAME="t273038"></a>traceroute, когда она выдает IP
адреса вместо имен хостов. </small></p>

<p><small>Некоторые анонимные FTP серверы требуют,
чтобы клиент имел корректное имя домена. Это
позволяет серверу зарегистрировать имя домена и
хоста, с который осуществлен заход. Единственная
информация, которую может узнать сервер о
клиенте из IP датаграммы - это IP адрес клиента.
Сервер осуществляет запрос указателя, чтобы
узнать доменное имя клиента. Если DNS сервер,
отвечающий за хост клиента, не сконфигурирован
корректно, запрос указателя не сработает. </small></p>

<p><small>Давайте смоделируем подобную ошибку. </small>

<ol>
  <li><small>Изменим IP адрес хоста slip (см. рисунок на
    внутренней стороне обложки) на 140.252.13.67. Это
    нормальный IP адрес для нашей подсети, однако его
    нет на DNS сервере домена noao.edu. </small></li>
  <li><small>Изменим IP адрес назначения SLIP канала на bsdi
    на 140.252.13.67. </small></li>
  <li><small>Добавим пункт в таблицу маршрутизации на sun,
    который будет направлять датаграммы для 140.252.13.67
    на маршрутизатор bsdi. (Обратитесь к описанию этой
    таблицы маршрутизации, которое приведено в
    разделе <a HREF="tcp09.html#t092000">&quot;Принципы
    маршрутизации&quot;</a> главы 9.) </small></li>
</ol>

<p><small>Хост slip доступен по Internet, потому что, как мы
видели в разделе <a HREF="tcp10.html#t104000">&quot;RIP: протокол
обмена информацией о маршрутизации&quot;</a> главы 10,
маршрутизаторы gateway и netb все еще посылают
датаграммы, которые предназначены в подсеть
140.252.13, на маршрутизатор sun. Наш маршрутизатор sun
знает, что делать с этими датаграммами, в
соответствии с пунктом маршрутизации, который мы
сделали в шаге номер 3. Таким образом, мы создали
хост, который полностью подключен к Internet, однако
не имеющий корректного имени домена. Таким
образом, <a NAME="t273039"></a>запрос указателя для IP
адреса 140.252.13.67 не будет работать. А сейчас
воспользуемся анонимным FTP на сервер, который,
как мы знаем, требует корректного имени домена.</small></p>

<p>&nbsp;</p>


<p>slip % <b>ftp ftp.uu.net<br>
</b>Connected to ftp.uu.net.<br>
<br>
220 ftp.UU.NET FTP server (Version 2.OWU(13) Fri Apr 9 20:44:32 EDT 1993) ready.<br>
Name (ftp.uu.net:rstevens): <b>anonymous<br>
<br>
</b>530- Sorry, we're unable to map your IP address 140.252.13.67 to a hostname<br>
530- in the DNS. This is probably because your nameserver does not have a<br>
530- PTR record for your address in its tables, or because your reverse<br>
530- nameservers are not registered. We refuse service to hosts whose<br>
530- names we cannot resolve. If this is simply because your nameserver is<br>
530- hard to reach or slow to respond then try again in a minute or so, and<br>
530- perhaps our nameserver will have your hostname in its cache by then.<br>
530- If not, try reaching us from a host that is in the DNS or have your<br>
530- system administrator fix your servers.<br>
530 User anonymous access denied..<br>
<br>
Login failed.<br>
Remote system type is UNIX.<br>
Using binary mode to transfer files.<br>
<br>
ftp&gt; <b>quit<br>
</b>221 Goodbye.&nbsp;</p>

<p>&nbsp;</p>

<p><small>(К сожалению, мы не можем найти имя хоста,
соответствующее вашему IP адресу. Возможно, это
потому, что у вашего сервера имен нет в таблице PTR
записи, соответствующей вашему адресу, или ваш
сервер не зарегистрирован. Мы не работаем с
хостами, для которых мы не можем определить имя
домена. Если проблема в том, что ваш DNS сервер
медленно отвечает или до него сложно
достучаться, попробуйте еще раз через минуту.
Может быть, в этот раз DNS сервер уже будет иметь
ваше имя в своем кэше. Если дело не в этом,
попробуйте зайти к нам с хоста, который корректно
зарегистрирован в DNS, или попросите
администратора починить ваш сервер.) Сообщение
об ошибке говорит само за себя.</small></p>
<u><b>

<p><a NAME="t274000"></a>Краткие выводы</p>
</b></u>

<p><small>FTP это стандарт, признанный в Internet, для
передачи файлов. В отличие от большинства других
TCP приложений, он использует два TCP соединения
между клиентом и сервером - управляющее
соединение, которое существует в течение всего
продолжения сессии клиент-сервер, и соединение
данных, которое создается и удаляется по
необходимости. </small></p>

<p><small>Управление соединением, которое
осуществляется FTP, позволило нам увидеть, какие
требования выдвигает TCP к управлению
соединением. Мы видели состояние ожидания 2MSL на
клиенте, который не выдает команды PORT. </small></p>

<p><small>FTP использует формат NVT <a NAME="t274001"></a>ASCII для
всех команд и откликов, которые передаются по
управляющему соединению. Режим передачи данных
по умолчанию это, как правило, также NVT <a NAME="t274002"></a>ASCII.
Мы видели, что более новые Unix клиенты
автоматически посылают команду, чтобы убедиться
в том, что сервер это Unix хост с 8-битными байтами, и
если так, используют двоичный режим для передачи
всех файлов, которые являются более
эффективными. </small></p>

<p><small>Также мы показали пример анонимного FTP,
популярного способа распространения
программного обеспечения по Internet.</small>&nbsp;</p>
<i><b>

<p>Упражнения</b></i> 

<ol>
  <li>Обратитесь к рисунку 27.8. Что
    изменится, если клиент осуществит активное
    открытие второго соединения данных вместо
    сервера?</li>
  <li>В примере для FTP клиента в этой главе мы сказали,
    что такие строки, как, например<p>local: hello.c remote: hello.c<br>
    42 bytes received in 0.0037 seconds (11 Kbytes/s)</p>
    <p>выдаются клиентом. Не
    заглядывая в исходные тексты, как можно
    определить, что они не от сервера?</p>
  </li>
</ol>

<hr>

</body>
</html>

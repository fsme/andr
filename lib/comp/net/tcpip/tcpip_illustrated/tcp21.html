<html>

<head>
<title>Тайм-ауты и повторные передачи TCP</title>

<meta http-equiv="Content-type" content="text/html; charset=koi8-r">
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>




<p><a NAME="t210000"></a>Глава 21 Тайм-ауты и повторные
передачи TCP</p>
<u>

<p><b><a NAME="t211000"></a>Введение</p>
</b></u>

<p><small>TCP - это надежный транспортный уровень. Один
из способов обеспечения надежности заключается
в том, что удаленный участник обмена
подтверждает полученные данные. Однако, сегменты
данных, которые должны быть подтверждены, могут
быть потеряны. TCP отрабатывает подобные ситуации
установкой тайм-аута, при отправке данных; если
данные не были подтверждены до момента истечения
тайм-аута, TCP передает их повторно. Основными
составляющими частями подобной технологии
являются <a NAME="t211001"></a>тайм-ауты и повторные
передачи. Как определяются величины тайм-аутов, и
как часто осуществляются повторные передачи? </small></p>

<p><small>Мы уже видели два примера тайм-аута и
повторной передачи: (1) в примере, посвященном
недоступности порта ICMP в разделе <a HREF="tcp06.html#t065000">&quot;ICMP
ошибка недоступности порта&quot;</a> главы 6, мы
видели, что TFTP клиент, использующий UDP, применяет
простую стратегию тайм-аута и повторной
передачи: он устанавливает период тайм-аута в 5
секунд и осуществляет повторную передачу каждые
5 секунд. (2) В примере ARP для несуществующего хоста
(глава 4, раздел <a HREF="tcp04.html#t045000">&quot;Примеры ARP&quot;</a>)
мы видели, что когда TCP старается установить
соединение, он повторно передает свои SYN,
используя увеличенные задержки между каждой
повторной передачей. </small></p>

<p><small>TCP управляет четырьмя таймерами для каждого
соединения.</small> 

<ol>
  <li><small><a NAME="t211002"></a>Таймер повторной передачи
    (retransmission) используется в том случае, когда
    ожидается подтверждение от удаленного конца. В
    этой главе таймер повторной передачи
    рассматривается подробно, также рассматриваются
    соответствующие характеристики, такие как
    предотвращение переполнения.</small></li>
  <li><small><a NAME="t211003"></a>Устойчивый (persist) таймер, в
    течение которого сохраняется информация о
    размере окна передачи, даже если удаленный конец
    закрыл свое приемное окно. В <a HREF="tcp22.html">главе 22</a>
    этот таймер будет описан более подробно.</small></li>
  <li><small><a NAME="t211004"></a>Таймер времени жизни (keepalive)
    определяет, когда можно считать, что удаленный
    конец вышел из строя или перезагрузился. Этот
    таймер описывается в <a HREF="tcp23.html">главе 23</a>. </small></li>
  <li><small><a NAME="t211005"></a>Таймер 2MSL определяет время, в
    течение которого соединение может быть в
    состоянии <a NAME="t211006"></a>TIME_WAIT. Это описано в
    разделе <a HREF="tcp18.html#t186000">&quot;Диаграмма состояний
    передачи TCP&quot;</a> главы 18. </small></li>
</ol>

<p><small>В этой главе мы начнем с простых примеров
того, как TCP использует тайм-ауты и повторные
передачи, а затем рассмотрим более подробные
примеры, которые позволят понять, как TCP
осуществляет управление таймерами. Мы увидим то,
как стандартные реализации рассчитывают время
возврата сегментов TCP, и как TCP использует эти
расчеты, для того чтобы вычислить тайм-аут для
повторной передачи следующего сегмента, который
он собирается отправить. Затем мы рассмотрим, как
TCP избегает переполнения - что TCP делает, когда
пакеты теряются - и в завершение, рассмотрим
реальные примеры того, каким образом теряются
пакеты. Также мы рассмотрим новый алгоритм
быстрой передачи и алгоритм быстрого
восстановления, а затем посмотрим, что позволяет
TCP быстрее определять факт потери пакетов, нежели
просто ожидание того, когда истечет таймер.</small></p>
<u><b>

<p><a NAME="t212000"></a>Простой пример использования
тайм-аутов и повторных передач</p>
</b></u>

<p><small>Во-первых, давайте рассмотрим стратегию
повторных передач, которая используется TCP. Мы
установим соединение, отправим какие-нибудь
данные, чтобы убедиться в том, что соединение
функционирует, отсоединим кабель, отправим еще
данные и посмотрим, как поступит TCP:</small></p>

<p>&nbsp;</p>


<p><br>
bsdi % <b>telnet svr4 discard</b><br>
Trying 140.252.13.34...<br>
Connected to svr4.<br>
Escape character is '^]'.<br>
<b>hello, world </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; эту
строку мы посылаем обычным образом<br>
<b>and hi </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; перед
тем как отправить эту строку, отсоединяем кабель<br>
Connection closed by foreign host.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вывод,
после того как TCP ждал 9 минут<br>
</p>


<p>&nbsp;</p>

<p><small>На рисунке 21.1 показан вывод команды tcpdump. (Мы
удалили всю информацию, связанную с типом
сервиса, которую устанавливает bsdi.)<a NAME="t212001"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp;&nbsp;&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1029
&gt; svr4.discard: S 1747921409:1747921409(0) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; win
4096 &lt;mss 1024&gt;<br>
2&nbsp;&nbsp;&nbsp; 0.004811 ( 0.0048)&nbsp;&nbsp;&nbsp;&nbsp; svr4.discard &gt;
bsdi.1029: S 3416685569:3416685569(0) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ack
1747921410 <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; win
4096 &lt;mss 1024&gt;<br>
3&nbsp;&nbsp;&nbsp; 0.006441 ( 0.0016)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1029 &gt;
svr4.discard: . ack 1 win 4096<br>
<br>
4&nbsp;&nbsp;&nbsp; 6.102290 ( 6.0958)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1029 &gt;
svr4.discard: P 1:15(14) ack 1 win 4096<br>
5&nbsp;&nbsp;&nbsp; 6.259410 ( 0.1571)&nbsp;&nbsp;&nbsp;&nbsp; svr4.discard &gt;
bsdi.1029: . ack 15 win 4096<br>
<br>
6&nbsp;&nbsp; 24.480158 (18.2207)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1029 &gt; svr4.discard: P
15:23(8) ack 1 win 4096<br>
7&nbsp;&nbsp; 25.493733 ( 1.0136)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1029 &gt; svr4.discard: P
15:23(8) ack 1 win 4096<br>
8&nbsp;&nbsp; 28.493795 ( 3.0001)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1029 &gt; svr4.discard: P
15:23(8) ack 1 win 4096<br>
9&nbsp;&nbsp; 34.493971 ( 6.0002)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1029 &gt; svr4.discard: P
15:23(8) ack 1 win 4096<br>
10&nbsp;&nbsp; 46.484427 (11.9905)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1029 &gt; svr4.discard: P
15:23(8) ack 1 win 4096<br>
11&nbsp;&nbsp; 70.485105 (24.0007)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1029 &gt; svr4.discard: P
15:23(8) ack 1 win 4096<br>
12&nbsp; 118.486408 (48.0013)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1029 &gt; svr4.discard: P
15:23(8) ack 1 win 4096<br>
13&nbsp; 182.488164 (64.0018)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1029 &gt; svr4.discard: P
15:23(8) ack 1 win 4096<br>
14&nbsp; 246.489921 (64.0018)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1029 &gt; svr4.discard: P
15:23(8) ack 1 win 4096<br>
15&nbsp; 310.491678 (64.0018)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1029 &gt; svr4.discard: P
15:23(8) ack 1 win 4096<br>
16&nbsp; 374.493431 (64.0018)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1029 &gt; svr4.discard: P
15:23(8) ack 1 win 4096<br>
17&nbsp; 438.495196 (64.0018)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1029 &gt; svr4.discard: P
15:23(8) ack 1 win 4096<br>
18&nbsp; 502.486941 (63.9917)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1029 &gt; svr4.discard: P
15:23(8) ack 1 win 4096<br>
19&nbsp; 566.488478 (64.0015)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1029 &gt; svr4.discard: R
23:23(0) ack 1 win 4096<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 21.1 Простой пример тайм-аута и
повторной передачи TCP.</small></p>

<p>&nbsp;</p>

<p><small>Строки 1, 2 и 3 соответствуют обычному
установлению TCP соединения. Строка&nbsp;4 это
передача &quot;hello, world&quot; (12 символов плюс символ
возврата каретки и пропуска строки), а в строке 5 -
подтверждение. Затем мы отсоединяем Ethernet кабель
от svr4. </small></p>

<p><small>В строке 6 показано, как передается &quot;and
hi&quot;. Строки 7-18 это 12 повторных передач сегмента,
а в строке 19 TCP прекращает попытки передачи и
посылает сброс. </small></p>

<p><small>Обратите внимание на временные промежутки
между последовательными повторными передачами:
они происходили в моменты времени 1, 3, 6, 12, 24, 48 и 64
секунды. Дальше в этой главе мы увидим, что первый
тайм-аут устанавливается в 1,5 секунды после
первой передачи. (Причина, по которой он возник
через 1,0136 секунды после первой передачи, а не
точно через 1,5 секунды, была объяснена на рисунке
18.7.) После этого величина тайм-аута удваивается
для каждой передачи, причем верхний предел
составляет 64 секунды. </small></p>

<p><small>Подобное увеличение называется <a NAME="t212002"></a>экспотенциальным
наращиванием (exponential backoff). Сравните это с
примером TFTP, который приведен в разделе <a HREF="tcp06.html#t065000">&quot;ICMP ошибка недоступности
порта&quot;</a> главы 6, где каждая повторная передача
осуществляется через 5 секунд после предыдущей. </small></p>

<p><small>Разница во времени между первой передачей
пакета (строка 6, момент времени 24,480) и сбросом
(строка 19, момент времени 566,488) составляет
примерно 9 минут. Современные TCP реализации
довольно настойчивы в попытках отправить данные!
</small></p>

<p>&nbsp;</p>


<p>В большинстве
реализаций полная величина тайм-аута
ненастраиваемая. <a NAME="t212003"></a>Solaris 2.2 позволяет
администратору изменить эту величину
(переменная <a NAME="t212004"></a>tcp_ip_abort_interval в разделе <a HREF="tcp_e.html#t354000">&quot;Solaris 2.2&quot;</a> приложения E), а по
умолчанию она составляет только 2 минуты, а не 9
минут, как это принято в большинстве реализаций.</p>


<p><small><a NAME="t213000"></a>&nbsp;</small></p>
<u><b>

<p>Определение времени возврата</p>
</b></u>

<p><small>Основой тайм-аутов и повторных передач TCP
является <a NAME="t213001"></a>расчет времени возврата (RTT -
round-trip time), соответствующего данному соединению.
Мы ожидаем, что оно может изменяться со временем,
так как может измениться маршрут, или загрузка
сети. TCP должен отследить эти изменения и
соответственно модифицировать тайм-ауты. </small></p>

<p><small>Во-первых, TCP должен рассчитать RTT между
отправкой байта с конкретным номером
последовательности и получением подтверждения
на этот номер последовательности. Из <a HREF="tcp20.html">предыдущей</a>
главы мы знаем, что обычно не существует полного
соответствия между сегментами данных и
подтверждениями (ACK). На рисунке 20.1 это означало,
что один RTT, который может быть вычислен
отправителем, является временем между передачей
сегмента 4 (байты данных 1-1024) и получением
сегмента 7 (ACK байт 1-2048), даже если этот ACK
подтверждает дополнительно 1024 байта. Мы
используем величину M, чтобы обозначить
рассчитанный RTT. </small></p>

<p><small>Для определения RTT существует расширение к
исходной спецификации TCP, которое называется
хэшированная оценочная функция RTT (обозначается
R)</small></p>

<p>&nbsp;</p>

<p><small>R ╛ a R + (1 - a )M</small></p>

<p>&nbsp;</p>

<p><small>где a это
коэффициент хэширования с рекомендуемым
значением 0,9. Хэширование - способ организации
структур данных (хэш таблиц), обеспечивающий
эффективный поиск и пополнение; положение
элемента данных в хэш таблице определяется
значением функции расстановки, отображающей
множество возможных ключей элементов данных и
множество индексов таблицы и обеспечивающей
равномерное заполнение. Хэшированный RTT
обновлялся каждый раз, когда осуществлялось
новое вычисление. Девяносто процентов данных для
каждого нового расчета берется из предыдущего
расчета, а десять из нового. </small></p>

<p><small>Для подобной хэшированной оценочной
функции, которая изменяется с изменением RTT, RFC 793
рекомендует, чтобы тайм-аут повторной передачи (<a NAME="t213002"></a>RTO) устанавливался следующим образом</small></p>

<p>&nbsp;</p>

<p><small>RTO = Rb</small></p>


<p>&nbsp;</p>

<p><small>где b это
коэффициент изменения задержки с рекомендуемым
значением равным 2. </small></p>

<p><small>[<a NAME="t213003"></a>Jacobson 1988] подробно обсуждает
проблемы, связанные с подобным подходом, в
основном заключающиеся в том, что он не может
применяться при широком диапазоне изменения RTT, и
является причиной нежелательных повторных
передач. Как замечает Jacobson, нежелательные
повторные передачи увеличивают загрузку сети. </small></p>

<p><small>В этом случае необходимо добавить
возможность отслеживать расхождения в расчетах
RTT в дополнение к хэшированной функции оценки RTT.
Расчет RTO основанный на среднем и расхождении
дает значительно лучшие результаты при широком
диапазоне изменений времен возврата, чем просто
расчет RTO как постоянного кратного среднего
значения. Рисунки 5 и 6 в [Jacobson 1988] показывают
сравнение значений RTO в соответствии с RFC 793 для
некоторых реальных времен возврата, с расчетами
RTO, которые мы показали ранее, которые принимают
во внимание изменение времен возврата. </small></p>

<p><small>Как описано у Jacobson, среднее отклонение
является хорошим приближением к стандартному
отклонению, однако рассчитывается значительно
легче. (Расчет стандартного отклонения требует
вычисления квадратного корня.) Таким образом,
следующие уравнения могут быть применены к
каждому расчету RTT M.</small></p>

<p>&nbsp;</p>

<p><small>Err = M - A</small></p>

<p><small>A ╛ A + gErr</small></p>

<p><small>D ╛ D + h(| Err | - D)</small></p>

<p><small>RTO = A + 4D</small></p>

<p>&nbsp;</p>

<p><small>где A это хэшированный RTT (оценочная функция
среднего), а D это хэшированное среднее
отклонение. Err это разница между только что
рассчитанным значением и текущим значением
оценочной функции RTT. Оба A и D используются для
расчета следующего тайм-аута повторной передачи
(RTO). Увеличение среднего (g) установлено в
значение 1/8 (0,125). Увеличение отклонения (h)
установлено в 0,25. Максимальное увеличение
отклонения делает рост RTO быстрее при изменении
RTT.</small></p>

<p>&nbsp;</p>


<p>[Jacobson 1988] устанавливает
2D при расчете RTO, однако для следующих
исследований [Jacobson 1990c] изменяет это значение на
4D, что соответствует реализации BSD Net/1.</p>


<p>&nbsp;</p>

<p><small>Jacobson показывает способ осуществить эти
вычисления с использованием целочисленной
арифметики, именно так это обычно делается в
стандартных реализациях. (Одна из причин
заключается в том, что g, h и множитель 4 - это
степени двух, поэтому все операции могут быть
осуществлены с помощью сдвига, без умножений и
делений.) </small></p>

<p><small>Сравнение исходного метода с методом Jacobsonа
показывает, что расчеты хэшированного среднего
одинаковы (a равно
единица минус увеличение (g)), однако используются
различные увеличения. Также, расчет RTO по Jacobsonу
зависит от обоих значений - хэшированного RTT и
хэшированного среднего отклонения, тогда как
оригинальный метод использует умножение
хэшированных RTT. </small></p>

<p><small>В следующем разделе мы увидим, как
устанавливаются эти оценочные функции, когда
будем рассматривать примеры.</small></p>
<i><b>

<p><a NAME="t213004"></a>Алгоритм Карна</p>
</b></i>

<p><small>В процессе повторной передачи пакета могут
возникнуть проблемы. Скажем, пакет передан,
тайм-аут отработан, RTO экспотенциально увеличен,
как показано в разделе <a HREF="#t212000">&quot;Простой
пример использования тайм-аутов и повторных
передач&quot;</a> этой главы, пакет передан повторно
с большим RTO и получено подтверждение.
Соответствует ли это подтверждение первой
передаче или второй? Это называется <a NAME="t213005"></a>проблемой
двусмысленности повторной передачи (retransmission
ambiguity problem) . </small></p>

<p><small><a NAME="t213006"></a>[Karn and Partridge 1987] указывает, что
когда применяется тайм-аут и повторная передача,
мы не можем обновить оценочные функции RTT, когда,
в конце концов, прибывает подтверждение на
повторно переданные данные. Это потому, что мы не
знаем, которой передаче соответствует
подтверждение (ACK). (Возможно, первая передача
была задержана, но не была отброшена, или был
задержан ACK на первую передачу.) </small></p>

<p><small>Так как данные были повторно переданы и к RTO
было применено <a NAME="t213007"></a>экспотенциальное
наращивание, мы повторно используем
экспотенциально увеличенный RTO для следующей
передачи. Новый RTO не рассчитывается до тех пор,
пока не будет получено подтверждение на сегмент,
который не отправлялся повторно.</small></p>
<u><b>

<p><a NAME="t214000"></a>Пример RTT</p>
</b></u>

<p><small>В этой главе мы рассмотрим примеры, которые
проиллюстрируют детали разных реализаций TCP
тайм-аутов и повторных передач, медленный старт и
предотвращение переполнения. </small></p>

<p><small>С помощью программы <a NAME="t214001"></a>sock
отправлено 32768 байт данных с хоста slip на discard
сервис хоста vangogh.cs.berkeley.edu:</small></p>

<p>&nbsp;</p>


<p>slip % <b>sock -D -i -n32
vangogh.cs.berkeley.edu discard</p>
</b>

<p>&nbsp;</p>

<p><small>Обратимся к рисунку, находящемуся на
внутренней стороне обложки. Из рисунка видно, что
slip подсоединен к Ethernet 140.252.1 двумя SLIP каналами, а
затем через Internet к пункту назначения. Так как
используется два SLIP канала (со скоростью 9600 бит в
секунду), мы ожидаем появления определенных
задержек. </small></p>

<p><small>Команда, приведенная выше, осуществит 32
записи по 1024 байта. Так как MTU между slip и bsdi
составляет 296, то будет сгенерировано 128
сегментов, каждый из которых будет содержать 256
байт пользовательских данных. Полное время
передачи займет примерно 45 секунд, и мы увидим
один тайм-аут и три повторные передачи. </small></p>

<p><small>Пока осуществляется эта передача, мы
запустим <a NAME="t214002"></a>tcpdump на хосте slip, чтобы
увидеть все сегменты, которые были переданы и
приняты. В дополнение мы указали опцию <a NAME="t214003"></a>-D,
чтобы включить <a NAME="t214004"></a>отладку сокетов (см.
приложение A, раздел <a HREF="tcp_a.html#t316000">&quot;Опция
отладки сокета&quot;</a>). Кроме того, у нас была
возможность запустить модифицированную версию
программы <a NAME="t214005"></a>trpt(8), которая позволяет
напечатать некоторые переменные в блоке
управления соединением, имеющие отношение к
временам задержки, медленному старту и
предотвращению переполнения. </small></p>

<p><small>Из-за того, что вывод достаточно большой, мы
не можем показать его целиком, однако рассмотрим
его по частям, в процессе изучения главы. На
рисунке 21.2 показана передача данных и
подтверждений в течение первых 5 секунд. Мы
немного модифицировали этот вывод от
предыдущего вывода команды tcpdump. Мы только
оценили моменты времени, когда пакет отправлялся
или принимался хостом, на котором запущена
программа <a NAME="t214006"></a>tcpdump, на этом рисунке мы
хотели показать, что пакет двигается по сети (так
как это соединение в локальной сети не похоже на
распределенный Ethernet), и показать, когда
принимающий хост, возможно, генерирует
подтверждения. (Мы удалили все объявления окна.
slip всегда объявляет окно размером 4096, а vangogh
всегда объявляет окно 8192.)<a NAME="t214007"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t21_2000.jpg" WIDTH="500" HEIGHT="757"></small></p>


<p ALIGN="CENTER"><small>Рисунок 21.2 Обмен пакетами и расчет
RTT.</small></p>

<p>&nbsp;</p>

<p><small>Также обратите внимание на то, что на этом
рисунке мы пронумеровали сегменты 1-13 и 15 в том
порядке, в котором они были отправлены или
приняты хостом slip. Это соответствует выводу tcpdump,
который был получен для этого хоста.</small></p>
<i><b>

<p>Определение времени возврата</p>
</b></i>

<p><small>Три большие фигурные скобки, находящиеся с
левой стороны временной диаграммы, указывают на
то, какие сегменты были использованы при расчете
RTT. Не для всех сегментов время было засечено. </small></p>

<p><small>Большинство реализаций TCP, происходящих от
Berkeley, рассчитывают только одно значение RTT для
соединения за один раз. Если в тот момент, когда
отправляется сегмент данных, таймер для данного
соединения уже используется, время для этого
сегмента не засекается. </small></p>

<p><small>Установка времени осуществляется путем
увеличения счетчика каждый раз, когда
запускается 500-миллисекундный таймер TCP. Это
означает, что для сегмента, подтверждение на
который прибывают через 550 миллисекунд после
того, как сегмент был отправлен, может быть
принято RTT как равное одному тику (500 миллисекунд),
так и RTT равное двум тикам (1000 миллисекунд). </small></p>

<p><small>В дополнение к этому счетчику тиков для
каждого соединения, запоминается начальный
номер последовательности данных в сегменте.
Когда принимается подтверждение, содержащее
этот номер последовательности, таймер
выключается. Если данные не были повторно
переданы, когда прибыл ACK, хэшированное RTT и
хэшированное среднее отклонение обновляется на
основе новых значений. </small></p>

<p><small>Таймер для соединения, показанного на
рисунке 21.2, стартует, когда передается сегмент 1,
и выключается, когда прибывает подтверждение на
него (сегмент 2). Несмотря на то, что его RTT равен
1,061 секунды (из вывода команды tcpdump), исследование <a NAME="t214008"></a>отладочной информации сокета
показывает, что за этот период произошло 3 тика
часов TCP, а это обозначает, что RTT равен 1500
миллисекунд. </small></p>

<p><small>Следующий сегмент, для которого засекли
время, сегмент номер 3. Когда, через 2,4
миллисекунды, передается сегмент номер 4, он не
может быть отслежен по времени, так как таймер
для этого соединения уже используется. Когда
прибывает сегмент 5, подтверждая данные, на
которые было засечено время, его RTT
рассчитывается равным 1 тику (500 миллисекунд),
даже несмотря на то, что, как мы видели из вывода
команды tcpdump, его RTT равен 0,808 секунды. </small></p>

<p><small>Таймер стартует снова, когда передается
сегмент 6, и выключается, когда прибывает
подтверждение на него, через 1,015 секунды (сегмент
10). Полученный RTT равен 2 тикам часов. Сегменты 7 и 9
не могут быть оценены по времени, так как таймер
занят. Также, когда принимается сегмент 9 (ACK 769),
ничего не обновляется, так как подтверждение не
подтверждает байты, на которые засекли время. </small></p>

<p><small>На рисунке 21.3 показана взаимосвязь между
реальными RTT, которые мы можем определить из
вывода команды tcpdump, и счетчиком тиков часов.<a NAME="t214009"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t21_3000.jpg" WIDTH="517" HEIGHT="112"></small></p>


<p ALIGN="CENTER"><small>Рисунок 21.3 Расчет RTT и тики часов.</small></p>

<p>&nbsp;</p>

<p><small>Вверху мы показали тики часов, каждые 500
миллисекунд. Внизу - моменты времени, полученные
из вывода команды tcpdump, и то, когда таймер
соединения включался и выключался. Мы знаем, что
между отправкой сегмента 1 и получением сегмента
2 прошло 3 тика, что заняло 1,061 секунды, таким
образом, мы предполагаем, что первый тик возник в
момент времени 0,03. (Первый тик должен произойти
между 0,00 и 0,061.) На рисунке показано, что второй RTT
был оценен равным 1 тику, а третий - 2 тикам. </small></p>

<p><small>В этом примере было передано 128 сегментов и
получено 18 значений RTT. На рисунке 21.4 показаны
измеренные RTT (взятые из вывода tcpdump) вместе с <a NAME="t214010"></a>RTO, используемого в TCP для установки
тайм-аутов (взято из отладочной информации
сокета). Момент времени 0 (на рисунке 21.2) по оси OX
соответствует отправке первого сегмента данных,
а не отправке первого SYN.<a NAME="t214011"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t21_4000.jpg" WIDTH="416" HEIGHT="321"></small></p>


<p ALIGN="CENTER"><small>Рисунок 21.4 Рассчитанные RTT и RTO TCP
для этого примера.</small></p>

<p>&nbsp;</p>

<p><small>Первые три точки, которые соответствующие
измеренным RTT, соответствуют трем RTT, которые мы
показали на рисунке 21.2. Пропуски в значениях RTT
около моментов времени 10, 14 и 21 вызваны
повторными передачами, которые здесь имели место
(что будет показано позже в этой главе). <a NAME="t214012"></a>Алгоритм
Карна не позволяет обновить наши оценки до тех
пор, пока еще один сегмент не будет передан и
подтвержден. Также обратите внимание на то, что
для этой реализации рассчитанные RTO TCP всегда
кратны 500 миллисекундам.</small></p>
<i><b>

<p>Расчет оценочных функций RTT</p>
</b></i>

<p><small>Давайте посмотрим, как устанавливаются и
обновляются оценочные функции RTT (хэшированный RTT
и хэшированное среднее отклонение), и как
рассчитывается тайм-аут для каждой передачи. </small></p>

<p><small>Переменные A и D устанавливаются в 0 и 3
секунды соответственно. Исходный тайм-аут для
передачи рассчитывается с использованием
формулы</small></p>

<p>&nbsp;</p>

<p><small>RTO = A + 2D = 0 + 2 x 3 = 6 секунд</small></p>

<p>&nbsp;</p>

<p><small>(Коэффициент 2D используется только для
этого первоначального расчета. Затем при расчете
RTO к A прибавляется 4D, как было показано ранее.) Это
RTO для передачи первоначального SYN. </small></p>

<p><small>В случае если исходный SYN потерян,
осуществляется тайм-аут и повторная передача. На
рисунке 21.5 показаны первые четыре строки вывода
команды tcpdump.<a NAME="t214013"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slip.1024
&gt; vangogh.discard: S 35648001:35648001(0) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; win
4096 &lt;mss 256&gt;<br>
2&nbsp; 5.802377 (5.8024)&nbsp;&nbsp;&nbsp;&nbsp; slip.1024 &gt; vangogh.discard: S
35648001:35648001(0) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; win
4096 &lt;mss 256&gt;<br>
3&nbsp; 6.269395 (0.4670)&nbsp;&nbsp;&nbsp;&nbsp; vangogh.discard &gt; slip.1024: S
1365512705:1365512705(0) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ack
35648002 <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; win
8192 &lt;mss 512&gt;<br>
4&nbsp; 6.270796 (0.0014)&nbsp;&nbsp;&nbsp;&nbsp; slip.1024 &gt; vangogh.discard: . ack 1
win 4096<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 21.5 Тайм-аут и повторная передача
исходного SYN.</small></p>

<p>&nbsp;</p>

<p><small>Когда тайм-аут возникает позже, через 5,802
секунды, текущий RTO рассчитывается следующим
образом</small></p>

<p>&nbsp;</p>

<p><small>RTO = A + 4D = 0 + 4 x 3 = 12 секунд</small></p>

<p>&nbsp;</p>

<p><small>Затем к RTO равному 12 применяется
экспотенциальное наращивание. Так как это первый
тайм-аут, используется множитель 2, при этом
значение следующего тайм-аута будет равно 24
секундам. Следующий тайм-аут рассчитывается с
использованием множителя 4, значения тайм-аута
становится 48 секунд: 12 x 4. (Эти исходные RTO для
первого SYN, 6 секунд и затем 24 секунды, как раз то,
что мы видели на рисунке 4.5.) </small></p>

<p><small>ACK прибывает через 467 миллисекунд после
повторной передачи. Значения A и D не обновляются,
потому что алгоритм Карна определяет
двусмысленность передачи. Следующий
отправляемый сегмент - это ACK в строке 4, однако
время для него не засекается, так как это всего
лишь подтверждение. (Время устанавливается
только для сегментов, содержащих данные.) </small></p>

<p><small>Когда отправляется первый сегмент данных
(сегмент 1 на рисунке 21.2), RTO не меняется, опять же в
соответствии с алгоритмом Карна. Текущее
значение, равное 24 секундам, повторно
используется до тех пор, пока не будет
осуществлено измерение RTT. Это означает, что RTO
для момента времени равного 0 на рисунке&nbsp;21.4
равно в действительности 24, однако мы не берем во
внимание эту точку. </small></p>

<p><small>Когда прибывает подтверждение на этот
первый сегмент данных (сегмент 2 на рисунке 21.2),
получено 3 тика часов, и наши показатели
устанавливаются следующим образом</small></p>

<p>&nbsp;</p>

<p><small>A = M + 0,5 = 1,5 + 0,5 = 2</small></p>

<p><small>D = A/2 = 1</small></p>

<p>&nbsp;</p>

<p><small>(Значение M равное 1,5 соответствует 3-м тикам
часов.) Предыдущие установки A и D в 0 и 3 были
сделаны для расчета первоначального RTO. Эти
установки предназначены для первого расчета
оценочных функций, с использованием первого
измерения RTT M. RTO рассчитывается следующим
образом</small></p>

<p>&nbsp;</p>

<p><small>RTO = A + 4D = 2 + 4 x 1 = 6 секунд</small></p>

<p>&nbsp;</p>

<p><small>Когда прибывает ACK на второй сегмент данных
(сегмент 5 на рисунке 21.2), отсчитан 1 тик часов (0,5
секунды), и наши показатели обновляются
следующим образом</small></p>

<p>&nbsp;</p>

<p><small>Err = M - A = 0,5 - 2 = -1,5</small></p>

<p><small>A = A + gErr = 2 - 0,125 x 1,5 = 1,8125</small></p>

<p><small>D = D + h(|Err| - D) = 1 + 0,25 x (1,5 - 1) = 1,125</small></p>

<p><small>RTO = A + 4D = 1,8125 + 4 x 1,125 = 6,3125</small></p>

<p>&nbsp;</p>

<p><small>Существует несколько тонкостей в
представлении Err, A и D, при расчетах с
фиксированной точкой, которая и используется в
действительности (однако мы показали для
простоты с плавающей точкой). Эта разница дает RTO
равное 6 секундам (а не 6,3125), как раз столько,
сколько было показано на рисунке 21.4 для момента
времени 1,871.</small></p>
<i><b>

<p><a NAME="t214014"></a>Медленный старт</p>
</b></i>

<p><small>Мы описали алгоритм медленного старта в
разделе <a HREF="tcp20.html#t206000">&quot;Медленный старт&quot;</a>
главы 20, а также видели его в действии на рисунке
21.2. </small></p>

<p><small>Первоначально по соединению отправляется
только один сегмент, и подтверждение на него
должно быть получено перед тем, как будет
отправлен другой сегмент. Когда сегмент 2 принят,
отправляются два следующих сегмента.</small></p>
<u><b>

<p><a NAME="t215000"></a>Пример переполнения</p>
</b></u>

<p><small>Давайте теперь рассмотрим передачу
сегментов данных. На рисунке 21.6 показана
зависимость стартового номера
последовательности сегмента от времени, когда
сегмент был отправлен. Это позволит нам более
наглядно представить процесс передачи данных.
Обычно точки, соответствующие данным, должны
двигаться вверх вправо, при этом наклон
соответствует скорости передачи. Повторные
передачи показаны отклонением графика вниз
вправо. </small></p>

<p><small>В начале раздела <a HREF="#t214000">&quot;Пример RTT&quot;</a>
этой главы мы сказали, что полное время передачи
составляло примерно 45 секунд, однако на этом
рисунке мы показали только 35 секунд. (Потому что,
именно 35 секунд потребовалось для передачи
только сегментов данных.) Первый сегмент данных
не передавался в течении 6,3 секунды после
отправки первого SYN, потому что первый SYN был
потерян при передаче и передан повторно (рисунок
21.5). После того как последний сегмент данных и FIN
были отправлены (момент времени 34,1 на рисунке 21.6),
потребовалось еще примерно 4,0 секунды на то,
чтобы принять последние 14 ACK от получателя перед
тем, как от получателя был получен FIN.<a NAME="t215001"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t21_6000.jpg" WIDTH="508" HEIGHT="356"></small></p>


<p ALIGN="CENTER"><small>Рисунок 21.6 Отправка 32768 байт данных
от slip на vangogh.</small></p>

<p>&nbsp;</p>

<p><small>На рисунке 21.6 мы сразу видим три повторные
передачи в моменты времени 10, 14 и 21. Во всех трех
случаях только один сегмент передается повторно,
потому что только одна точка оказалась ниже
предыдущих. </small></p>

<p><small>Давайте рассмотрим первый из этих
&quot;скачков вниз&quot; (в момент времени 10). Вывод
команды tcpdump мы рассмотрим вместе с рисунком 21.7.<a NAME="t215002"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t21_7000.jpg" WIDTH="531" HEIGHT="773"></small></p>


<p ALIGN="CENTER"><small>Рисунок 21.7 Обмен пакетами в
процессе повторной передачи в районе 10-секундной
метки.</small></p>

<p>&nbsp;</p>

<p><small>Мы удалили все объявления окна, за
исключением сегмента 72, который мы обсудим ниже.
slip всегда объявляет окно равное 4096, а vangogh
объявляет окно равное 8192. Сегменты на этом
рисунке пронумерованы как продолжение рисунка
21.2, где первый сегмент данных по соединению был с
номером 1. Как и на рисунке 21.2, сегменты
пронумерованы в соответствии с тем, как они
отправлялись или принимались на хосте slip, где
была запущена программа <a NAME="t215003"></a>tcpdump. Мы
также удалили несколько сегментов, которые не
имели отношения к нашему обсуждению (44, 47 и 49, а
также все ACK от vangogh). </small></p>

<p><small>Случилось так, что сегмент 45 либо потерялся,
либо пришел поврежденным - мы не можем сказать
этого определенно, основываясь на выводе
команды. Все что мы можем увидеть на хосте slip это
то, что было подтверждено все, за исключением
байта 6657 (сегмент 58), за которым следовали
следующие восемь ACK с тем же самым номером
последовательности. Прием сегмента 62, третьего
из дублированных ACK, вызвал повторную передачу
данных, начиная с номера последовательности 6657
(сегмент 63). В действительности, реализации,
происходящие от Berkeley, подсчитывают количество
принятых дублированных ACK, и когда принимается
третий, они подразумевают, что сегмент потерян, и
повторно передают только один сегмент, начиная с
этого номера последовательности. Подобное
поведение является частью <a NAME="t215004"></a>алгоритма
быстрой повторной передачи (fast retransmit), который
следует за алгоритмом быстрого восстановления
данных (fast recovery algorithm), которые мы обсудим в
разделе <a HREF="#t217000">&quot;Быстрая повторная передача
и алгоритм быстрого восстановления&quot;</a> этой
главы. </small></p>

<p><small>Обратите внимание на то, что после
повторной передачи (сегмент 63) отправитель
продолжает обычную передачу данных (сегменты 67, 69
и 71). TCP не ожидает того, что удаленный конец
подтвердит повторную передачу. </small></p>

<p><small>Давайте посмотрим, что происходит на
принимающем конце. Когда обычные данные приходят
последовательно (сегмент 43), принимающий TCP
передает 256 байт данных пользовательскому
процессу. Однако следующий принятый сегмент
(сегмент 46) не в порядке; стартовый номер
последовательности данных (6913) не является
следующим ожидаемым номером последовательности
(6657). TCP сохраняет 256 байт данных и отвечает
посредством ACK с самый большим номером
последовательности, который был принят успешно,
плюс один (6657). Следующие семь сегментов, принятых
vangogh (48, 50, 52, 54, 55, 57 и 59), также не в порядке. Данные
сохраняются принимающим TCP, и генерируются
дублированные ACK. </small></p>

<p><small>Таким образом, для TCP не существует способа
сообщить удаленному концу, что сегмент
отсутствует. Помимо этого TCP не может подтвердить
поврежденные данные. Все что может сделать vangogh в
подобном случае - это продолжать посылать ACK с
номером 6657. </small></p>

<p><small>Когда прибывают отсутствующие данные
(сегмент 63), принимающий TCP имеет в своем буфере
байты данных 6657-8960. Он передает эти 2304 байта
пользовательскому процессу. Все 2304 байта
подтверждены в сегменте 72. Также обратите
внимание на то, что этот ACK объявляет окно равное
5888 (8192 - 2304), так как пользовательский процесс не
имеет возможности прочитать 2304 байта, которые
уже готовы для него. </small></p>

<p><small>Если мы рассмотрим более подробно вывод
команды <a NAME="t215005"></a>tcpdump для моментов времени 14 и
21 на рисунке 21.6, то увидим, что они были вызваны
получением трех дублированных ACK, а это указывает
на то, что пакет был потерян. Во всех этих случаях
только один пакет был передан повторно. </small></p>

<p><small>Мы продолжим рассмотрение этого примера в
разделе <a HREF="#t218000">&quot;Пример переполнения
(продолжение)&quot;</a> этой главы, после того как
рассмотрим более подробно алгоритм
предотвращения переполнения.</small></p>
<u><b>

<p><a NAME="t216000"></a>Алгоритм предотвращения
переполнения</p>
</b></u>

<p><small>Медленный старт, который мы описали в
разделе <a HREF="tcp20.html#t206000">&quot;Медленный старт&quot;</a>
главы 20, это способ первоначально установить <a NAME="t216001"></a>поток данных по соединению. Однако, в
это же самое время мы достигнем предела у
промежуточного маршрутизатора, при котором
пакеты будут отбрасываться. Предотвращение
переполнения это способ, позволяющий
предотвратить потерю пакетов. Подробности можно
найти в [<a NAME="t216002"></a>Jacobson 1988]. </small></p>

<p><small>Предположение, на котором строится этот
алгоритм, заключается в том, что из-за различных
повреждений теряется очень малое число пакетов
(значительно меньше чем 1%), поэтому потеря
пакетов сигнализирует о том, что в каком-либо
месте сети между источником и назначением
появилось переполнение. Существуют два признака,
по которым можно определить, что пакеты теряются:
появление тайм-аутов и получение дублированных
ACK. (Мы видели последнее в разделе <a HREF="#t215000">&quot;Пример
переполнения&quot;</a> этой главы. Если же
использовать тайм-аут как показатель
возникновения переполнения, то нам потребуется
хороший алгоритм расчета RTT, примерно такой, как
описан в разделе <a HREF="#t213000">&quot;Определение
времени возврата&quot;</a>.) </small></p>

<p><small>Предотвращение переполнения и медленный
старт это независимые друг от друга алгоритмы,
более того, работающие с различными объектами.
Однако, когда возникает переполнение, мы хотим
замедлить скорость передачи пакетов по сети, а
затем использовать медленный старт, чтобы начать
все с начала. На практике эти алгоритмы
используются вместе. </small></p>

<p><small>Предотвращение переполнения и медленный
старт требуют, чтобы для каждого соединения были
определены две переменные: окно переполнения, <a NAME="t216003"></a>cwnd, и размер порога медленного старта, <a NAME="t216004"></a>ssthresh. Вместе алгоритмы работают
следующим образом:</small></p>

<p><small>Инициализация заданного соединения
устанавливает cwnd в один сегмент, а ssthresh в 65535 байт.
Подпрограмма вывода TCP определит, какое из
значений меньше: cwnd или окно, объявленное
получателем и никогда не пошлет больше
минимального значения. Предотвращение
переполнения это способ контролировать поток
данных, со стороны отправителя, тогда как
объявление окна это способ контролировать поток
данных, со стороны получателя. Первый основан на
оценке отправителем того, насколько переполнена
сеть, тогда как последний связан с величиной
доступного буферного пространства у получателя
для данного соединения. Когда возникает
переполнение (на что указывает тайм-аут или
получение дублированных ACK), одна половина
текущего размера окна (меньшее значение из
величин cwnd и размера окна, объявленного
получателем, но по меньшей мере два сегмента)
сохраняется в ssthresh. Более того, если мы узнали о
переполнении с помощью тайм-аута, cwnd
устанавливается в один сегмент (то есть
осуществляется медленный старт). Когда новые
данные подтверждены удаленным концом, cwnd
увеличивается, однако способ этого увеличения
зависит от того, работает ли алгоритм медленного
старта или предотвращения переполнения. Если cwnd
меньше или равно ssthresh, используется медленный
старт; иначе используется предотвращение
переполнения. Медленный старт продолжается до
тех пор, пока мы не достигнем половины пути до
того момента где были, когда возникло
переполнение (то есть, до того момента пока мы не
запишем половину размера окна, которое доставило
нам проблемы в шаге 2), после чего используется
алгоритм предотвращения переполнения. Медленный
старт требует, чтобы cwnd начиналась с одного
сегмента и увеличивалась на один сегмент каждый
раз при приеме ACK. Как указано в разделе <a HREF="tcp20.html#t206000">&quot;Медленный старт&quot;</a> главы 20,
это открывает окно экспотенциально: посылается
один сегмент, затем два, затем четыре и так далее.
Предотвращение переполнения требует, чтобы cwnd
увеличивалась на 1/cwnd плюс меньшая дробная часть
размера сегмента (размер сегмента, поделенный на
8) каждый раз, когда прибывает ACK. (Это ошибка
реализации, которая присутствовала во всех
релизах 4.3BSD и даже в 4.4BSD. Но этой ошибки нет в
будущих реализациях [Floyd 1994]. Обратите внимание на
то, что в примерах ниже в главе используется этот
термин, потому что примеры исполнялись на
реализации с ошибкой [см. рисунок 21.9 и рисунок
21.11]). Это увеличение посредством сложения, по
сравнению с экспотенциальным увеличением при
медленном старте. Мы хотим увеличивать cwnd по
крайней мере на один сегмент за каждый
промежуток времени равный времени возврата (вне
зависимости от того, сколько ACK было принято за
этот RTT), тогда как медленный старт увеличивает cwnd
на количество ACK принятых за время возврата.
Прибавление меньшей дробной части размера
сегмента позволяет быстрее открывать большие
окна.</small></p>

<p>&nbsp;</p>


<p>Релиз <a NAME="t216005"></a>4.3BSD
Tahoe, описанный в [<a NAME="t216006"></a>Leffler et al. 1989],
осуществляет медленный старт, только если
удаленный конец находится в другой сети. Это было
изменено в релизе <a NAME="t216007"></a>4.3BSD Reno таким
образом, что медленный старт осуществляется
всегда.</p>


<p>&nbsp;</p>

<p><small>На рисунке 21.8 приведено описание
медленного старта и предотвращения
переполнения. Мы показали размер cwnd и ssthresh в
блоках сегментов, тогда как в действительности
их размер измеряется в байтах.<a NAME="t216008"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t21_8000.jpg" WIDTH="442" HEIGHT="262"></small></p>


<p ALIGN="CENTER"><small>Рисунок 21.8 Медленный старт и
предотвращение переполнения.</small></p>

<p>&nbsp;</p>

<p><small>На этом рисунке мы предположили, что
переполнение возникает, когда cwnd имеет значение
равное 32 сегментам. ssthresh устанавливается в 16
сегментов, а cwnd устанавливается в 1 сегмент. Один
сегмент посылается в момент времени 0 и
предполагается, что ACK на него возвращается в
момент времени 1, cwnd увеличивается до 2 сегментов.
Затем отправляется два сегмента и
предполагается, что их ACK прибывают в момент
времени 2, cwnd увеличивается до 4 сегментов (по
одному разу на каждый ACK). Этот экспотенциальный
рост продолжается до тех пор, пока cwnd не будет
равно ssthresh, а именно после того как 8 ACK были
приняты между моментами времени 3 и 4. С этой точки
увеличение cwnd линейное, причем максимальный
увеличение - это увеличение на один сегмент за
период равный времени возврата. </small></p>

<p><small>Как видно из этого рисунка, термин
&quot;медленный старт&quot; не вполне корректен. Это,
скорее, замедление передачи пакетов, которое
вызвано переполнением, однако скорость
увеличения количества пакетов, отправленных в
сеть, увеличивается в течение медленного старта.
Скорость увеличения не уменьшается до тех пор,
пока не будет достигнуто значение ssthresh, когда
начинает действовать предотвращение
переполнения.</small></p>
<u><b>

<p><a NAME="t217000"></a>Быстрая повторная передача и
алгоритм быстрого восстановления </p>
</b></u>

<p><small>В тексте не приводится достаточно жесткого
разграничения между алгоритмом быстрой
повторной передачи и быстрого восстановления.
Это два абсолютно независимых алгоритма.
Алгоритм быстрой повторной передачи вступает в
действие, когда TCP определяет потерю сегмента и
номер потерянного сегмента по наличию
небольшого количества последователььных
дублированных подтверждений (ACK). Потерянный
сегмент передается повторно. Алгоритм быстрого
востановления говорит, что после быстрой
повторной передачи необходимо осуществить
предотвращение переполнения, а не медленный
старт. Алгоритм быстрой повторной передачи
впервые появился в 4.3BSD Tahoe, однако за ним
неправильно следовал медленный старт. Алгоритм
быстрого восстановления впервые был применен в
4.3BSD Reno. </small></p>

<p><small>В 1990 году [<a NAME="t217001"></a>Jacobson 1990b] алгоритм
предотвращения переполнения был модифицирован.
Мы уже видели эти модификации в действии в
примере переполнения (раздел <a HREF="#t215000">&quot;Пример
переполнения&quot;</a> этой главы). </small></p>

<p><small>Перед тем как познакомиться с этими
изменениями представьте, что TCP требует
сгенерировать немедленное подтверждение
(дублированный <a NAME="t217002"></a>ACK), когда принят
поврежденный сегмент. Этот дублированный ACK не
должен быть задержан. Цель дублированного ACK
заключается в том, чтобы сообщить удаленному
концу о том, что сегмент был получен
поврежденным, и сообщить, какой ожидается номер
последовательности. </small></p>

<p><small>Так как мы не знаем, было ли дублирование ACK
вызвано потерей сегмента или просто тем, что
изменился порядок следования сегментов, мы
ожидаем прихода небольшого количества
дублированных ACK. Это означает, что если сегменты
просто пришли в другом порядке, будет получено
только один или два дублированных ACK перед тем,
как перемешанные сегменты будут обработаны,
после чего будет сгенерирован новый ACK. Если же
последовательно пришло три или более
дублированных ACK, это уже является признаком
того, что сегмент был потерян (раздел <a HREF="#t215000">&quot;Пример
переполнения&quot;</a>). Мы осуществляем повторную
передачу отсутствующего сегмента, не ожидая
истечения таймера повторной передачи. Также мы
осуществляем предотвращение переполнения, но не
медленный старт. </small></p>

<p><small>На рисунке 21.7 мы видели, что медленный старт
не осуществлялся после того, как было принято три
дублированных ACK. Вместо этого отправитель
осуществил повторную передачу, за которой
следует три сегмента новых данных (сегменты 67, 69 и
71), перед тем как были получены подтверждения на
повторную передачу (сегмент 72). </small></p>

<p><small>Причина того, что в этом случае не был
применен медленный старт, заключается в том, что
получение дублированных ACK сообщило нечто
большее, нежели просто о потере одного пакета.
Так как получатель может только генерировать
дублированные ACK, когда прибывает еще один
сегмент, можно сказать, что этот сегмент вышел из
сети и находится в буфере получателя. Таким
образом, данные все еще двигаются между двумя
концами, и мы не хотим внезапно уменьшить поток,
воспользовавшись медленным cтартом. </small></p>

<p><small>Алгоритм функционирует следующим образом.</small></p>

<p><small>&nbsp;</small> 

<ol>
  <li><small>Когда принят третий дублированный ACK, ssthresh
    устанавливается равным половине текущего окна
    переполнения, cwnd.</small><p><small>Передается
    отсутствующий сегмент.</small></p>
    <p><small>Значение cwnd устанавливается в значение
    ssthresh плюс утроенное значение размера сегмента.</small></p>
  </li>
  <li><small>Каждый раз когда прибывает дублированный ACK,
    cwnd увеличивается на размер сегмента, и
    передается пакет (если это разрешено новым
    значением cwnd).</small></li>
  <li><small>Когда прибывает следующий ACK, который
    подтверждает новые данные, устанавливается cwnd
    равное ssthresh (значение, установленное в шаге 1). Это
    должно быть ACK на повторную передачу из шага 1,
    пришедшее через одно время возврата после
    повторной передачи. Этот ACK должен также
    подтверждать все промежуточные сегменты,
    отправленные между потерянным пакетом и
    получением первого дублированного ACK. Этот шаг
    осуществляется при предотвращении переполнения,
    так как мы наполовину замедлили скорость, с
    которой производилась передача в тот момент,
    когда пакет был потерян.</small></li>
</ol>

<p>&nbsp;</p>

<p><small>Мы увидим, что произойдет с переменными cwnd и
ssthresh, в следующем разделе.</small></p>
<u><b>

<p><a NAME="t218000"></a>Пример переполнения (продолжение)</p>
</b></u>

<p><small>Просматривая соединение с использованием <a NAME="t218001"></a>tcpdump и <a NAME="t218002"></a>отладочной опции
сокетов (которую мы описали в разделе <a HREF="#t214000">&quot;Пример
RTT&quot;</a>), мы можем увидеть значения cwnd и ssthresh при
передаче каждого сегмента. Если максимальный
размер сегмента (<a NAME="t218003"></a>MSS) равен 256 байт,
исходные значения cwnd и ssthresh будут равны 256 и 65535
соответственно. Каждый раз, когда принимается ACK,
cwnd увеличивается на значение MSS и принимает
значения 512, 768, 1024, 1280 и так далее. Предположим, что
переполнения не происходит, поэтому окно
переполнения достигнет значения окна,
объявленного получателем, а это, в свою очередь,
будет означать, что объявленное окно
ограничивает поток данных. </small></p>

<p><small>Однако нам интересно посмотреть, что
произойдет в случае возникновения переполнения.
Рассмотрим тот же пример из раздела <a HREF="#t214000">&quot;Пример
RTT&quot;</a>. В этом примере переполнение появлялось
четыре раза. Был тайм-аут при передаче исходного
SYN, который предназначался для установления
соединения (рисунок 21.5), после чего, в процессе
передачи данных, было потеряно три пакета
(рисунок 21.6). </small></p>

<p><small>На рисунке 21.9 показаны значения двух
переменных cwnd и ssthresh, когда осуществлялась
повторная передача исходного SYN, за которым
следовало семь первых сегментов данных. (Мы
показали обмен исходными сегментами данных и их
ACK на рисунке 21.2.) Переданные байты данных
показаны в формате вывода команды tcpdump: 1:257(256), что
означает байты с 1 по 256. </small></p>

<p><small>Когда возникает тайм-аут при передаче SYN,
ssthresh устанавливается в свое минимальное
значение (512 байт, что равно, в этом примере, двум
сегментам). cwnd устанавливается в один сегмент (256
байт), чтобы войти в фазу медленного старта. </small></p>

<p><small>Когда получены SYN и ACK, с этими переменными
ничего не происходит, так как новые данные не
были подтверждены. </small></p>

<p><small>Когда прибывает ACK 257, мы все еще находимся в
режиме медленного старта, так как cwnd меньше либо
равно ssthresh, поэтому cwnd увеличивается на 256. То же
самое происходит, когда прибывает ACK 513. </small></p>

<p><small>Когда прибывает ACK 769, мы больше не находимся
в режиме медленного старта, однако переходим в
режим предотвращения переполнения. Новое
значение cwnd рассчитывается следующим образом</small></p>

<p>&nbsp;</p>

<p><small>cwnd ╛ cwnd +
(разм.сегмента x разм.сегмента)/cwnd + разм.сегмента/8</small></p>

<p>&nbsp;</p>

<p><small>Это больше на 1/cwnd, чем то, что мы показали
ранее, принимая во внимание то, что cwnd
рассчитывается в действительности в байтах, а не
в сегментах. Для этого примера мы рассчитаем</small></p>

<p>&nbsp;</p>

<p><small>cwnd ╛ 768 + (256 x
256)/768 + 256/8<a NAME="t218004"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="703">
  <tr>
    <td WIDTH="15%" VALIGN="TOP" ROWSPAN="2" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Номер сегмента (рисунок 21.2)</small></td>
    <td WIDTH="62%" VALIGN="TOP" COLSPAN="3" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Действие</small></td>
    <td WIDTH="23%" VALIGN="TOP" COLSPAN="2" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Переменная</small></td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Отправлено</small></td>
    <td WIDTH="16%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Получено</small></td>
    <td WIDTH="24%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Комментарий</small></td>
    <td WIDTH="9%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>cwnd</small></td>
    <td WIDTH="14%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>ssthresh</small></td>
  </tr>
  <tr>
    <td WIDTH="15%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="22%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="16%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="24%" VALIGN="TOP"><p ALIGN="CENTER"><small>инициализация</small></td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>256</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>65535</small></td>
  </tr>
  <tr>
    <td WIDTH="15%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="22%" VALIGN="TOP"><p ALIGN="CENTER"><small>SYN</small></td>
    <td WIDTH="16%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="24%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="15%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="22%" VALIGN="TOP"><p ALIGN="CENTER">&nbsp;</p>
    <p ALIGN="CENTER"><small>SYN</small></td>
    <td WIDTH="16%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="24%" VALIGN="TOP"><p ALIGN="CENTER"><small>тайм-аут</small></p>
    <p ALIGN="CENTER"><small>повторная передача</small></td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>256</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>512</small></td>
  </tr>
  <tr>
    <td WIDTH="15%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="22%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>SYN, ACK</small></td>
    <td WIDTH="24%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="15%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="22%" VALIGN="TOP"><p ALIGN="CENTER"><small>ACK</small></td>
    <td WIDTH="16%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="24%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="22%" VALIGN="TOP"><p ALIGN="CENTER"><small>1:257(256)</small></td>
    <td WIDTH="16%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="24%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>2</small></td>
    <td WIDTH="22%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>ACK 257</small></td>
    <td WIDTH="24%" VALIGN="TOP"><p ALIGN="CENTER"><small>медленный
    старт</small></td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>512</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>512</small></td>
  </tr>
  <tr>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>3</small></td>
    <td WIDTH="22%" VALIGN="TOP"><p ALIGN="CENTER"><small>257:513(256)</small></td>
    <td WIDTH="16%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="24%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>4</small></td>
    <td WIDTH="22%" VALIGN="TOP"><p ALIGN="CENTER"><small>513:769(256)</small></td>
    <td WIDTH="16%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="24%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>5</small></td>
    <td WIDTH="22%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>ACK 513</small></td>
    <td WIDTH="24%" VALIGN="TOP"><p ALIGN="CENTER"><small>медленный
    старт</small></td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>768</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>512</small></td>
  </tr>
  <tr>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>6</small></td>
    <td WIDTH="22%" VALIGN="TOP"><p ALIGN="CENTER"><small>769:1025(256)</small></td>
    <td WIDTH="16%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="24%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>7</small></td>
    <td WIDTH="22%" VALIGN="TOP"><p ALIGN="CENTER"><small>1025:1281(256)</small></td>
    <td WIDTH="16%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="24%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>8</small></td>
    <td WIDTH="22%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>ACK 769</small></td>
    <td WIDTH="24%" VALIGN="TOP"><p ALIGN="CENTER"><small>предотвращение
    переполнения</small></td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>885</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>512</small></td>
  </tr>
  <tr>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>9</small></td>
    <td WIDTH="22%" VALIGN="TOP"><p ALIGN="CENTER"><small>1281:1537(256)</small></td>
    <td WIDTH="16%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="24%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>10</small></td>
    <td WIDTH="22%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>ACK 1025</small></td>
    <td WIDTH="24%" VALIGN="TOP"><p ALIGN="CENTER"><small>предотвращение
    переполнения</small></td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>991</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>512</small></td>
  </tr>
  <tr>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>11</small></td>
    <td WIDTH="22%" VALIGN="TOP"><p ALIGN="CENTER"><small>1537:1793(256)</small></td>
    <td WIDTH="16%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="24%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="9%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="15%" VALIGN="TOP"><p ALIGN="CENTER"><small>12</small></td>
    <td WIDTH="22%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>ACK 1281</small></td>
    <td WIDTH="24%" VALIGN="TOP"><p ALIGN="CENTER"><small>предотвращение
    переполнения</small></td>
    <td WIDTH="9%" VALIGN="TOP"><p ALIGN="CENTER"><small>1089</small></td>
    <td WIDTH="14%" VALIGN="TOP"><p ALIGN="CENTER"><small>512</small></td>
  </tr>
</table>


<p><small>Рисунок 21.9 Пример предотвращения
переполнения.</small></p>

<p>&nbsp;</p>

<p><small>что равно 885 (с использованием
целочисленной арифметики). Когда прибывает
следующий ACK 1025, мы рассчитаем</small></p>

<p>&nbsp;</p>

<p><small>cwnd ╛ 885 + (256 x
256)/885 + 256/8</small></p>

<p>&nbsp;</p>

<p><small>что равно 991. </small></p>

<p><small>Это суммарное увеличение cwnd продолжается
до появления первой повторной передачи, которая
происходит в районе 10-секундной метки на рисунке
21.6. Рисунок 21.10 это график для тех же самых данных,
которые приведены на рисунке 21.6, но сюда
добавлены значения cwnd. </small></p>

<p><small>Первые шесть значений cwnd на этом рисунке -
это значения, которые мы рассчитали для рисунка
21.9. На этом рисунке невозможно указать разницу
между экспотенциальным увеличением в течение
медленного старта и суммарным увеличением в
течение предотвращения переполнения, потому что
фаза медленного старта проходит очень быстро. </small></p>

<p><small>Нам необходимо объяснить, что происходит в
трех точках, когда возникает повторная передача.
Вспомним, что каждая повторная передача
возникает из-за того, что были приняты три
дублированных ACK (это указывает на то, что пакет
был потерян). Здесь вступает в действие алгоритм
быстрой повторной передачи, описанный в разделе <a HREF="#t217000">&quot;Быстрая повторная передача и
алгоритм быстрого восстановления&quot;</a>. ssthresh
сразу же устанавливается в половину размера
окна, который соответствовал тому моменту, когда
была осуществлена повторная передача, однако cwnd
позволяет продолжать увеличение до тех пор, пока
принимаются дублированные ACK, так как каждый
дублированный ACK означает, что сегмент все еще
находится в сети (принимающий TCP буферизировал
его, ожидая прибытия отсутствующих данных). </small></p>

<p><small>Рисунок 21.10 аналогичен рисунку 21.9 и
показывает значения cwnd и ssthresh. Номера сегментов в
первой колонке соответствуют рисунку 21.7.<a NAME="t218005"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t21_1000.jpg" WIDTH="508" HEIGHT="394"></small></p>


<p ALIGN="CENTER"><small>Рисунок 21.10 Значения cwnd и номера
отправляемых последовательностей, при передаче
данных.</small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="785">
  <tr>
    <td WIDTH="17%" VALIGN="TOP" ROWSPAN="2" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Номер сегмента</small></p>
    <p ALIGN="CENTER"><small>(рисунок 21.7)</small></td>
    <td WIDTH="64%" VALIGN="TOP" COLSPAN="3" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Действие</small></td>
    <td WIDTH="19%" VALIGN="TOP" COLSPAN="2" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Переменная</small></td>
  </tr>
  <tr>
    <td WIDTH="21%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Отправлено</small></td>
    <td WIDTH="13%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Получено</small></td>
    <td WIDTH="30%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Комментарий</small></td>
    <td WIDTH="8%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>cwnd</small></td>
    <td WIDTH="11%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>ssthresh</small></td>
  </tr>
  <tr>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>58</small></td>
    <td WIDTH="21%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>ACK 6657</small></td>
    <td WIDTH="30%" VALIGN="TOP"><p ALIGN="CENTER"><small>подтверждение
    новых данных</small></td>
    <td WIDTH="8%" VALIGN="TOP"><p ALIGN="CENTER"><small>2426</small></td>
    <td WIDTH="11%" VALIGN="TOP"><p ALIGN="CENTER"><small>512</small></td>
  </tr>
  <tr>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>59</small></td>
    <td WIDTH="21%" VALIGN="TOP"><p ALIGN="CENTER"><small>8705:8961(256)</small></td>
    <td WIDTH="13%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="30%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="11%" VALIGN="TOP">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>60</small></td>
    <td WIDTH="21%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>ACK 6657</small></td>
    <td WIDTH="30%" VALIGN="TOP"><p ALIGN="CENTER"><small>дублированный
    ACK номер 1</small></td>
    <td WIDTH="8%" VALIGN="TOP"><p ALIGN="CENTER"><small>2426</small></td>
    <td WIDTH="11%" VALIGN="TOP"><p ALIGN="CENTER"><small>512</small></td>
  </tr>
  <tr>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>61</small></td>
    <td WIDTH="21%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>ACK 6657</small></td>
    <td WIDTH="30%" VALIGN="TOP"><p ALIGN="CENTER"><small>дублированный
    ACK номер 2</small></td>
    <td WIDTH="8%" VALIGN="TOP"><p ALIGN="CENTER"><small>2426</small></td>
    <td WIDTH="11%" VALIGN="TOP"><p ALIGN="CENTER"><small>512</small></td>
  </tr>
  <tr>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>62</small></td>
    <td WIDTH="21%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>ACK 6657</small></td>
    <td WIDTH="30%" VALIGN="TOP"><p ALIGN="CENTER"><small>дублированный
    ACK номер 3</small></td>
    <td WIDTH="8%" VALIGN="TOP"><p ALIGN="CENTER"><small>1792</small></td>
    <td WIDTH="11%" VALIGN="TOP"><p ALIGN="CENTER"><small>1024</small></td>
  </tr>
  <tr>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>63</small></td>
    <td WIDTH="21%" VALIGN="TOP"><p ALIGN="CENTER"><small>6657:6913(256)</small></td>
    <td WIDTH="13%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="30%" VALIGN="TOP"><p ALIGN="CENTER"><small>повторная
    передача</small></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="11%" VALIGN="TOP">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>64</small></td>
    <td WIDTH="21%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>ACK 6657</small></td>
    <td WIDTH="30%" VALIGN="TOP"><p ALIGN="CENTER"><small>дублированный
    ACK номер 4</small></td>
    <td WIDTH="8%" VALIGN="TOP"><p ALIGN="CENTER"><small>2048</small></td>
    <td WIDTH="11%" VALIGN="TOP"><p ALIGN="CENTER"><small>1024</small></td>
  </tr>
  <tr>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>65</small></td>
    <td WIDTH="21%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>ACK 6657</small></td>
    <td WIDTH="30%" VALIGN="TOP"><p ALIGN="CENTER"><small>дублированный
    ACK номер 5</small></td>
    <td WIDTH="8%" VALIGN="TOP"><p ALIGN="CENTER"><small>2304</small></td>
    <td WIDTH="11%" VALIGN="TOP"><p ALIGN="CENTER"><small>1024</small></td>
  </tr>
  <tr>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>66</small></td>
    <td WIDTH="21%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>ACK 6657</small></td>
    <td WIDTH="30%" VALIGN="TOP"><p ALIGN="CENTER"><small>дублированный
    ACK номер 6</small></td>
    <td WIDTH="8%" VALIGN="TOP"><p ALIGN="CENTER"><small>2560</small></td>
    <td WIDTH="11%" VALIGN="TOP"><p ALIGN="CENTER"><small>1024</small></td>
  </tr>
  <tr>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>67</small></td>
    <td WIDTH="21%" VALIGN="TOP"><p ALIGN="CENTER"><small>8961:9217(256)</small></td>
    <td WIDTH="13%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="30%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="11%" VALIGN="TOP">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>68</small></td>
    <td WIDTH="21%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>ACK 6657</small></td>
    <td WIDTH="30%" VALIGN="TOP"><p ALIGN="CENTER"><small>дублированный
    ACK номер 7</small></td>
    <td WIDTH="8%" VALIGN="TOP"><p ALIGN="CENTER"><small>2816</small></td>
    <td WIDTH="11%" VALIGN="TOP"><p ALIGN="CENTER"><small>1024</small></td>
  </tr>
  <tr>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>69</small></td>
    <td WIDTH="21%" VALIGN="TOP"><p ALIGN="CENTER"><small>9217:9473(256)</small></td>
    <td WIDTH="13%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="30%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="11%" VALIGN="TOP">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>70</small></td>
    <td WIDTH="21%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>ACK 6657</small></td>
    <td WIDTH="30%" VALIGN="TOP"><p ALIGN="CENTER"><small>дублированный
    ACK номер 8</small></td>
    <td WIDTH="8%" VALIGN="TOP"><p ALIGN="CENTER"><small>3072</small></td>
    <td WIDTH="11%" VALIGN="TOP"><p ALIGN="CENTER"><small>1024</small></td>
  </tr>
  <tr>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>71</small></td>
    <td WIDTH="21%" VALIGN="TOP"><p ALIGN="CENTER"><small>9473:9729(256)</small></td>
    <td WIDTH="13%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="30%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="11%" VALIGN="TOP">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="17%" VALIGN="TOP"><p ALIGN="CENTER"><small>72</small></td>
    <td WIDTH="21%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="13%" VALIGN="TOP"><p ALIGN="CENTER"><small>ACK 8961</small></td>
    <td WIDTH="30%" VALIGN="TOP"><p ALIGN="CENTER"><small>подтверждение
    новых данных</small></td>
    <td WIDTH="8%" VALIGN="TOP"><p ALIGN="CENTER"><small>1280</small></td>
    <td WIDTH="11%" VALIGN="TOP"><p ALIGN="CENTER"><small>1024</small></td>
  </tr>
</table>


<p><small>Рисунок 21.11 Пример предотвращения
переполнения (продолжение).</small></p>

<p>&nbsp;</p>

<p><small>Значения cwnd увеличиваются постоянно, от
последнего значения на рисунке 21.9 для сегмента 12
(1089), до первого значения на рисунке 21.11 для
сегмента 58 (2426). Значение <a NAME="t218006"></a>ssthresh
осталось тем же самым (512), так как за этот период
не было осуществлено повторных передач. </small></p>

<p><small>Когда прибыли первые два дублированные ACK
(сегменты 60 и 61), они просто подсчитываются
(третий дублированный ACK не прибыл), а cwnd остается
неизменным. (Эта неизменяющаяся часть рисунка
21.10, предваряет первую повторную передачу.)
Однако когда прибывает третий ACK, ssthresh
устанавливается в значение равное половине cwnd.
cwnd устанавливается в значение ssthresh плюс размер
сегмента, умноженный на количество
дублированных ACK (1024 + 3 x 256). Затем осуществляется
повторная передача. </small></p>

<p><small>Прибывает еще пять дублированных ACK
(сегменты 64-66, 68 и 70), при этом cwnd каждый раз
увеличивается на размер сегмента. Наконец,
прибывает новый ACK (сегмент 72), и cwnd
устанавливается в значение ssthresh (1024), при этом
стартует стандартный алгоритм предотвращения
переполнения. Так как cwnd меньше или равно ssthresh
(они равны), к cwnd добавляется размер сегмента, при
этом получается значение 1280. Когда прибывает
следующий ACK (который не показан на рисунке 21.11),
cwnd больше чем ssthresh, поэтому cwnd устанавливается в
значение 1363. </small></p>

<p><small>В течение фазы быстрой повторной передачи и
быстрого восстановления мы передаем новые
данные после получения дублированных ACK в
сегментах 66, 68 и 70, однако не после получения
дублированных ACK в сегментах 64 и 65. Причина этого
заключается в значении cwnd по сравнению с
количеством неподтвержденных байтов данных.
Когда прибывает сегмент 64, cwnd становится равным
2048, однако мы имеем 2304 неподтвержденных байта
(девять сегментов: 46, 48, 50, 52, 54, 55, 57, 59 и 63). Мы ничего
не можем послать. Когда прибывает сегмент 65, cwnd
становится равным 2304, поэтому мы все еще ничего
не можем отправить. Однако, когда прибывает
сегмент 66, cwnd становится равным 2560, теперь мы
можем послать новый сегмент данных. Точно так же,
когда прибывает сегмент 68, cwnd становится равным
2816, что больше чем 2560 байт неподтвержденных
данных, таким образом, мы можем послать еще один
новый сегмент данных. То же самое происходит,
когда прибывает сегмент 70. </small></p>

<p><small>Когда в момент времени 14,3 происходит
следующая повторная передача (см. рисунок 21.10),
которая также вызвана приемом трех
дублированных ACK, мы видим такое же увеличение cwnd
как если бы прибыл еще один дублированный ACK,
после чего происходит уменьшение до 1024. </small></p>

<p><small>Повторная передача в момент времени 21,1 на
рисунке 21.10 также происходит при приходе
дублированных ACK. Мы получили еще три
дублированных ACK после повторной передачи,
поэтому мы видим три дополнительных увеличения
cwnd, после чего следует уменьшение до 1280. Для
остальной передачи cwnd увеличивается линейно с
окончательным значением 3615.</small></p>
<u><b>

<p><a NAME="t219000"></a>Показатели на маршрут</p>
</b></u>

<p><small>Более новые реализации TCP хранят
большинство из показателей, которые мы описали в
этой главе в записях таблицы маршрутизации.
Предположим, что TCP соединение закрыто, при этом
по соединению было отправлено достаточное
количество данных, чтобы получить статистику, и
запись в таблице маршрутизации для
определенного пункта назначения не является
маршрутом по умолчанию. При выполнении этих
условий в записи таблицы маршрутизации
сохраняется следующая информация (эта
информация будет использована при следующих
обращениях к этой записи): хэшированный RTT,
хэшированное среднее отклонение и порог
медленного старта. Понятие &quot;достаточное
количество данных&quot; - означает 16 окон данных.
При этом можно получить 16 примеров RTT, что
позволяют фильтру хэшированного RTT получить
значение с отклонением в пределах 5% от реального.
</small></p>

<p><small>Помимо этого, администратор может
воспользоваться командой <a NAME="t219001"></a>route(8) ,
чтобы установить показатели для заданного
маршрута: три показателя, упомянутых в
предыдущем параграфе, а также MTU, <a NAME="t219002"></a>емкость
исходящего канала в зависимости от полосы
пропускания (раздел <a HREF="tcp20.html#t207000">&quot;Пропускная
способность для неинтерактивных данных&quot;</a>
главы 20) и емкость входящего канала в зависимости
от полосы пропускания. </small></p>

<p><small>Когда устанавливается новое TCP соединение,
либо активное, либо пассивное, и пункт таблицы
маршрутизации, который используется для этого
соединения, имеет значения для этих показателей,
соответствующие переменные инициализируются
значениями показателей.</small></p>
<u><b>

<p><a NAME="t21A000"></a>ICMP ошибки</p>
</b></u>

<p><small>Давайте посмотрим, как TCP обрабатывает ICMP
ошибки, которые возвращаются по соединению. В
основном TCP обрабатывает следующие ICMP ошибки: <a NAME="t21A001"></a>подавление источника, <a NAME="t21A002"></a>хост
недоступен и <a NAME="t21A003"></a>сеть недоступна. </small></p>

<p><small>Текущие реализации (производные от Berkeley)
обрабатывают эти ICMP ошибки следующим образом:</small>

<ul>
  <li><small>При получении подавления источника, окно
    переполнения, cwnd, устанавливается в один сегмент,
    чтобы осуществить медленный старт, однако порог
    медленного старта, ssthresh, не изменяется, таким
    образом, окно будет открыто (ограничивается
    размером окна и временем возврата), пока не
    возникнет переполнение. </small></li>
  <li><small>Получение ошибки о недоступности хоста или
    недоступности сети игнорируется, так как эти две
    ошибки воспринимаются как
    &quot;кратковременные&quot;. Это может произойти из-за
    того, что промежуточный маршрутизатор вышел из
    строя, и потребуется несколько минут на то, чтобы
    протокол маршрутизации установил
    альтернативный маршрут. В течение этого периода
    может возникнуть любая из этих двух ICMP ошибок,
    однако соединение не должно быть разорвано.
    Вместо этого TCP старается отправить данные, на
    которые была сгенерирована ошибка, однако, они
    могут быть отброшены по тайм-ауту. (Обратитесь к
    рисунку 21.1, на котором показано, что TCP не
    разрывает соединение в течение 9 минут.) Текущие
    реализации Berkeley фиксируют возникшие ICMP ошибки, и
    если соединение разорвано по тайм-ауту, ICMP ошибка
    транслируется в более понятный код ошибки,
    который выглядит как &quot;connection timed out&quot;
    (соединение закрыто по тайм-ауту).</small></li>
</ul>

<p>&nbsp;</p>


<p>Более ранние
реализации BSD некорректно разрывали соединение,
когда приходила ICMP ошибка о недоступности хоста
или недоступности сети.</p>


<p>&nbsp;</p>
<i><b>

<p>Пример</p>
</b></i>

<p><small>Мы можем посмотреть, как ICMP ошибка о
недоступности хоста обрабатывается на нашем SLIP
канале, когда он погашен в середине соединения.
Мы установили соединение с хоста slip на хост aix. (На
рисунке, находящемся на внутренней стороне
обложки, мы видим, что это соединение проходит
через SLIP канал.) После установления соединения и
передачи какого-то количества данных, SLIP канал
между маршрутизаторами sun и netb погашен. При этом
запись, соответствующая маршруту по умолчанию в
sun (которую мы показывали на <a HREF="tcp09.html#t093001">рисунке
9.2</a>), будет удалена. Ожидается, что sun затем будет
отвечать на IP датаграммы, направляемые в Ethernet
сеть 140.252.1, ошибкой ICMP о недоступности хоста. Мы
хотим посмотреть, как TCP обрабатывает эти ICMP
ошибки. </small></p>

<p><small>Здесь приведена интерактивная сессия на
хосте slip:</small></p>

<p>&nbsp;</p>


<p><br>
slip % <b>sock aix echo </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; запускаем
программу sock<br>
<b>test line </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим
эту строку<br>
test line
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; она
отображается эхом<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; в
этом месте SLIP канал выключен<br>
<b>another line </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; затем
вводим эту строку и смотрим повторные передачи<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; здесь
SLIP канал восстановлен<br>
another line
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; и
происходит обмен строкой и ее эхом<br>
<b>line number 3</b><br>
line number 3<br>
<b>the last line</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SLIP
канал погашен и не восстановлен<br>
read error: No route to host
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCP
в конце концов закрывает соединение<br>
</p>


<p>&nbsp;</p>

<p><small>На рисунке 21.12 показан соответствующий
вывод команды tcpdump, полученный на маршрутизаторе
bsdi. (Установление соединения и все объявления
окна удалены.) Мы подсоединились к эхо серверу на
хосте aix и напечатали &quot;test line&quot; (строка 1). Она
отразилась эхом (строка 2), и эхо было
подтверждено (строка 3). Затем мы погасили SLIP
канал. </small></p>

<p><small>Затем ввели &quot;another line&quot; (строка 3) и
ожидаем, что TCP отработает тайм-аут и повторно
передаст сообщение. И действительно, эта строка
отправляется шесть раз перед тем, как будет
получен отклик. Строки 4-13 показывают первую
передачу и следующие четыре повторные передачи,
каждая из которых генерирует ICMP ошибку о
недоступности хоста с маршрутизатора sun. Это как
раз то, что мы ожидали: IP датаграммы, двигаются от
slip к маршрутизатору bsdi (который имеет маршрут по
умолчанию, указывающий на sun) и затем на sun, где и
находится поврежденный канал. </small></p>

<p><small>Пока происходят эти повторные передачи, SLIP
канал восстанавливается, и повторная передача в
строке 14 достигают пункта назначения. Строка 15
это эхо от aix, а строка 16 - подтверждение на эхо. </small></p>

<p><small>Можно сделать вывод, что TCP игнорирует ICMP
ошибку о недоступностии хоста и продолжает
осуществлять повторные передачи. Мы также видим
ожидаемое <a NAME="t21A005"></a>экспотенциальное
наращивание времени в каждом тайм-ауте при
повторной передаче: первый возникает через 2,5
секунды, затем умножается на 2 (при этом
длительность тайм-аута составляет 5 секунд),
затем на 4 (10 секунд), затем на 8 (20 секунд) и затем
на 16 (40 секунд). </small></p>

<p><small>После чего мы напечатали третью строку
ввода (&quot;line number 3&quot;) и увидели, что она
отправлена в строке 17, отражена эхом в строке 18, и
эхо подтверждено в строке 19. </small></p>

<p><small>Сейчас мы хотим посмотреть, что произойдет,
когда TCP осуществляет повторную передачу, а затем
прекращает попытки после получения ICMP ошибки о
недоступности хоста. Для этого мы снова
выключаем SLIP канал. После того как канал
выключен, мы печатаем &quot;the last line&quot; и видим, что
она передается 13 раз перед тем, как TCP прекращает
попытки. (Строки 30-43 удалены из вывода. В них
показаны дополнительные повторные передачи.) </small></p>

<p><small>Необходимо обратить внимание на одну
деталь которая, заключается в том, что сообщение
об ошибке печатается нашей программой sock, когда
она в конце концов прекращает работу: &quot;No route to
host&quot;. (Нет маршрута к хосту.) Это соответствует
ошибке операцинной системы Unix, которая, в свою
очередь соответствует ICMP ошибке о недоступности
хоста (<a HREF="tcp06.html#t066001">рисунок 6.12</a>). Значит, TCP
сохраняет ICMP ошибку, которую он получил по
соединению, и когда он в конце концов прекращает
свою работу, то печатает эту ошибку вместо
&quot;Connection timed out&quot; (соединение закрыто по
тайм-ауту). </small></p>

<p><small>И в заключение, обратите внимание на то, что
временные промежутки между повторными
передачами в строках 22-46 сравнимы с промежутками
в строках&nbsp;6-14. Это происходит из-за того, что TCP
обновил свои оценочные функции, когда третья
строка, которую мы напечатали, была отправлена и
подтверждена без повторных передач в строках 17-19.
Исходный тайм-аут повторной передачи в настоящее
время равен 3 секундам, при этом последующие
значения будут равны 6, 12, 24, 48 и затем верхний
предел 64.<a NAME="t21A006"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp;&nbsp;&nbsp;&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slip.1035
&gt; aix.echo: P 1:11(10) ack 1<br>
2&nbsp;&nbsp;&nbsp;&nbsp; 0.212271 (&nbsp; 0.2123)&nbsp;&nbsp;&nbsp;&nbsp; aix.echo &gt;
slip.1035: P 1:11(10) ack 11<br>
3&nbsp;&nbsp;&nbsp;&nbsp; 0.310685 (&nbsp; 0.0984)&nbsp;&nbsp;&nbsp;&nbsp; slip.1035 &gt;
aix.echo: . ack 11<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; здесь
SLIP канал выключен<br>
<br>
4&nbsp;&nbsp; 174.758100 (174.4474)&nbsp;&nbsp;&nbsp;&nbsp; slip.1035 &gt; aix.echo: P
11:24(13) ack 11<br>
5&nbsp;&nbsp; 174.759017 (&nbsp; 0.0009)&nbsp;&nbsp;&nbsp;&nbsp; sun &gt; slip: icmp: host
aix unreachable<br>
<br>
6&nbsp;&nbsp; 177.150439 (&nbsp; 2.3914)&nbsp;&nbsp;&nbsp;&nbsp; slip.1035 &gt; aix.echo:
P 11:24(13) ack 11<br>
7&nbsp;&nbsp; 177.151271 (&nbsp; 0.0008)&nbsp;&nbsp;&nbsp;&nbsp; sun &gt; slip: icmp: host
aix unreachable <br>
<br>
8&nbsp;&nbsp; 182.150200 (&nbsp; 4.9989)&nbsp;&nbsp;&nbsp;&nbsp; slip.1035 &gt; aix.echo:
P 11:24(13) ack 11<br>
9&nbsp;&nbsp; 182.151189 (&nbsp; 0.0010)&nbsp;&nbsp;&nbsp;&nbsp; sun &gt; slip: icmp: host
aix unreachable<br>
<br>
10&nbsp;&nbsp; 192.149671 (&nbsp; 9.9985)&nbsp;&nbsp;&nbsp;&nbsp; slip.1035 &gt; aix.echo:
P 11:24(13) ack 11<br>
11&nbsp;&nbsp; 192.150608 (&nbsp; 0.0009)&nbsp;&nbsp;&nbsp;&nbsp; sun &gt; slip: icmp:
host aix unreachable<br>
<br>
12&nbsp;&nbsp; 212.148783 ( 19.9982)&nbsp;&nbsp;&nbsp;&nbsp; slip.1035 &gt; aix.echo: P
11:24(13) ack 11<br>
13&nbsp;&nbsp; 212.149786 (&nbsp; 0.0010)&nbsp;&nbsp;&nbsp;&nbsp; sun &gt; slip: icmp:
host aix unreachable<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; здесь
SLIP канал включен<br>
<br>
14&nbsp;&nbsp; 252.146774 ( 39.9970)&nbsp;&nbsp;&nbsp;&nbsp; slip.1035 &gt; aix.echo: P
11:24(13) ack 11<br>
15&nbsp;&nbsp; 252.439257 (&nbsp; 0.2925)&nbsp;&nbsp;&nbsp;&nbsp; aix.echo &gt; slip.1035:
P 11:24(13) ack 24<br>
16&nbsp;&nbsp; 252.505331 (&nbsp; 0.0661)&nbsp;&nbsp;&nbsp;&nbsp; slip.1035 &gt; aix.echo:
. ack 24<br>
<br>
17&nbsp;&nbsp; 261.977246 (&nbsp; 9.4719)&nbsp;&nbsp;&nbsp;&nbsp; slip.1035 &gt; aix.echo:
P 24:38(14) ack 24<br>
18&nbsp;&nbsp; 262.158758 (&nbsp; 0.1815)&nbsp;&nbsp;&nbsp;&nbsp; aix.echo &gt; slip.1035:
P 24:38(14) ack 38<br>
19&nbsp;&nbsp; 262.305086 (&nbsp; 0.1463)&nbsp;&nbsp;&nbsp;&nbsp; slip.1035 &gt; aix.echo:
. ack 38<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; здесь
SLIP канал выключен<br>
<br>
20&nbsp;&nbsp; 458.155330 (195.8502)&nbsp;&nbsp;&nbsp;&nbsp; slip.1035 &gt; aix.echo: P
38:52(14) ack 38<br>
21&nbsp;&nbsp; 458.156163 (&nbsp; 0.0008)&nbsp;&nbsp;&nbsp;&nbsp; sun &gt; slip: icmp:
host aix unreachable<br>
<br>
22&nbsp;&nbsp; 461.136904 (&nbsp; 2.9807)&nbsp;&nbsp;&nbsp;&nbsp; slip.1035 &gt; aix.echo:
P 38:52(14) ack 38<br>
23&nbsp;&nbsp; 461.137826 (&nbsp; 0.0009)&nbsp;&nbsp;&nbsp;&nbsp; sun &gt; slip: icmp:
host aix unreachable<br>
<br>
24&nbsp;&nbsp; 467.136461 (&nbsp; 5.9986)&nbsp;&nbsp;&nbsp;&nbsp; slip.1035 &gt; aix.echo:
P 38:52(14) ack 38<br>
25&nbsp;&nbsp; 467.137385 (&nbsp; 0.0009)&nbsp;&nbsp;&nbsp;&nbsp; sun &gt; slip: icmp:
host aix unreachable<br>
<br>
26&nbsp;&nbsp; 479.135811 ( 11.9984)&nbsp;&nbsp;&nbsp;&nbsp; slip.1035 &gt; aix.echo: P
38:52(14) ack 38<br>
27&nbsp;&nbsp; 479.136647 (&nbsp; 0.0008)&nbsp;&nbsp;&nbsp;&nbsp; sun &gt; slip: icmp:
host aix unreachable<br>
<br>
28&nbsp;&nbsp; 503.134816 ( 23.9982)&nbsp;&nbsp;&nbsp;&nbsp; slip.1035 &gt; aix.echo: P
38:52(14) ack 38<br>
29&nbsp;&nbsp; 503.135740 (&nbsp; 0.0009)&nbsp;&nbsp;&nbsp;&nbsp; sun &gt; slip: icmp:
host aix unreachable<br>
<br>
здесь удалено 14 строк вывода<br>
<br>
44&nbsp; 1000.219573 ( 64.0959)&nbsp;&nbsp;&nbsp;&nbsp; slip.1035 &gt; aix.echo: P
38:52(14) ack 38<br>
45&nbsp; 1000.220503 (&nbsp; 0.0009)&nbsp;&nbsp;&nbsp;&nbsp; sun &gt; slip: icmp: host aix
unreachable<br>
<br>
46&nbsp; 1064.201281 ( 63.9808)&nbsp;&nbsp;&nbsp;&nbsp; slip.1035 &gt; aix.echo: R
52:52(0) ack 38<br>
47&nbsp; 1064.202182 (&nbsp; 0.0009)&nbsp;&nbsp;&nbsp;&nbsp; sun &gt; slip: icmp: host aix
unreachable<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 21.12 Обработка TCP полученной ICMP
ошибки о недоступности хоста.</small></p>
<u><b>

<p><a NAME="t21B000"></a>Пересборка пакетов</p>
</b></u>

<p><small>Когда TCP отрабатывает тайм-ауты и
осуществляет повторные передачи, он не должен
повторно передавать идентичные сегменты (если
исходно было 10 пакетов по одному байту, то при
повторной передаче можно передать 1 пакет
размером десять байт). Вместо этого, TCP разрешено
осуществлять пересборку пакетов (repacketization),
отправляя сегменты большего размера, что может
увеличить производительность. (В
действительности, сегменты большего размера не
могут превосходить по размеру <a NAME="t21B001"></a>MSS,
объявленный удаленным получателем.) Протокол TCP
может себе это позволить, потому что он
идентифицирует данные, которые были отправлены и
подтверждены, по номерам байтов, а не по номерам
сегментов. </small></p>

<p><small>Мы можем легко посмотреть, как это
происходит. Воспользуемся программой <a NAME="t21B002"></a>sock,
чтобы подсоединиться к discard серверу, и напечатаем
одну строку. Затем мы отсоединяем Ethernet кабель и
вводим вторую строку. Пока эта вторая строка
будет повторно передаваться, мы вводим третью
строку. При этом ожидается, что следующая
повторная передача будет содержать обе и вторую,
и третью строки.</small></p>

<p>&nbsp;</p>


<p><br>
bsdi % <b>sock svr4 discard<br>
hello there </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; первая
строка отправлена нормально<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; отсоединяем
Ethernet кабель<br>
<b>line number 2 </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; эта
строка будет повторно передаваться<br>
<b>and 3 </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим
эту строку перед тем, как вторая отправлена
нормально<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; подсоединяем
обратно Ethernet кабель<br>
</p>


<p>&nbsp;</p>

<p><small>На рисунке 21.13 показан вывод команды tcpdump.
(Мы удалили установление соединения, прерывание
соединения и все объявления окна.)<a NAME="t21B003"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp;&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1032
&gt; svr4.discard: P 1:13(12) ack 1<br>
2&nbsp;&nbsp; 0.140489 ( 0.1405)&nbsp;&nbsp;&nbsp;&nbsp; svr4.discard &gt; bsdi.1032: .
ack 13<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; здесь
отсоединен Ethernet кабель<br>
<br>
3&nbsp; 26.407696 (26.2672)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1032 &gt; svr4.discard: P
13:27(14) ack 1<br>
4&nbsp; 27.639390 ( 1.2317)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1032 &gt; svr4.discard: P
13:27(14) ack 1<br>
5&nbsp; 30.639453 ( 3.0001)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1032 &gt; svr4.discard: P
13:27(14) ack 1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; здесь
напечатана третья строка<br>
<br>
6&nbsp; 36.639653 ( 6.0002)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1032 &gt; svr4.discard: P
13:33(20) ack 1<br>
7&nbsp; 48.640131 (12.0005)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1032 &gt; svr4.discard: P
13:33(20) ack 1<br>
8&nbsp; 72.640768 (24.0006)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1032 &gt; svr4.discard: P
13:33(20) ack 1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; здесь
Ethernet кабель подсоединен обратно<br>
<br>
9&nbsp; 72.719091 ( 0.0783)&nbsp;&nbsp;&nbsp;&nbsp; svr4.discard &gt; bsdi.1032: . ack 33<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 21.13 Пересборка пакетов TCP.</small></p>

<p>&nbsp;</p>

<p><small>В строках 1 и 2 показана первая строка (&quot;hello
there&quot;), которая отправлена и подтверждена. Затем
мы отсоединяем Ethernet кабель и печатаем &quot;line number
2&quot; (14 байт, включая символ новой строки). Эти
байты передаются в строке 3, а затем повторно
передаются в строках 4 и 5. </small></p>

<p><small>Перед тем как осуществляется повторная
передача в строке 6, мы печатаем &quot;and 3&quot; (6 байт,
включая символ новой строки) и видим, что
повторная передача на этот раз содержит 20 байт:
обе строки, которые мы напечатали. Подтверждение,
которое прибывает в строке 9, подтверждает все 20
байт.</small></p>
<u><b>

<p><a NAME="t21C000"></a>Краткие выводы</p>
</b></u>

<p><small>В этой главе детально рассматривается
стратегия TCP тайм-аутов и повторных передач. Наш
первый пример был посвящен потерянному SYN, с
помощью которого устанавливаются соединения, и
мы видели, как применяется экспотенциальное
наращивание значений последовательных
тайм-аутов при повторной передаче. </small></p>

<p><small>TCP рассчитывает время возврата и затем
использует полученные значения, чтобы
поддерживать и обновлять значение хэшированной
оценочной функции RTT и хэшированной оценочной
функции среднего отклонения. Эти два показателя
затем используются при расчете следующего
значения тайм-аута для повторной передачи.
Большинство реализаций рассчитывают только один
RTT на окно. Алгоритм Карна снимает проблему
двусмысленной повторной передачи, поэтому не
приходится рассчитывать RTT в случае потери
пакета. </small></p>

<p><small>Наш подробный пример, в котором было
потеряно три пакета, позволил нам рассмотреть
большинство алгоритмов TCP в действии: медленный
старт, предотвращение переполнения, быструю
повторную передачу и быстрое восстановление. Мы
также имели возможность рассчитать оценочные
функции RTT TCP вместе с окном переполнения и
порогом медленного старта, а также сравнить эти
значения с реальными значениями, полученными из
вывода отладочных программ. </small></p>

<p><small>Мы закончили рассмотрением влияния
различных ICMP ошибок на TCP соединение, и как TCP
позволено перестраивать порядок движения
данных. Мы видели, что &quot;мягкие&quot; ICMP ошибки не
приводят к разрыву соединения, однако
запоминаются таким образом, что когда соединение
разрывается по каким-либо причинам, ошибка может
быть выведена в виде сообщения.</small></p>
<i><b>

<p>Упражнения</b></i> 

<ol>
  <li>На рисунке 21.5 первый тайм-аут был
    рассчитан как 6 секунд, а следующий как 12 секунд.
    Если ACK для первоначального SYN не прибыл после
    того, как истечет 12-секундный тайм-аут, какова
    будет величина следующего тайм-аута?</li>
  <li>В рассуждениях, которые следуют за рисунком 21.5,
    мы сказали, что временные промежутки между
    тайм-аутами рассчитываются как 6, 24 и затем 48
    секунд, как мы видели на <a HREF="tcp04.html#t045001">рисунке
    4.5</a>. Однако, если мы рассмотрим TCP соединение на
    несуществующий хост с системы <a NAME="t21C001"></a>SVR4,
    тайм-ауты будут 6, 12, 24 и 48 секунд. Что происходит?</li>
  <li>Сравните производительность скользящего окна
    TCP с <a NAME="t21C002"></a>TFTP <a NAME="t21C003"></a>протоколом с
    ожиданием подтверждения следующим образом. В
    этой главе мы передали 32768 байт примерно за 35
    секунд (рисунок 21.6) по каналу со средним RTT,
    находящимся в районе 1,5 секунды (рисунок 21.4).
    Рассчитайте, сколько понадобится времени TFTP для
    того, чтобы осуществить ту же передачу.</li>
  <li>В разделе <a HREF="#t217000">&quot;Быстрая повторная
    передача и алгоритм быстрого восстановления&quot;</a>
    мы сказали, что прием дублированного ACK
    вызывается, как правило, тем, что сегмент был
    потерян или пришел не в свое вовремя
    (беспорядочно). В разделе <a HREF="#t215000">&quot;Пример
    переполнения&quot;</a> мы видели, что генерация
    дублированных ACK вызывается потерей сегмента.
    Нарисуйте рисунок, который доказывал бы, что
    приход сегмента &quot;не в свое время&quot; также
    генерирует дублированные ACK.</li>
  <li>На рисунке 21.6 между моментами времени 28,8 и 29,8
    находится очень заметный пропуск. Является ли
    это повторной передачей?</li>
  <li>В разделе <a HREF="#t216000">&quot;Алгоритм предотвращения
    переполнения&quot;</a> мы сказали, что релиз 4.3BSD Tahoe
    осуществляет только медленный старт, если пункт
    назначения находится в другой сети. Как Вы
    думаете, что означает &quot;другая сеть&quot;?
    (Подсказка: см. <a HREF="tcp_e.html">приложение E</a>.)</li>
  <li>В разделе <a HREF="tcp20.html#t202000">&quot;Обычный поток
    данных&quot;</a> главы 20 мы сказали, что TCP
    подтверждает каждый второй сегмент. Однако на
    рисунке 21.2 мы видели, что получатель
    подтверждает каждый сегмент. Почему?</li>
  <li>Действительно ли полезны <a NAME="t21C004"></a>показатели
    на маршрут, с господствующим маршрутом по
    умолчанию?</li>
</ol>

<hr>

</body>
</html>

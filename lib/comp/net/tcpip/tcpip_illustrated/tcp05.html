<html>

<head>
<title>RARP: Обратный протокол определения адреса</title>

<meta http-equiv="Content-type" content="text/html; charset=koi8-r">
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>




<p><a NAME="t050000"></a>Глава 5 RARP: обратный протокол
определения адреса</p>
<u>

<p><b><a NAME="t051000"></a>Введение</p>
</b></u>

<p><small>Когда загружается система с локальным
диском, она обычно получает свой IP адрес из
конфигурационного файла, который считывается с
диска. Однако для систем, не имеющих диска, таких
как X терминалы или бездисковые рабочие станции,
требуются другой способ определения
собственного IP адреса. </small></p>

<p><small>Каждая система в сети имеет уникальный
аппаратный адрес, который назначается
производителем сетевого интерфейса (сетевой
платы). Принцип работы RARP заключается в том, что
бездисковая система может считать свой
уникальный аппаратный адрес с интерфейсной
платы и послать RARP запрос (широковещательный
фрейм в сеть), где потребует кого-нибудь
откликнуться и сообщить IP адрес (с помощью RARP
отклика). </small></p>

<p><small>Несмотря на то что концепция довольно
проста, ее реализация как правило значительно
сложнее чем ARP, который был описан в <a HREF="tcp04.html">предыдущей</a>
главе. Официальная спецификация RARP находится в RFC
903 [<a NAME="t051001"></a>Finlayson et al. 1984].</small></p>
<u><b>

<p><a NAME="t052000"></a>Формат пакета RARP</p>
</b></u>

<p><small><a NAME="t052001"></a>Формат пакета RARP практически
идентичен пакету ARP (см. рисунок 4.3). Единственное
отличие заключается в том, что поле <a NAME="t052002"></a>тип
фрейма (frame type) для запроса или отклика RARP
установлено в 0x8035, а поле op имеет значение 3 для RARP
запроса и значение 4 для RARP отклика. </small></p>

<p><small>RARP запрос является широковещательным, а RARP
отклик обычно персональный.</small></p>
<u><b>

<p><a NAME="t053000"></a>Примеры RARP</p>
</b></u>

<p><small>В нашей сети мы можем заставить хост sun
загружаться из сети, вместо того чтобы
загружаться с локального диска. Если мы
запустили RARP сервер и <a NAME="t053001"></a>tcpdump на хосте
bsdi, то получим вывод, показанный на рисунке 5.1. Мы
используем флаг <a NAME="t053002"></a>-e, чтобы команда tcpdump
показывала аппаратные адреса:<a NAME="t053003"></a> </small></p>

<p>&nbsp;</p>


<p>1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42
ff:ff:ff:ff:ff:ff rarp 60: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp
who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>
2&nbsp; 0.13 (0.13)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0:0:c0:6f:2d:40 8:0:20:3:f6:42 rarp 42: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp
reply 8:0:20:3:f6:42 at sun<br>
3&nbsp; 0.14 (0.01)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42 0:0:c0:6f:2d:40 ip 65: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.26999&gt;bsdi.tftp:
23 RRQ &quot;8CFC0D21.SUN4C&quot;<br>
</p>


<p><small>Рисунок 5.1 Запрос и отклик RARP.</small></p>

<p>&nbsp;</p>

<p><small>Запрос RARP широковещательный (строка 1), а
отклик RARP (строка 2) персональный. Вывод в строке 2,
at sun, означает, что RARP отклик содержит IP адрес
хоста sun (140.252.13.33). </small></p>

<p><small>В строке 3 мы видим, что как только sun получил
свой IP адрес, он выдал TFTP запрос на чтение (RRQ)
файла 8CFC0D21.SUN4C. (<a NAME="t053004"></a>TFTP это простой
протокол передачи файлов - Trivial File Transfer Protocol. Мы
рассмотрим его более подробно в <a HREF="tcp15.html">главе
15</a>.) Восемь шестнадцатиричных цифр в имени файла
это шестнадцатиричное представление IP адреса
140.252.13.33 хоста sun. Это IP адрес, который мы получили
в отклике RARP. Оставшаяся часть имени файла, SUN4C,
указывает на тип системы, которая загружается. </small></p>

<p><small>В строке 3 <a NAME="t053005"></a>tcpdump сообщает, что это
IP датаграмма длиной 65, а не UDP датаграмма (которая
в действительности является ей), так как мы
запустили tcpdump с флаго -e, чтобы получить в выводе
аппаратные адреса. Еще один момент на, который
необходимо обратить внимание на рисунке 5.1,
заключается в том, что длина Ethernet фрейма в строке
2 меньше чем установленный минимум (который, как
мы упоминали в разделе <a HREF="tcp04.html#t045000">&quot;Примеры
ARP&quot;</a> главы 4, должен быть равен 60 байтам).
Причина этого заключается в том, что мы запустили
tcpdump на системе, которая посылает этот Ethernet фрейм
(bsdi). Приложение, <a NAME="t053006"></a>rarpd, пишет 42 байта в
устройство пакетного фильтра BSD (BSD Packet Filter) (14
байт - Ethernet заголовок и 28 байт - отклик RARP), именно
это и видит tcpdump. Однако драйвер устройства Ethernet
дополняет этот короткий фрейм до минимального
размера, необходимого для передачи (60 байт). Если
бы мы запустили tcpdump на другом компьютере, длина
составила бы 60 байт. </small></p>

<p><small>Также мы видим, что когда бездисковая
система получает свой IP адрес в отклике RARP, она
осуществляет TFTP запрос, чтобы прочитать
загрузочный имидж. Сейчас мы не будем подробно
рассматривать, как загружаются бездисковые
системы. (В <a HREF="tcp16.html">главе 16</a> описывается
последовательность загрузки бездисковых X
терминалов с использованием RARP, BOOTP и TFTP.) </small></p>

<p><small>На рисунке 5.2 показаны пакеты, которые
появляются в том случае, если в сети нет RARP
сервера. Адрес назначения каждого пакета -
широковещательный адрес Ethernet. Адрес Ethernet,
следующий за who-is, это аппаратный адрес хоста
которому требуется информация, а адрес Ethernet,
следующий за tell, это аппаратный адрес
отправителя. </small></p>

<p><small><a NAME="t053007"></a>Обратите внимание на частоту
повторных передач. Первая повторная передача
происходит через 6,55 секунд, затем интервал
увеличивается до 42,80 секунд, затем через 5,34
секунды, затем через 6,55 секунд и снова через 42,79
секунды. Если мы рассчитаем разницу между каждым
тайм-аутом, мы заметим эффект удвоения: между 5,34 и
6,55 - 1,21 секунды, между 6,55 и 8,97 - 2,42 секунды, между 8,97
и 13,80 - 4,83 секунды и так далее.<a NAME="t053008"></a></small></p>

<p>&nbsp;</p>


<p> 1&nbsp;&nbsp;&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42
ff:ff:ff:ff:ff:ff rarp 60: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp
who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>
2&nbsp;&nbsp;&nbsp; 6.55 ( 6.55)&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42 ff:ff:ff:ff:ff:ff rarp
60: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp
who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>
3&nbsp;&nbsp; 15.52 ( 8.97)&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42 ff:ff:ff:ff:ff:ff rarp 60: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp
who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>
4&nbsp;&nbsp; 29.32 (13.80)&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42 ff:ff:ff:ff:ff:ff rarp 60: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp
who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>
5&nbsp;&nbsp; 52.78 (23.46)&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42 ff:ff:ff:ff:ff:ff rarp 60: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp
who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>
6&nbsp;&nbsp; 95.58 (42.80)&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42 ff:ff:ff:ff:ff:ff rarp 60: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp
who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>
7&nbsp; 100.92 ( 5.34)&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42 ff:ff:ff:ff:ff:ff rarp 60: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp
who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>
8&nbsp; 107.47 ( 6.55)&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42 ff:ff:ff:ff:ff:ff rarp 60: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp
who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>
9&nbsp; 116.44 ( 8.97)&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42 ff:ff:ff:ff:ff:ff rarp 60: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp
who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>
10&nbsp; 130.24 (13.80)&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42 ff:ff:ff:ff:ff:ff rarp 60: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp
who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>
11&nbsp; 153.70 (23.46)&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42 ff:ff:ff:ff:ff:ff rarp 60: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp
who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>
12&nbsp; 196.49 (42.79)&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42 ff:ff:ff:ff:ff:ff rarp 60: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp
who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 5.2 RARP запрос при отсутствии в сети
RARP сервера.</small></p>

<p>&nbsp;</p>

<p><small>Когда тайм-аут достигает определенного
предела (больше чем 42,80 секунды), он сбрасывается
вновь в 5,34 секунды. </small></p>

<p><small>Подобное увеличение значения тайм-аута -
это наилучший подход, так как каждый раз
используется одно и то же значение. На рисунке 6.8
мы увидим неверный подход, с помощью которого
осуществляются тайм-ауты и повторные передачи, а
в <a HREF="tcp21.html">главе 21</a> мы рассмотрим метод
используемый в TCP.</small></p>
<u><b>

<p><a NAME="t054000"></a>Реализация RARP сервера</p>
</b></u>

<p><small>Тогда как концепция RARP довольно проста,
реализация RARP сервера сильно зависит от системы
и довольно сложна. Напротив, реализация ARP
сервера проста и является, как правило, частью
реализации ядра TCP/IP. Так как ядро знает
собственные IP адреса и аппаратные адреса, при
получении ARP запроса для одного из IP адресов оно
просто формирует отклик с соответствующим
аппаратным адресом.</small></p>
<i><b>

<p>RARP серверы как пользовательские процессы</p>
</b></i>

<p><small>Основная задача RARP сервера заключается в
том, чтобы предоставить соответствие между
аппаратными адресами и IP адресами для множества
хостов (все бездисковые системы в сети).
Необходимая информация содержится в дисковом
файле (обычно <a NAME="t054001"></a>/etc/ethers в UNIX системах).
Так как ядро обычно не читает дисковые файлы,
функция RARP сервера реализуется с использованием
пользовательского процесса, который не является
частью ядра TCP/IP. </small></p>

<p><small>Далее, можно отметить, что RARP запросы
передаются в качестве Ethernet фреймов со
специфическим <a NAME="t054002"></a>полем типа фрейма Ethernet
(0x8035 на рисунке 2.1). Это означает, что RARP сервер
должен обладать способностью отправлять и
принимать Ethernet фреймы подобного типа. В <a HREF="tcp_a.html">приложении А</a> мы опишем как для приема
подобных фреймов используются BSD Packet Filter, Sun Network
Interface Tap и SVR4 Data Link Provider Interface. Так как посылка и
прием подобных фреймов зависит от системы,
реализация RARP сервера также зависит от системы.</small></p>
<i><b>

<p>Несколько RARP серверов в сети</p>
</b></i>

<p><small>Еще одна особенность заключается в том, что
RARP запросы посылаются в виде широковещательных
запросов аппаратного уровня, как показано на
рисунке 5.2. Это означает, что они не
перенаправляются маршрутизаторами. Чтобы
позволить бездисковым системам загружаться,
даже если RARP сервер выключен, в сети обычно
существуют несколько RARP серверов (на одном и том
же кабеле). </small></p>

<p><small>По мере того как количество серверов растет
(чтобы повысить надежность), увеличивается
сетевой траффик, так как каждый сервер посылает
RARP отклик на каждый RARP запрос. Бездисковые
системы, которые посылают RARP запросы, обычно
используют первый полученный ими RARP отклик. (Мы
никогда не имели подобных проблем с ARP, потому что
только один хост посылает ARP отклик.) Более того,
существует вероятность, что несколько RARP
серверов отправят отклики одновременно,
увеличивая тем самым количество коллизий в Ethernet.</small></p>
<u><b>

<p><a NAME="t055000"></a>Краткие выводы</p>
</b></u>

<p><small>RARP используется большинством бездисковых
систем при загрузке, для получения свох IP
адресов. Формат пакета RARP практически идентичен
пакету ARP. Запрос RARP широковещательный, в нем
содержится аппаратный адрес отправителя, при
этом он спрашивает кого-либо послать ему его IP
адрес. Отклик обычно персональный. </small></p>

<p><small>Проблемы с RARP заключаются в том, что он
использует широковещательные запросы на
канальном уровне, поэтому большинство
маршрутизаторов не могут перенаправлять RARP
запросы; а также в том, что передается минимум
необходимой информации: только IP адрес системы. В
<a HREF="tcp16.html">главе 16</a> мы увидим, что BOOTP сообщает
значительно больше информации необходимой при
загрузке бездисковых систем: IP адрес, имя хоста, с
которого происходит загрузка, и так далее. </small></p>

<p><small>Несмотря на то что концепция RARP довольно
проста, реализация RARP сервера зависит от системы.
Также надо отметить, что не все TCP/IP реализации
предоставляют RARP сервер.</small></p>

<p>&nbsp;</p>
<i><b>

<p>Упражнения</b></i> 

<ol>
  <li>Требуется ли для RARP отдельное <a NAME="t055001"></a>поле типа фрейма (frame type)? Может ли быть
    использовано одно и то же значение 0x0806 для ARP и RARP?</li>
  <li>Если в сети находится несколько RARP серверов, как
    они могут сделать так, чтобы предотвратить
    коллизии своих ответов?</li>
</ol>





<p>&nbsp;</p>
<hr>
</center>
</body>
</html>

<html>

<head>
<title>TFTP: простой протокол передачи данных</title>

<meta http-equiv="Content-type" content="text/html; charset=koi8-r">
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>




<p><a NAME="t150000"></a>Глава 15 TFTP: простой протокол
передачи данных</p>
<u>

<p><b><a NAME="t151000"></a>Введение</p>
</b></u>

<p><small><a NAME="t151001"></a>TFTP - это простой протокол
передачи файлов. Он, как правило, используется
при загрузке бездисковых систем (рабочие станции
или X терминалы). В отличие от протокола передачи
файлов (FTP - File Transfer Protocol), который мы опишем в <a HREF="tcp27.html">главе 27</a> и который использует TCP, TFTP
использует UDP. Это сделано для того, чтобы
протокол был как можно проще и меньше. Реализации
TFTP (и необходимого UDP, IP и драйвера устройства)
могут поместиться в постоянной памяти (ПЗУ). </small></p>

<p><small>В этой главе приводится только краткое
описание TFTP, потому что в <a HREF="tcp16.html">следующей</a>
главе мы рассмотрим протокол Bootstrap, который
использует TFTP. Мы использовали протокол TFTP, когда
загружали из сети хост sun (см. <a HREF="tcp05.html#t053001">рисунок
5.1</a>). Он выдавал TFTP запрос, после того как получил
свой IP адрес с использованием RARP. </small></p>

<p><small>RFC 1350 [<a NAME="t151002"></a>Sollins 1992] является
официальной спецификацией TFTP версия 2. Глава 12
[Stevens 1990] предоставляет полные исходные коды
реализации TFTP клиента и сервера и описывает
некоторую технику программирования,
использованную в TFTP.</small></p>
<u><b>

<p><a NAME="t152000"></a>Протокол</p>
</b></u>

<p><small>Обмен между клиентом и сервером начинается
с того, что клиент запрашивает сервер либо
прочитать, либо записать файл для клиента. В
стандартном варианте загрузки бездисковой
системы первый запрос - это запрос на чтение (RRQ).
На рисунке 15.1 показан формат пяти сообщений TFTP.
(Коды операций 1 и 2 имеют одинаковый формат.) </small></p>

<p><small>Первые 2 байта TFTP сообщения это код операции
(opcode). В запросе на чтение (RRQ) и в запросе на запись
(WRQ) имя файла (filename) указывает файл на сервере,
который клиент хочет либо считать, либо записать.
Мы специально показали на рисунке 15.1, что это имя
файла оканчивается нулевым байтом. Режим (mode) это
ASCII строка: netascii или octet (любая комбинация больших
или маленьких букв), которая также оканчивается
байтом 0. netascii означает, что данные являются
строками ASCII текста, причем каждая строка
оканчивается 2-символьной последовательностью
возврата каретки, за которой следует пропуск
строки (обозначается - CR/LF).<a NAME="t152001"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t15_1_20.jpg" WIDTH="524" HEIGHT="445"></small></p>


<p ALIGN="CENTER"><small>Рисунок 15.1 Формат пяти TFTP
сообщений.</small></p>

<p>&nbsp;</p>

<p><small>И клиент и сервер должны иметь возможность
осуществить преобразование между этим форматом
и каким-либо другим (другой разделитель строк),
который используется на локальном хосте.
Передача octet обозначает, что данные будут
передаваться в виде 8-битных байтов без
интерпретации. </small></p>

<p><small>Каждый пакет данных содержит номер блока
(block number), который затем используется в пакете
подтверждении. В качестве примера скажем, что
когда необходимо осуществить чтение файла,
клиент посылает запрос на чтение (RRQ), указывая
имя файла и режим. Если файл может быть прочитан
клиентом, сервер отвечает пакетом данных с
номером блока равным 1. Клиент посылает
подтверждение (ACK) на номер блока 1. Сервер
отвечает следующим пакетом данных с номером
блока равным 2. Клиент подтверждает номер блока 2.
Это продолжается до тех пор, пока файл не будет
передан. Каждый пакет данных содержит 512 байт
данных, за исключением последнего пакета,
который содержит от 0 до 511 байт данных. Когда
клиент получает пакет данных, который содержит
меньше чем 512 байт, он считает, что получил
последний пакет. </small></p>

<p><small>В случае запроса на запись (WRQ) клиент
посылает WRQ, указывая имя файла и режим. Если файл
может быть записан клиентом, сервер отвечает
подтверждением (ACK) с номером блока равным 0.
Клиент посылает первые 512 байт файла с номером
блока равным 1, сервер отвечает ACK с номером блока
равным 1. </small></p>

<p><small><a NAME="t152002"></a>Этот тип передачи данных
называется протоколом с остановкой и ожиданием
подтверждения (stop-and-wait) . Он используется только в
простых протоколах, таких как TFTP. Мы увидим в
разделе <a HREF="tcp20.html#t203000">&quot;Изменение размера
окна&quot;</a> главы 20, что TCP предоставляет другую
форму подтверждений, которая позволяет добиться
более высокой пропускной способности. <a NAME="t152003"></a>TFTP
разработан таким образом, чтобы реализация была
как можно проще, а не для того чтобы повысить
пропускную способность. </small></p>

<p><small>Последний тип TFTP сообщений это сообщения об
ошибках, код операции (opcode) равен 5. Это как раз то,
чем сервер отвечает в том случае, если запрос на
чтение или запись не может быть обработан. Ошибки
чтения или записи в течении передачи файла также
приводят к тому, что отправляется сообщение об
ошибке, при этом передача прекращается. Номер
ошибки (error number) содержит цифровой код ошибки, за
которым следует сообщение об ошибке в ASCII
формате, которое может содержать дополнительную
информацию предоставляемую операционной
системой. </small></p>

<p><small>Так как TFTP использует ненадежный UDP, то
именно от TFTP зависит, как будут обработаны
потерянные и дублированные пакеты. В случае
потери пакета, отправитель отрабатывает <a NAME="t152004"></a>тайм-аут и осуществляет повторную
передачу. (Возможно появление проблемы,
называемой &quot;синдромом новичка&quot; (sorcerer's apprentice
syndrome), которая может возникнуть, если с обеих
сторон будет отработан тайм-аут и осуществлена
повторная передача. Раздел 12.2 [Stevens 1990]
показывает, в результате чего может возникнуть
подобная проблема.) Как и в большинстве UDP
приложений, контрольная сумма TFTP сообщения не
расчитывается, а это означает, что любое
повреждение данных может быть определено только
с помощью <a NAME="t152005"></a>контрольной суммы UDP (см.
главу 11, раздел <a HREF="tcp11.html#t113000">&quot;Контрольная
сумма UDP&quot;</a>).</small></p>
<u><b>

<p><a NAME="t153000"></a>Пример</p>
</b></u>

<p><small>Давайте посмотрим, как работает протокол
TFTP. Мы запустим TFTP клиента на хосте bsdi и получим
текстовый файл с хоста svr4:</small></p>

<p>&nbsp;</p>


<p><br>
bsdi % <b>tftp svr4 </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; стартуем
TFTP клиента<br>
tftp&gt; <b>get test1.c </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; получаем
файл с сервера<br>
Received 962 bytes in 0.3 seconds<br>
tftp&gt; <b>quit </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; разрываем
соединение<br>
<br>
bsdi % <b>ls -l test1.c </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; сколько
байт в полученном файле?<br>
-rw-r--r-- 1 rstevens staff 914 Mar 20 11:41 test1.c<br>
<br>
bsdi % <b>wc -l test1.c </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; и
сколько строк?<br>
48 test1.c<br>
</p>


<p>&nbsp;</p>

<p><small>Первый момент, который бросается в глаза,
заключается в том, что файл в Unix содержит 914 байт,
однако TFTP передает 962 байта. Воспользовавшись
программой <a NAME="t153002"></a>wc, мы увидим, что в файле 48
строк, таким образом, 48 символов новой строки в Unix
были дополнены до 48 пар CR/LF, так как TFTP по
умолчанию осуществляет передачу в режиме netascii. </small></p>

<p><small>На рисунке 15.2 показан обмен пакетами.<a NAME="t153001"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1106
&gt; svr4.tftp: 19 RRQ &quot;test1.c&quot;<br>
<br>
2&nbsp; 0.287080 (0.2871)&nbsp;&nbsp;&nbsp;&nbsp; svr4.1077 &gt; bsdi.1106: udp 516<br>
3&nbsp; 0.291178 (0.0041)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1106 &gt; svr4.1077: udp 4<br>
<br>
4&nbsp; 0.299446 (0.0083)&nbsp;&nbsp;&nbsp;&nbsp; svr4.1077 &gt; bsdi.1106: udp 454<br>
5&nbsp; 0.312320 (0.0129)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1106 &gt; svr4.1077: udp 4<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 15.2 Обмен пакетами в случае TFTP.</small></p>

<p>&nbsp;</p>

<p><small>В строке 1 показан запрос на чтение от
клиента к серверу. Порт назначения UDP для TFTP -
заранее известный порт 69, <a NAME="t153003"></a>tcpdump
просматривает TFTP пакеты и печатает RRQ и имя файла.
Длина UDP данных печатается как 19 байт и
получается следующим образом: 2 байта - код
операции, 7 байт - имя файла, 1 байт равный 0, 8 байт
для netascii и еще 1 байт равный 0. </small></p>

<p><small>Следующий пакет приходит от сервера (строка
2) и содержит 516 байт: 2 байта - код операции, 2 байта
- номер блока и 512 байт данных. Строка 3 -
подтверждение на эти данные: 2 байта - код
операции и 2 байта - номер блока. </small></p>

<p><small>И последний пакет данных (строка 4) содержит
450 байт данных. 512 байт данных в строке 2 и эти 450
байт составляют 962 байта данных, полученные
клиентом. </small></p>

<p><small>Обратите внимание, что <a NAME="t153004"></a>tcpdump не
печатает дополнительную информацию о протоколе
TFTP для строк 2 - 5, как он это сделал,
интерпретировав TFTP сообщение в строке 1. Это
происходит потому, что номер порта сервера
сменился между строками 1 и 2. Протокол TFTP требует,
чтобы клиент отправил первый пакет (RRQ или WRQ) на
заранее известный порт UDP сервера (69). Сервер
находит какой-либо неиспользуемый динамически
назначаемый порт (1077 на рисунке 15.2), который затем
используется сервером для дальнейшего обмена
пакетами между клиентом и сервером. Номер порта
клиента (1106 в данном примере) не меняется. tcpdump не
имеет представления о том, что порт 1077 на хосте svr4
используется TFTP сервером. </small></p>

<p><small><a NAME="t153005"></a>Причина, по которой меняется
номер порта сервера, заключается в том, что
сервер не должен захватывать заранее известный
порт на большой промежуток времени, требуемый на
передачу файла (что может занять от нескольких
секунд до нескольких минут). Вместо этого,
заранее известный порт остается доступным для
других TFTP клиентов, которые могут послать туда
свой запрос. Тогда как в это время передача
осуществляется через другой порт. </small></p>

<p><small>Обратимся к <a HREF="tcp10.html#t104001">рисунку 10.6</a>. RIP
сервер, которому необходимо послать клиенту
более чем 512 байт, отправляет обе UDP датаграммы с
заранее известного порта сервера. В случае TFTP
(из-за отличий в протоколе), долговременного
взаимодействия между клиентом и сервером не
осуществляется (которое, как мы сказали, может
занимать от секунд до минут). Если один процесс
сервера будет использовать заранее известный
порт все время, пока осуществляется передача
файла, возникнет необходимость отказать всем
последующим запросам, которые придут от других
клиентов, или один процесс сервера должен иметь
возможность осуществлять множественную
передачу файлов нескольким клиентам в одно и то
же время с одного и того же порта (69). Простейшее
решение заключается в том, что сервер переходит
на другой порт, после того как получил RRQ или WRQ.
Клиент определяет новый порт, когда он получает
первый пакет данных (строка 2 на рисунке 15.2), а
затем посылать все последующие подтверждения
(строки 3 и 5) на новый порт. </small></p>

<p><small>В разделе <a HREF="tcp16.html#t163000">&quot;Пример&quot;</a>
главы 16 мы увидим, как TFTP используется при
загрузке X терминалов.</small></p>
<u><b>

<p><a NAME="t154000"></a>Безопасность</p>
</b></u>

<p><small>Обратите внимание на то, что TFTP пакеты
(рисунок 15.1) не содержат никаких данных об имени
пользователя или пароле. Это брешь в секретности
характерная для TFTP. Так как TFTP был разработан для
использования в процессе загрузки, он не
предоставляет возможности передать имя
пользователя и пароль. </small></p>

<p><small>Эта характеристика TFTP была использована
многими хакерами, чтобы получить копии файла
паролей из Unix и затем расшифровать пароли. Чтобы
предотвратить подобный доступ, большинство TFTP
серверов в настоящее время регламентируют, какие
файлы могут быть получены с использованием TFTP
(как правило, файлы из директории <a NAME="t154001"></a>/tftpboot
в Unix системах). Эта директория содержит только
загрузочные файлы, необходимые бездисковым
системам. </small></p>

<p><small>Для дополнительной безопасности TFTP сервер,
на Unix системе, обычно устанавливает свой
пользовательский идентификатор (UID) и
идентификатор группы (GID) в значения, которые не
могут быть назначены реальному пользователю. Это
позволяет доступ только к файлам, которые
доступны для чтения и записи всем. </small></p>
<u><b>

<p><a NAME="t155000"></a>Краткие выводы</p>
</b></u>

<p><small>TFTP - это простой протокол, разработанный
таким образом, чтобы помещаться в ПЗУ и быть
использованным только в процессе загрузки
бездисковых систем. Он использует небольшое
количество форматов сообщений и <a NAME="t155001"></a>протокол
с остановкой и ожиданием подтверждения. </small></p>

<p><small>Чтобы позволить нескольким клиентам
загружаться одновременно, TFTP сервер
предоставляет несколько форм одновременной
работы. Так как UDP не предоставляет уникального
соединения между клиентом и сервером (как это
делает TCP), TFTP сервер создает новый UDP порт для
каждого клиента. Это позволяет разным клиентам
выдавать датаграммы, которые будут <a NAME="t155002"></a>демультиплексированы
UDP модулем сервера, на основе номеров портов
назначения, вместо того чтобы это делал сам
сервер. </small></p>

<p><small>Протокол TFTP не предоставляет средства
безопасности. Большинство реализаций позволяет
доступ по протоколу TFTP только к файлам, которые
необходимы при загрузке. </small></p>

<p><small>В <a HREF="tcp27.html">главе 27</a> мы рассмотрим
протокол передачи файлов (FTP - File Transfer Protocol),
который разработан для общих целей, а также
обеспечивает высокую пропускную способность при
передаче файлов.</small></p>
<i><b>

<p>Упражнения</b></i> 

<ol>
  <li>Прочитайте требования к хостам <a NAME="t155003"></a>Host Requirements RFC, чтобы посмотреть, что
    должен делать TFTP сервер, если он получит запрос, IP
    адрес назначения которого является
    широковещательным адресом.</li>
  <li>Как Вы думаете, что произойдет, когда номер
    блока TFTP изменится с 65535 на 0? Говорится ли
    что-нибудь по этому поводу в RFC 1350?</li>
  <li>Мы сказали, что TFTP отправитель осуществляет <a NAME="t155004"></a>тайм-аут и повторную передачу, чтобы
    отработать потерю пакетов. Как это отразится на
    функционировании TFTP, когда он используется как
    часть процесса загрузки?</li>
  <li>Что является ограничивающим фактором по
    времени при передаче файла с использованием TFTP?</li>
</ol>

<hr>

</body>
</html>

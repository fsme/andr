<html>

<head>
<title>NFS: сетевая файловая система</title>

<meta http-equiv="Content-type" content="text/html; charset=koi8-r">
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>


<b>

<p><a NAME="t290000"></a>Глава 29 NFS: сетевая файловая система</p>
<u>

<p><a NAME="t291000"></a>Введение</p>
</u></b>

<p><small>В этой главе мы рассмотрим сетевую файловую
систему (<a NAME="t291001"></a>NFS - Network File System), популярное
приложение, которое предоставляет приложениям
клиентов прозрачный доступ к файлам.
Краеугольным камнем NFS является <a NAME="t291002"></a>Sun RPC:
вызов удаленной процедуры (Remote Procedure Call), что мы и
опишем в первую очередь. </small></p>

<p><small>Программе клиента не требуется специальных
средств, чтобы воспользоваться NFS. Ядро
определяет что файл находится на NFS сервере и
автоматически генерирует RPC вызов, для того чтобы
получить доступ к файлу. </small></p>

<p><small>Мы не будем подробно рассматривать, как
реализуется доступ к файлам, а рассмотрим, как
при этом используются протоколы Internet, особенно
UDP.</small></p>
<u><b>

<p><a NAME="t292000"></a>Вызов удаленной процедуры компании
Sun</p>
</b></u>

<p><small>В большинстве случаев задачи сетевого
программирования решаются путем написания
программ приложений, которые вызывают функции,
предоставляемые системой, чтобы осуществить
конкретные сетевые операции. Например, одна
функция осуществляет активное открытие TCP,
другая пассивное открытие TCP, третья посылает
данные по TCP соединению, четвертая устанавливает
конкретные опции протокола (включает TCP таймер
&quot;оставайся в живых&quot;) и так далее. В разделе <a HREF="tcp01.html#t01F000">&quot;Интерфейсы прикладного
программирования&quot;</a> главы 1 мы упоминали, что
существует два популярных набора функций для
сетевого программирования (прикладной
программный интерфейс, <a NAME="t292001"></a>API), это сокеты
и <a NAME="t292002"></a>TLI. Программный интерфейс,
используемый клиентом, и программный интерфейс,
используемый сервером, могут отличаться, так же
как и операционные системы, которые
функционируют у клиента и сервера. Именно
коммуникационный и прикладной протоколы
определяют, сможет ли конкретный клиент общаться
с сервером. Unix клиент, написанный на C,
использующий сокеты в качестве программного
интерфейса, и TCP - в качестве коммуникационного
протокола, может общаться с сервером на
мейнфрейме, написанным на COBOLе с использованием
других API и TCP, если оба хоста подключены к сети и
оба имеют реализацию TCP/IP. </small></p>

<p><small>Обычно клиент посылает серверу команды, а
сервер отправляет клиенту отклики. Все
рассмотренные нами приложения, - Ping, Traceroute, демоны
маршрутизации, клиенты и сервера DNS, TFTP, BOOTP, SNMP,
Telnet, FTP, SMTP - все построены именно таким образом. </small></p>

<p><small><a NAME="t292003"></a>RPC, вызов удаленной процедуры,
реализует иной подход к сетевому
программированию. Программа клиента просто
вызывает функции в программе сервера. Так это
решено с точки зрения программиста, однако в
действительности имеет место следующая
последовательность действий.</small> 

<ol>
  <li><small>Когда клиент вызывает удаленную процедуру,
    вызывается функция на локальном хосте, которая
    сгенерирована пакетом RPC. Эта функция называется <a NAME="t292004"></a>client stub. client stub упаковывает аргументы
    процедуры в сетевое сообщение и отправляет
    сообщение серверу. </small></li>
  <li><small>server stub на хосте сервера получает сетевое
    сообщение. Аргументы извлекаются из сетевого
    сообщения, и осуществляется вызов процедуры
    сервера, написанной прикладным программистом.</small></li>
  <li><small>Функция сервера возвращает управление server
    stubу, который, в свою очередь, принимает
    полученные значения, упаковывает их в сетевое
    сообщение и отправляет сообщение обратно к client
    stub.</small></li>
  <li><small>client stub возвращает приложению клиента
    значения из сетевого сообщения.</small></li>
</ol>

<p><small>Сетевое программирование, использующее stubы
и библиотечные RPC подпрограммы использует
интерфейсы прикладного программирования API
(сокеты или TLI), однако пользовательские
приложения (программа клиента и процедуры
сервера, вызываемые клиентом) никогда не
обращаются к API. Приложению клиента достаточно
вызывать процедуру сервера, при этом все детали
реализации спрятаны пакетом RPC, client stubом и server
stubом. </small></p>

<p><small>Пакеты RPC имеют следующие положительные
стороны.</small> 

<ul>
  <li><small>Программирование становится легче, так как
    не приходится решать задачи сетевого
    программирования (а если и приходится, то совсем
    немного). Прикладные программисты просто пишут
    программу клиента и процедуры сервера, которые
    вызывает клиент. </small></li>
  <li><small>Если используется ненадежный протокол,
    такой как UDP, все детали, а именно тайм-ауты и
    повторные передачи обрабатываются пакетом RPC.
    Это, в свою очередь, упрощает пользовательское
    приложение. </small></li>
  <li><small>Библиотека RPC обрабатывает необходимое
    преобразование аргументов и возвращаемых
    значений. Например, если аргументы состоят из
    целых чисел и чисел с плавающей точкой, пакет RPC
    обработает все различия между представлением
    целых чисел и чисел с плавающей точкой на клиенте
    и сервере. Благодаря этому упрощается реализация
    клиентов и серверов для функционирования в
    разнородных средах. </small></li>
</ul>

<p><small>Программирование RPC подробно описано в
главе 18 [Stevens 1990]. Два наиболее популярных RPC
пакета это Sun RPC и RPC пакет в Open Software Foundation's (<a NAME="t292005"></a>OSF) Distributed Computing Environment (<a NAME="t292006"></a>DCE).
Мы рассмотрим, как осуществляется вызов
процедуры, как выглядит возвращаемое сообщение и
как это соотносится с пакетом Sun RPC, так как именно
этот пакет используется в сетевой файловой
системе. Версия 2 Sun RPC описана в RFC 1057 [<a NAME="t292007"></a>Sun
Microsystems 1988a]. </small></p>
<i><b>

<p>Sun RPC</p>
</b></i>

<p><small>Существует два вида Sun RPC. Одна версия
построена с использованием <a NAME="t292008"></a>API сокет и
работает с TCP и UDP. Другая называется <a NAME="t292009"></a>TI-RPC
(независимо от транспорта - transport independent),
построена с использованием <a NAME="t292010"></a>TLI API и
работает с любыми транспортными уровнями,
предоставляемыми ядром. С нашей точки зрения
между ними нет никакой разницы, так как в этой
главе мы рассматриваем только TCP и UDP. </small></p>

<p><small>На рисунке 29.1 показан формат сообщения
вызова процедуры RPC, с использованием UDP.<a NAME="t292011"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t29_1000.jpg" WIDTH="375" HEIGHT="413"></small></p>


<p ALIGN="CENTER"><small>Рисунок 29.1 Сообщения вызова
процедуры RPC в формате UDP датаграммы.</small></p>

<p>&nbsp;</p>

<p><small>Стандартные IP и UDP заголовки показаны
раньше (<a HREF="tcp03.html#t032001">рисунок 3.1</a> и <a HREF="tcp11.html#t112001">рисунок 11.2</a>). Все, что следует
после UDP заголовка, определяется пакетом RPC. </small></p>

<p><small>Идентификатор транзакции (<a NAME="t292012"></a>XID -
transaction ID) устанавливается клиентом и
возвращается сервером. Когда клиент получает
отклик, он сравнивает XID, возвращенный сервером, с
XID отправленного запроса. Если они не совпадают,
клиент отбрасывает сообщение и ожидает прихода
следующего. Каждый раз, когда клиент выдает новый
RPC, он меняет XID. Однако если клиент передает RPC
повторно (если отклик не был получен), XID не
меняется. </small></p>

<p><small>Переменная call равна 0 для вызова и 1 для
отклика. Текущая версия RPC (RPC version) равна 2. Три
следующие переменные, номер программы (program number),
номер версии (version number) и номер процедуры (procedure
number), идентифицируют конкретную процедуру,
которая должна быть вызвана на сервере. </small></p>

<p><small><a NAME="t292013"></a>Полномочия (credentials)
идентифицируют клиента. В некоторых примерах это
поле остается незаполненным, а в других здесь
можно встретить цифровой идентификатор
пользователя и идентификатор группы к который он
принадлежит. Сервер может заглянуть в полномочия
и решить, обработать ли запрос или нет. Проверка
(verifier) используется для защищенного RPC (Secure RPC),
которое использует DES шифрование. Несмотря на то,
что поля полномочий и проверки это поля с
переменной длиной, их длина передается как часть
поля. </small></p>

<p><small>Дальше следуют параметры процедуры. Их
формат зависит от того, как приложение
определяет удаленную процедуру. Как получатель
(server stub) узнает размер параметров? Так как
используется UDP, размер параметров можно
рассчитать как размер UDP датаграммы минус длина
всех полей вплоть до поля проверки. Когда вместо
UDP используется TCP, понятия фиксированной длины
не существует, так как TCP это поток байтов без
разделителей записей. В подобном случае, между TCP
заголовком и XID появляется 4-байтовое поле длины,
из которого приемник узнает длину RPC вызова в
байтах. Это позволяет, если необходимо, послать
сообщение вызова RPC в нескольких TCP сегментах. (DNS
использует подобную технику; <a HREF="tcp14.html#t14A002">упражнение
4</a> главы 14.) </small></p>

<p><small>На рисунке 29.2 показан формат RPC отклика. Он
отправляется от server stub к client stub, когда удаленная
процедура завершает свою работу.<a NAME="t292014"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t29_2000.jpg" WIDTH="375" HEIGHT="322"></small></p>


<p ALIGN="CENTER"><small>Рисунок 29.2 Формат сообщения
отклика процедуры RPC как UDP датаграмма.</small></p>

<p>&nbsp;</p>

<p><small>XID вызова просто копируется в XID отклика. В
поле reply находится 1, по этому полю проводится
различие между вызовом и откликом. Поле статуса
(status) содержит нулевое значение, если сообщение
вызова было принято. (Сообщение может быть
отброшено, если номер версии RPC не равен 2 или если
сервер не может аутентифицировать клиента.) Поле <a NAME="t292015"></a>проверки (verifier) используется в случае
защищенного RPC, чтобы указать сервер. </small></p>

<p><small>В поле статуса приема (accept status) находится
нулевое значение, если все нормально. Ненулевое
значение может указывать, например, на неверный
номер версии или неверный номер процедуры. Если
вместо UDP используется TCP, то, как и в случае
сообщения вызова RPC, между TCP заголовком и XID
посылается 4-байтовое поле длины.</small></p>
<u><b>

<p><a NAME="t293000"></a>XDR: представление внешних данных</p>
</b></u>

<p><small>Представление внешних данных (<a NAME="t293001"></a>XDR
- External Data Representation) это стандарт, используемый для
кодирования значений в RPC вызове и отклике
сообщениях - полей заголовка RPC (XID, номер
программы, статус приема и так далее), параметров
процедуры и результатов процедуры. Стандартный
способ кодирования данных позволяет клиенту
вызвать процедуру в системе с отличной
архитектурой. XDR определен в RFC 1014 [<a NAME="t293002"></a>Sun
Microsystems 1987]. </small></p>

<p><small>XDR определяет определенное количество
типов данных и точный способ того, как они
передаются в RPC сообщении (порядок битов, <a NAME="t293003"></a>порядок байтов и так далее).
Отправитель должен построить RPC сообщение в XDR
формате, тогда получатель конвертирует XDR формат
в исходное представление. (В тот формат, который
принят для его системы.) Мы видим, например, на
рисунках 29.1 и 29.2, что все целые значения, которые
мы показали (XID, вызов, номер программы и так
далее), это 4-байтовые целые числа. И
действительно, все целые в XDR занимают 4 байта. XDR
поддерживает и другие типы данных, включая целые
без знака, логические, числа с плавающей точкой,
массивы фиксированной длины, массивы переменной
длины и структуры.</small></p>
<u><b>

<p><a NAME="t294000"></a>Соответствие портов</p>
</b></u>

<p><small>Программы RPC сервера, содержащие удаленные
процедуры, используют динамически назначаемые
порты, а не заранее известные порты. Это требует
&quot;регистрации&quot; в какой-либо форме, для того
чтобы постоянно иметь информацию, какая
динамически назначаемый порт использует та или
иная RPC программа. В Sun RPC этот регистратор
называется <a NAME="t294001"></a>преобразователь портов
(port mapper). (Port mapper - это сервер, который конвертирует
номера RPC программ в номера портов протоколов DARPA.
Этот сервер обязательно должен быть запущен,
чтобы можно было исполнить RPC вызов.)</small></p>

<p>&nbsp;</p>


<p>Термин &quot;порт&quot; (port) в
названии происходит от номеров портов TCP и UDP,
характеристики семейства протоколов Internet. Так
как TI-RPC работает поверх любых транспортных
уровней, а не только поверх TCP и UDP, название port mapper
в системах, использующих TI-RPC (<a NAME="t294002"></a>SVR4 и <a NAME="t294003"></a>Solaris 2.2, например), было преобразовано в <a NAME="t294004"></a>rpcbind. Однако мы будем продолжать
использовать более привычное - port mapper.</p>


<p>&nbsp;</p>

<p><small>В действительности, сам преобразователь
портов должен иметь заранее известный порт: UDP
порт 111 и TCP порт 111. Преобразователь портов - это
всего лишь программа RPC сервера. Он имеет номер
программы (100000), номер версии (2), TCP порт 111 и UDP порт
111. Серверы регистрируют друг друга в
преобразователе портов, используя RPC вызовы, а
клиенты запрашивают преобразователь портов,
используя RPC вызовы. Преобразователь портов
предоставляет четыре процедуры сервера:</small></p>

<p><small>&nbsp;</small> 

<ol>
  <li><small>PMAPPROC_SET. Вызывается RPC сервером при старте,
    чтобы зарегистрировать номер программы, номер
    версии и протокол в преобразователе портов. </small></li>
  <li><small>PMAPPROC_UNSET. Вызывается сервером, чтобы удалить
    ранее зарегистрированное преобразование. </small></li>
  <li><small>PMAPPROC_GETPORT. Вызывается RPC клиентом при старте,
    чтобы получить номер порта для заданного номера
    программы, номера версии и протокола. </small></li>
  <li><small>PMAPPROC_DUMP. Возвращает все пункты (номер
    программы, номер версии, протокол и номер порта) в
    базу данных преобразователя портов. </small></li>
</ol>

<p>&nbsp;</p>

<p><small>Когда стартует программа сервер RPC и позже,
когда она вызывается программой клиента RPC,
осуществляются следующие шаги.</small></p>

<p><small>&nbsp;</small> 

<ol>
  <li><small>Преобразователь портов должен стартовать
    первым, обычно при загрузке системы. При этом
    создается конечная точка TCP и осуществляется
    пассивное открытие TCP порта 111. Также создается
    конечная точка UDP, которая находится в ожидании,
    когда на UDP порт 111 прибудет UDP датаграмма. </small></li>
  <li><small>При старте программа сервера RPC создает
    конечную точку TCP и конечную точку UDP для каждой
    поддерживаемой версии программы. (Программа RPC
    может поддерживать несколько версий. Клиент
    указывает требуемую версию при вызове процедуры
    сервера.) Динамически назначаемый номер порта
    закрепляется за каждой конечной точкой. (Нет
    никакой разницы, одинаковые ли номера портов TCP и
    UDP или разные.) Сервер регистрирует каждую
    программу, версию, протокол и номер порта,
    осуществляя удаленной вызов процедуры
    преобразователя портов PMAPPROC_SET. </small></li>
  <li><small>Когда стартует программа клиента RPC, она
    вызывает процедуру преобразователя портов
    PMAPPROC_GETPORT, чтобы получить динамически
    назначаемый номер порта для заданной программы,
    версии и протокола. </small></li>
  <li><small>Клиент отправляет сообщение вызова RPC на
    номер порта, полученный в пункте 3. Если
    используется UDP, клиент просто посылает UDP
    датаграмму, содержащую сообщение вызова RPC
    (рисунок 29.1), на номер UDP порта сервера. В ответ
    сервер отправляет UDP датаграмму, содержащую
    сообщение RPC отклика (рисунок 29.2). Если
    используется TCP, клиент осуществляет активное
    открытие на номер TCP порта сервера и затем
    посылает сообщение вызова RPC по соединению.
    Сервер отвечает сообщением отклика RPC по
    соединению.</small></li>
</ol>

<p>&nbsp;</p>

<p><small>Программа <a NAME="t294005"></a>rpcinfo(8) печатает все
текущие настройки преобразователя портов. (Здесь
происходит вызов процедуры преобразователя
портов PMAPPROC_DUMP.) Ниже показан обычный вывод:</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>/usr/etc/rpcinfo -p</b><br>
program&nbsp;&nbsp;&nbsp; vers&nbsp;&nbsp;&nbsp; proto&nbsp;&nbsp;&nbsp; port<br>
&nbsp; 100005&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcp
&nbsp;&nbsp;&nbsp;&nbsp; 702&nbsp;&nbsp; mountd
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; демон
монтирования NFS<br>
&nbsp; 100005&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; udp
&nbsp;&nbsp;&nbsp;&nbsp; 699&nbsp;&nbsp; mountd<br>
&nbsp; 100005&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcp
&nbsp;&nbsp;&nbsp;&nbsp; 702&nbsp;&nbsp; mountd<br>
&nbsp; 100005&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; udp
&nbsp;&nbsp;&nbsp;&nbsp; 699&nbsp;&nbsp; mountd<br>
<br>
&nbsp; 100003&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; udp
&nbsp;&nbsp;&nbsp; 2049&nbsp;&nbsp; nfs
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; сам NFS<br>
<br>
&nbsp; 100021&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcp
&nbsp;&nbsp;&nbsp;&nbsp; 709&nbsp;&nbsp; nlockmgr
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; менеджер блокирования
NFS<br>
&nbsp; 100021&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; udp
&nbsp;&nbsp;&nbsp; 1036&nbsp;&nbsp; nlockmgr<br>
&nbsp; 100021&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcp
&nbsp;&nbsp;&nbsp;&nbsp; 721&nbsp;&nbsp; nlockmgr<br>
&nbsp; 100021&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; udp
&nbsp;&nbsp;&nbsp; 1039&nbsp;&nbsp; nlockmgr<br>
&nbsp; 100021&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcp
&nbsp;&nbsp;&nbsp;&nbsp; 713&nbsp;&nbsp; nlockmgr<br>
&nbsp; 100021&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; udp
&nbsp;&nbsp;&nbsp; 1037&nbsp;&nbsp; nlockmgr<br>
</p>


<p>&nbsp;</p>

<p><small>Мы видим, что некоторые программы
поддерживают несколько версий, и каждая
комбинация номера программы, номера версии и
протокола имеет свою собственную раскладку
номеров портов, обслуживаемую преобразователем
портов. </small></p>

<p><small>Доступ к обеим версиям монтирующего демона
можно получить через один и тот же номер TCP порта
(702) и один и тот же номер UDP порта (699), однако
каждая версия блокирующего менеджера имеет свой
собственный номер порта.</small></p>
<u><b>

<p><a NAME="t295000"></a>Протокол NFS</p>
</b></u>

<p><small>NFS предоставляет клиентам прозрачный
доступ к файлам и файловой системе сервера. Это
отличается от FTP (<a HREF="tcp27.html">глава 27</a>), который
обеспечивает передачу файлов. С помощью FTP
осуществляется полное копирование файла. NFS
осуществляет доступ только к тем частям файла, к
которым обратился процесс, и основное
достоинство NFS в том, что он делает этот доступ
прозрачным. Это означает, что любое приложение
клиента, которое может работать с локальным
файлом, с таким же успехом может работать и с NFS
файлом, без каких либо модификаций самой
программы. </small></p>

<p><small>NFS это приложение клиент-сервер,
построенное с использованием Sun RPC. NFS клиенты
получают доступ к файлам на NFS сервере путем
отправки RPC запросов на сервер. Это может быть
реализовано с использованием обычных
пользовательских процессов - а именно, NFS клиент
может быть пользовательским процессом, который
осуществляет конкретные RPC вызовы на сервер,
который так же может быть пользовательским
процессом. Однако, NFS обычно реализуется иначе,
это делается по двум причинам. Во-первых, доступ к
NFS файлам должен быть прозрачным для клиента.
Поэтому, вызовы NFS клиента осуществляются
операционной системой клиента от имени
пользовательского процесса клиента. Во-вторых, NFS
сервера реализованы внутри операционной системы
для повышения эффективности работы сервера. Если
бы NFS сервер являлся пользовательским процессом,
каждый запрос клиента и отклик сервера (включая
данные, которые будут считаны или записаны)
должен пройти через разделитель между ядром и
пользовательским процессом, что вообще довольно
дорогое удовольствие. </small></p>

<p><small>В этом разделе мы рассмотрим версию 2 NFS, как
она документирована в RFC 1094 [<a NAME="t295001"></a>Sun Microsystems
1988b]. Лучшее описание Sun RPC, XDR и NFS дано в [<a NAME="t295002"></a>X/Open
1991]. Подробности использования и
администрирования NFS приведены в [<a NAME="t295026"></a>Stern
1991]. Спецификации версии 3 протокола NFS были
реализованы в 1993 году, о чем мы поговорим в
разделе <a HREF="#t297000">&quot;NFS версия 3&quot;</a> этой главы. </small></p>

<p><small>На рисунке 29.3 показаны типичные настройки
NFS клиента и NFS сервера. На этом рисунке
необходимо обратить внимание на следующее.</small></p>

<p><small>&nbsp;</small> 

<ol>
  <li><small>Клиенту безразлично, получает ли он доступ к
    локальному файлу или к NFS файлу. Ядро определяет
    это, когда файл открыт. После того как файл
    открыт, ядро передает все обращения к локальным
    файлам в квадратик, помеченный как &quot;доступ к
    локальным файлам&quot;, а все ссылки на NFS файлы
    передаются в квадратик &quot;NFS клиент&quot;.</small></li>
  <li><small>NFS клиент отправляет RPC запросы NFS серверу
    через модуль TCP/IP. NFS обычно использует UDP, однако
    более новые реализации могут использовать TCP.</small></li>
  <li><small>NFS сервер получает запросы от клиента в виде
    UDP датаграмм на порт 2049. Несмотря на то, что NFS
    может работать с преобразователем портов, что
    позволяет серверу использовать динамически
    назначаемые порты, UDP порт 2049 жестко закреплен за
    NFS в большинстве реализаций.<a NAME="t295003"></a></small><p>&nbsp;</p>
    <p ALIGN="CENTER"><small><img SRC="t29_3000.jpg" WIDTH="511" HEIGHT="279"></small></p>
    <p ALIGN="CENTER"><small>Рисунок 29.3 Типичные
    настройки NFS клиента и NFS сервера.</small></p>
    <p>&nbsp;</p>
  </li>
  <li><small>Когда NFS сервер получает запрос от клиента,
    он передаются локальной подпрограмме доступа к
    файлу, которая обеспечивает доступ к локальному
    диску на сервере.</small></li>
  <li><small>Серверу может потребоваться время, для того
    чтобы обработать запросы клиента. Даже доступ к
    локальной файловой системе может занять
    некоторое время. В течение этого времени сервер
    не хочет блокировать запросы от других клиентов,
    которые также должны быть обслужены. Чтобы
    справиться с подобной ситуацией, большинство NFS
    серверов запускаются несколько раз, то есть
    внутри ядра существует несколько NFS серверов.
    Конкретные методы решения зависят от
    операционной системы. В большинстве ядер Unix
    систем не &quot;живет&quot; несколько NFS серверов,
    вместо этого запускается несколько
    пользовательских процессов (которые обычно
    называются <a NAME="t295004"></a>nfsd), которые осуществляют
    один системный вызов и остаются внутри ядра в
    качестве процесса ядра.</small></li>
  <li><small>Точно так же, NFS клиенту требуется время,
    чтобы обработать запрос от пользовательского
    процесса на хосте клиента. RPC выдается на хост
    сервера, после чего ожидается отклик. Для того,
    чтобы пользовательские процессы на хосте
    клиента могли в любой момент воспользоваться NFS,
    существует несколько NFS клиентов, запущенных
    внутри ядра клиента. Конкретная реализация также
    зависит от операционной системы. Unix система
    обычно использует технику, напоминающую NFS
    сервер: пользовательский процесс, называемый biod,
    осуществляет один единственный системный вызов
    и остается внутри ядра как процесс ядра.</small></li>
</ol>

<p>&nbsp;</p>

<p><small>Большинство Unix хостов может
функционировать как NFS клиент и как NFS сервер, или
как и то и другое одновременно. Большинство PC
реализаций (MS-DOS) имеют только реализации NFS
клиента. Большинство IBM мейнфреймов
предоставляет только функции NFS сервера. </small></p>

<p><small>NFS в действительности - это нечто большее,
чем просто NFS протокол. На рисунке 29.4 показаны
различные программы RPC, которые используются с NFS.<a NAME="t295005"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="590">
  <tr>
    <td WIDTH="42%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Приложение</small></td>
    <td WIDTH="20%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Номер
    программы</small></td>
    <td WIDTH="16%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Номер
    версии</small></td>
    <td WIDTH="22%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Количество
    процедур</small></td>
  </tr>
  <tr>
    <td WIDTH="42%" VALIGN="TOP"><small>преобразователь
    портов</small></td>
    <td WIDTH="20%" VALIGN="TOP"><p ALIGN="CENTER"><small>100000</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>2</small></td>
    <td WIDTH="22%" VALIGN="TOP"><p ALIGN="CENTER"><small>4</small></td>
  </tr>
  <tr>
    <td WIDTH="42%" VALIGN="TOP"><small>NFS</small></td>
    <td WIDTH="20%" VALIGN="TOP"><p ALIGN="CENTER"><small>100003</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>2</small></td>
    <td WIDTH="22%" VALIGN="TOP"><p ALIGN="CENTER"><small>15</small></td>
  </tr>
  <tr>
    <td WIDTH="42%" VALIGN="TOP"><small>программа mount</small></td>
    <td WIDTH="20%" VALIGN="TOP"><p ALIGN="CENTER"><small>100005</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="22%" VALIGN="TOP"><p ALIGN="CENTER"><small>5</small></td>
  </tr>
  <tr>
    <td WIDTH="42%" VALIGN="TOP"><small>менеджер
    блокирования</small></td>
    <td WIDTH="20%" VALIGN="TOP"><p ALIGN="CENTER"><small>100021</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>1,2,3</small></td>
    <td WIDTH="22%" VALIGN="TOP"><p ALIGN="CENTER"><small>19</small></td>
  </tr>
  <tr>
    <td WIDTH="42%" VALIGN="TOP"><small>монитор статуса</small></td>
    <td WIDTH="20%" VALIGN="TOP"><p ALIGN="CENTER"><small>100024</small></td>
    <td WIDTH="16%" VALIGN="TOP"><p ALIGN="CENTER"><small>1</small></td>
    <td WIDTH="22%" VALIGN="TOP"><p ALIGN="CENTER"><small>6</small></td>
  </tr>
</table>


<p><small>Рисунок 29.4 Различные RPC программы,
используемые в NFS.</small></p>

<p>&nbsp;</p>


<p>Версии, которые мы
показали на этом рисунке в виде единиц, найдены в
таких системах как <a NAME="t295006"></a>SunOS 4.1.3. Новые
реализации предоставляют более новые версии
некоторых программ. <a NAME="t295007"></a>Solaris&nbsp;2.2,
например, также поддерживает версии 3 и 4
преобразователя портов и версию 2 демона mount. <a NAME="t295008"></a>SVR4 также поддерживает версию 3
преобразователя портов.</p>


<p>&nbsp;</p>

<p><small>Демон монтирования вызывается на хосте NFS
клиента, перед тем как клиент может получить
доступ к файловой системе сервера. Мы опишем этот
процесс ниже. </small></p>

<p><small><a NAME="t295009"></a>Менеджер блокирования и <a NAME="t295010"></a>монитор статуса позволяют клиенту
заблокировать часть файлов, которые находятся на
NFS сервере. Эти две программы не зависимы от
протокола NFS, потому что блокирование требует
идентификации клиента и на хосте клиента, и на
сервере, а NFS сам по себе &quot;безразличен&quot;. (Ниже
мы скажем о безразличности NFS более подробно.)
Главы 9, 10 и 11 [<a NAME="t295011"></a>X/Open 1991] документируют
процедуры, которые используются менеджером
блокирования и монитором статуса для
блокирования в NFS.</small></p>
<i><b>

<p><a NAME="t295012"></a>Описатели файлов</p>
</b></i>

<p><small>Одна из основ NFS реализуется описателями
файлов. Для обращения к файлу или директории на
сервере объекта используется <a NAME="t295013"></a>opaque.
Термин opaque обозначает, что сервер создает
описатель файла, передает его обратно клиенту,
который клиент затем использует при обращении к
файлу. Клиент никогда не просматривает
содержимое описателя файла - его содержимое
представляет интерес только для сервера. </small></p>

<p><small>NFS клиент получает описатель файла каждый
раз когда открывает файл, который в
действительности находится на NFS сервере. Когда
NFS клиент читает или пишет в этот файл (по
поручению пользовательского процесса),
описатель файла передается обратно серверу. Это
указывает на то, что доступ к файлу был
осуществлен. </small></p>

<p><small>Обычно пользовательский процесс не
работает с описателями файлов. Обмен описателями
файлов осуществляют NFS клиент и NFS сервер. В
версии 2 NFS описатель файла занимает 32 байта, а в
версии 3 он вырос до 64 байт.</small></p>

<p>&nbsp;</p>


<p>Unix серверы обычно
хранят в описателе файла следующую информацию:
идентификатор файловой системы (major и minor номера
устройства файловой системы), номер инода (i-node)
(уникальный номер внутри файловой системы), номер
поколения инода (номер, который изменяется
каждый раз, когда инод повторно используется для
другого файла).</p>


<p>&nbsp;</p>
<i><b>

<p><a NAME="t295014"></a>Протокол монтирования</p>
</b></i>

<p><small>Клиент использует NFS протокол монтирования,
чтобы смонтировать файловую систему сервера,
перед тем как получить доступ к NFS файлам. Обычно
это происходит при загрузке клиента. В
результате клиент получает описатель файла
файловой системы сервера. </small></p>

<p><small>На рисунке 29.5 описана последовательность
действий Unix клиента при исполнении команды <a NAME="t295015"></a>mount(8).<a NAME="t295016"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t29_5000.jpg" WIDTH="519" HEIGHT="261"></small></p>


<p ALIGN="CENTER"><small>Рисунок 29.5 Протокол монтирования,
используемый Unix командой mount.</small></p>

<p>&nbsp;</p>

<p><small>При этом осуществляются следующие шаги.</small></p>

<p><small>&nbsp;</small> 

<ol>
  <li><small>При загрузке сервера на нем стартует
    преобразователь портов.</small></li>
  <li><small>После преобразователя портов на сервере
    стартует демон монтирования (<a NAME="t295017"></a>mountd). Он
    создает конечную точку TCP и конечную точку UDP, а
    также назначает каждой из них динамически
    назначаемый номер порта. Затем он регистрирует
    эти номера у преобразователя портов.</small></li>
  <li><small>Клиент исполняется команду mount, которая
    выдает RPC вызов на преобразователь портов
    сервера, чтобы получить номер порта от демона
    монтирования на сервере. Для обмена между
    клиентом и преобразователем портов могут быть
    использованы и TCP и UDP, однако обычно используется
    UDP.</small></li>
  <li><small>Преобразователь портов сообщает номер
    порта.</small></li>
  <li><small>Команда mount выдает RPC вызов демону
    монтирования, чтобы смонтировать файловую
    систему сервера. И снова может быть использован
    как TCP, так и UDP, однако обычно используется UDP.
    Теперь сервер может проверить &quot;годность&quot;
    клиента основываясь на его IP адресе и номере
    порта, чтобы убедиться, можно ли этому клиенту
    смонтировать указанную файловую систему.</small></li>
  <li><small>Демон монтирования откликается описателем
    файла указанной файловой системы.</small></li>
  <li><small>Команда mount клиента выдает системный вызов
    mount, чтобы связать описатель файла, полученный в
    шаге 5, с локальной точкой монтирования на хосте
    клиента. Описатель файла хранится в коде NFS
    клиента, и с этого момента любое обращение
    пользовательских процессов к файлам на файловой
    системе сервера будет использовать описатель
    файла как стартовую точку.</small></li>
</ol>

<p>&nbsp;</p>

<p><small>Подобная реализация отдает весь процесс
монтирования, кроме системного вызова mount на
клиенте, пользовательским процессам, а не ядру.
Три программы, которые мы показали - команда mount,
преобразователь портов и демон монтирования -
пользовательские процессы. </small></p>

<p><small>В этом примере на хосте sun (NFS клиент) была
исполнена команда</small></p>

<p>&nbsp;</p>


<p>sun <b># mount -t nfs bsdi:/usr /nfs/bsdi/usr</p>
</b>

<p>&nbsp;</p>

<p><small>Эта команда монтирует директорию /usr на
хосте bsdi (NFS сервер) как локальную файловую
систему /nfs/bsdi/usr. На рисунке 29.6 показан результат.<a NAME="t295018"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t29_6000.jpg" WIDTH="284" HEIGHT="339"></small></p>


<p ALIGN="CENTER"><small>Рисунок 29.6 Монтирование директории
bsdi:/usr как /nfs/bsdi/usr на хосте sun.</small></p>

<p>&nbsp;</p>

<p><small>После чего при обращении к файлу
/nfs/bsdi/usr/rstevens/hello.c на клиенте sun, происходит
обращение к файлу /usr/rstevens/hello.c на сервере bsdi.</small></p>
<i><b>

<p><a NAME="t295019"></a>Процедуры NFS</p>
</b></i>

<p><small>NFS сервер предоставляет 15 процедур, которые
мы сейчас опишем. (Числа, которые использованные
при описании, не совпадают с номерами NFS процедур,
так как мы сгруппировали их по функциональному
признаку.) Несмотря на то что NFS разрабатывалась
таким образом, чтобы работать между различными
операционными системами, а не только между Unix
системами, некоторые из процедур основаны именно
на Unix функционировании, что, в свою очередь, может
не поддерживаться другими операционными
системами (например, жесткие линки,
символические линки, групповое пользование,
права доступа на исполнение и так далее). Глава 4
[Stevens 1992] содержит дополнительную информацию о
характеристиках файловых систем, некоторыми из
которых пользуется NFS.</small></p>

<p><small>&nbsp;</small> 

<ol>
  <li><small>GETATTR. Возвращает атрибуты файлов: тип файла
    (обычный файл, директория и так далее), права
    доступа, размер файла, владельца файла, время
    последнего обращения и так далее.</small></li>
  <li><small>SETATTR. Устанавливает атрибуты файла.
    Установлен может быть только определенный набор
    атрибутов: права доступа, владелец, групповое
    владение, размер, время последнего обращения и
    время последней модификации.</small></li>
  <li><small>STATFS. Возвращает статус файловой системы:
    размер свободного пространства, оптимальный
    размер для передачи и так далее. Используется,
    например, Unix командой df.</small></li>
  <li><small>LOOKUP. &quot;Оценивает&quot; файл. Эта процедура
    вызывается клиентом каждый раз, когда
    пользовательский процесс открывает файл,
    который находится на NFS сервере. Возвращается
    описатель файла, вместе с атрибутами файла.</small></li>
  <li><small>READ. Читает из файла. Клиент указывает
    описатель файла, начальное смещение в байтах и
    максимальное количество байтов, которое
    необходимо считать (до 8192).</small></li>
  <li><small><a NAME="t295020"></a>WRITE. Записывает в файл. Клиент
    указывает описатель файла, начальное смещение в
    байтах, количество байт, которое необходимо
    записать, и данные, которые необходимо записать.</small><p><small>Требуется,
    чтобы NFS записи были <a NAME="t295021"></a>синхронными (с
    ожиданием). Сервер не может ответить OK до тех пор,
    пока данные не были успешно записаны (и любая
    другая информация о файле, которая должна быть
    обновлена) на диск.</small></p>
  </li>
  <li><small>CREATE. Создает файл.</small></li>
  <li><small>REMOVE. Удаляет файл.</small></li>
  <li><small>RENAME. Переименовывает файл.</small></li>
  <li><small>LINK. Делает жесткий линк на файл. Жесткий линк
    это Unix концепция, которая определяет, что
    конкретный файл на диске может иметь любое
    количество точек входа (имен, которые также
    называются жесткими линками), которые указывают
    на этот файл.</small></li>
  <li><small>SYMLINK. Создает символический линк на файл.
    Символический линк это файл, который содержит
    имя другого файла. Большинство операций, которые
    осуществляются над символическим линком
    (например, открытие), в действительности
    совершаются с тем файлом, на котороый указывает
    символический линк.</small></li>
  <li><small>READLINK. Чтение символического линка
    возвращает имя файла, на который указывает
    символический линк.</small></li>
  <li><small>MKDIR. Создает директорию.</small></li>
  <li><small>RMDIR. Удаляет директорию.</small></li>
  <li><small>READDIR. Читает директорию. Используется,
    например, Unix командой ls.</small></li>
</ol>

<p>&nbsp;</p>

<p><small>В действительности, приведенные имена
процедур начинаются с префикса NFSPROC_, который мы
опустили.</small></p>
<i><b>

<p><a NAME="t295022"></a>UDP или TCP? </p>
</b></i>

<p><small>NFS был исходно написан, чтобы использовать
UDP, и эту возможность предоставляют все
производители. Однако, более новые реализации,
также поддерживают TCP. Поддержка TCP используется
для работы в глобальных сетях, которые
становится все быстрее. Поэтому использование NFS
в настоящее время уже не ограничено локальными
сетями. </small></p>

<p><small>Границы между локальными и глобальными
сетями стираются, и все это происходит очень
быстро. Времена возврата меняются в очень
широком диапазоне, и все чаще возникает
переполнение. Эти характеристики глобальных
сетей приводят к тому, что все чаще в них
используются алгоритмы, которые мы
рассматривали для TCP - медленный старт и
избежание переполнения. Так как UDP не
предоставляет ничего похожего на эти алгоритмы,
то они или им подобные должны быть встроены в NFS
клиент и сервер, иначе необходимо использовать
TCP.</small></p>
<i><b>

<p><a NAME="t295023"></a>NFS поверх TCP</p>
</b></i>

<p><small>Реализация NFS Berkeley Net/2 поддерживает как UDP,
так и TCP. [<a NAME="t295024"></a>Macklem 1991] описывает эту
реализацию. Давайте рассмотрим, чем отличается
использование NFS при работе поверх TCP.</small></p>

<p><small>&nbsp;</small> 

<ol>
  <li><small>Когда сервер загружается, он запускает NFS
    сервер, который осуществляет активное открытие
    на TCP порт 2049, ожидая прихода запроса на
    соединение от клиента. Это обычно делается в
    дополнение к обычному NFS UDP, который ожидает
    входящие датаграммы на UDP порте 2049.</small></li>
  <li><small>Когда клиент монтирует файловую систему
    сервера с использованием TCP, он осуществляет
    активное открытие на TCP порт 2049 на сервере. При
    этом устанавливается TCP соединение между
    клиентом и сервером для этой файловой системы.
    Если тот же самый клиент монтирует еще одну
    файловую систему на том же самом сервере,
    создается еще одно TCP соединение.</small></li>
  <li><small>И клиент, и сервер устанавливают TCP опцию <a NAME="t295025"></a>&quot;оставайся в живых&quot; на своих
    концах соединения (<a HREF="tcp23.html">глава 23</a>). Это
    позволяет определить момент выхода из строя или
    перезагрузки того или иного участника обмена.</small></li>
  <li><small>Все приложения на клиенте, которые
    используют файловую систему сервера, делят одно
    и то же TCP соединение для этой файловой системы.
    Например, если была на рисунке 29.6, бы еще одна
    директория на bsdi, с именем smith, ниже директории /usr,
    обращения к файлам в /nfs/bsdi/usr/rstevens и /nfs/bsdi/usr/smith
    делили бы одно и то же TCP соединение.</small></li>
  <li><small>Если клиент определяет, что сервер вышел из
    строя или перезагрузился (после получения TCP
    ошибки &quot;соединение закрыто по тайм-ауту&quot; или
    &quot;соединение закрыто хостом&quot;), он старается
    повторно подсоединиться к серверу. Клиент
    осуществляет еще одно активное открытие, чтобы
    повторно установить TCP соединение для этой
    файловой системы. Любой запрос от клиента, для
    которого отработан тайм-аут на предыдущем
    соединении, повторно выдается на новое
    соединение.</small></li>
  <li><small>Если клиент вышел из строя, то же происходит
    и с приложениями, которые работали до выхода из
    строя. Когда клиент перезагружается, он,
    возможно, повторно смонтирует файловую систему
    сервера с использованием TCP, причем будет
    использовано другое TCP соединение с сервером.
    Предыдущее соединение между клиентом и сервером
    для этой файловой системы находится в
    полуоткрытом состоянии (сервер думает, что оно
    все еще открыто), однако так как сервер установил
    опцию &quot;оставайся в живых&quot;, это полуоткрытое
    соединение будет закрыто, когда TCP сервер пошлет
    следующую пробу &quot;оставайся в живых&quot;.</small></li>
</ol>

<p>&nbsp;</p>

<p><small>Со временем и другие производители
планируют начать поддержку NFS поверх TCP.</small></p>
<u><b>

<p><a NAME="t296000"></a>Примеры NFS</p>
</b></u>

<p><small>Давайте воспользуемся <a NAME="t296001"></a>tcpdump,
чтобы посмотреть, какие NFS процедуры
привлекаются клиентом для обычных операций с
файлом. Когда tcpdump определяет, что UDP датаграмма
содержит RPC вызов (call равен 0 на рисунке&nbsp;29.1) с
портом назначения 2049, он декодирует датаграмму
как NFS запрос. Точно так же, если UDP датаграмма
содержит RPC отклик (reply равен 1 на рисунке 29.2) с
портом источника равным 2049, он декодирует
датаграмму как NFS отклик.</small></p>
<i><b>

<p>Простой пример: чтение файла</p>
</b></i>

<p><small>В первом примере мы скопируем файл,
находиться на NFS сервере, на терминал с
использованием команды <a NAME="t296002"></a>cat(1):</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>cat /nfs/bsdi/usr/rstevens/hello.c </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; копирование файла на
терминал<br>
main()<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf
(&quot;hello, world\n&quot;);<br>
}<br>
</p>


<p>&nbsp;</p>

<p><small>Файловая система /nfs/bsdi/usr на хосте sun (NFS
клиент) в действительности является файловой
системой /usr на хосте bsdi (NFS сервер), как показано
на рисунке 29.6. Ядро sun определяет это, когда cat
открывает файл и использует NFS для доступа к
файлу. На рисунке 29.7 показан вывод команды tcpdump.<a NAME="t296003"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.7aa6
&gt; bsdi.nfs: 104 getattr<br>
2&nbsp; 0.003587 (0.0036)&nbsp;&nbsp;&nbsp; bsdi.nfs &gt; sun.7aa6: reply ok 96<br>
<br>
3&nbsp; 0.005390 (0.0018)&nbsp;&nbsp;&nbsp; sun.7aa7 &gt; bsdi.nfs: 116 lookup
&quot;rstevens&quot;<br>
4&nbsp; 0.009570 (0.0042)&nbsp;&nbsp;&nbsp; bsdi.nfs &gt; sun.7aa7: reply ok 128<br>
<br>
5&nbsp; 0.011413 (0.0018)&nbsp;&nbsp;&nbsp; sun.7aa8 &gt; bsdi.nfs: 116 lookup
&quot;hello.c&quot;<br>
6&nbsp; 0.015512 (0.0041)&nbsp;&nbsp;&nbsp; bsdi.nfs &gt; sun.7aa8: reply ok 128<br>
<br>
7&nbsp; 0.018843 (0.0033)&nbsp;&nbsp;&nbsp; sun.7aa9 &gt; bsdi.nfs: 104 getattr<br>
8&nbsp; 0.022377 (0.0035)&nbsp;&nbsp;&nbsp; bsdi.nfs &gt; sun.7aa9: reply ok 96<br>
<br>
9&nbsp; 0.027621 (0.0052)&nbsp;&nbsp;&nbsp; sun.7aaa &gt; bsdi.nfs: 116 read 1024 bytes @
0<br>
10&nbsp; 0.032170 (0.0045)&nbsp;&nbsp;&nbsp; bsdi.nfs &gt; sun.7aaa: reply ok 140<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 29.7 Функционирование NFS при чтении
файла.</small></p>

<p>&nbsp;</p>

<p><small>Команда tcpdump декодирует NFS запрос или
отклик, также она печатает поле <a NAME="t296004"></a>XID для
клиента, вместо номера порта. Поле XID в строках 1 и
2 равно 0x7aa6. </small></p>

<p><small>Имя файла /nfs/bsdi/usr/rstevens/hello.c обрабатывается
функцией открытия в ядре клиента по одному
элементу имени за раз. Когда функция открытия
достигает /nfs/bsdi/usr, она определяет, что это точка
монтирования файловой системы NFS. </small></p>

<p><small>В строке 1 клиент вызывает процедуру GETATTR,
чтобы получить атрибуты директории сервера,
которую смонтировал клиент (/usr). Этот RPC запрос
содержит 104 байта данных, помимо IP и UDP заголовков.
Отклик в строке 2 возвращает OK и содержит 96 байт
данных, помимо IP и UDP заголовков. Мы видим на этом
рисунке, что минимальное NFS сообщение содержит
примерно 100 байт данных. </small></p>

<p><small>В строке 3 клиент вызывает процедуру LOOKUP для
файла rstevens и получает отклик OK в строке 4. LOOKUP
указывает имя файла rstevens и описатель файла,
который был сохранен ядром, когда монтировалась
удаленная файловая система. Отклик содержит
новый описатель файла, который используется в
следующем шаге. </small></p>

<p><small>В строке 5 клиент осуществляет LOOKUP файла
hello.c с использованием описателя файла из строки 4.
Он получает другой описатель файла в строке 6.
Этот новый описатель файла как раз то, что клиент
использует в строках 7 и 9, чтобы обратиться к
файлу /nfs/bsdi/usr/rstevens/hello.c. Мы видим, что клиент
осуществляет LOOKUP для каждого компонента имени в
пути к открываемому файлу. </small></p>

<p><small>В строке 7 клиент еще раз исполняет GETATTR,
затем следует READ в строке 9. Клиент запрашивает 1024
байта, начиная со смещения равного 0, однако
получает данных меньше чем 1024 байта. (После
вычитания размеров RPC полей и других значений,
возвращенных процедурой READ, в строке 10
возвращаются 38 байт данных. Это как раз размер
файла hello.c.) </small></p>

<p><small>В этом примере пользовательский процесс
ничего не знает об этих NFS запросах и откликах,
которые осуществляются ядром. Приложение всего
лишь вызывает функцию открытия ядра, которая
вызывает обмен 3 запросами и 3 откликами (строки
1-6), а затем вызывает функцию чтение ядра, которая
вызывает 2 запроса и 2 отклика (строки 7-10). Для
приложения клиента, файл, находящийся на NFS
сервере, прозрачен.</small></p>
<i><b>

<p>Простой пример: создание директории</p>
</b></i>

<p><small>В качестве еще одного примера сменим
рабочую директорию на директорию, которая
находится на NFS сервере, а затем создадим новую
директорию:</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>cd /nfs/bsdi/usr/rstevens </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; меняем
рабочую директорию<br>
sun % <b>mkdir Mail </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; создаем
директорию<br>
</p>


<p>&nbsp;</p>

<p><small>На рисунке 29.8 показан вывод команды tcpdump.<a NAME="t296005"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp;&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.7ad2
&gt; bsdi.nfs: 104 getattr<br>
2&nbsp;&nbsp; 0.004912 ( 0.0049)&nbsp;&nbsp;&nbsp; bsdi.nfs &gt; sun.7ad2: reply ok 96<br>
<br>
3&nbsp;&nbsp; 0.007266 ( 0.0024)&nbsp;&nbsp;&nbsp; sun.7ad3 &gt; bsdi.nfs: 104 getattr<br>
4&nbsp;&nbsp; 0.010846 ( 0.0036)&nbsp;&nbsp;&nbsp; bsdi.nfs &gt; sun.7ad3: reply ok 96<br>
<br>
5&nbsp; 35.769875 (35.7590)&nbsp;&nbsp;&nbsp; sun.7ad4 &gt; bsdi.nfs: 104 getattr<br>
6&nbsp; 35.773432 ( 0.0036)&nbsp;&nbsp;&nbsp; bsdi.nfs &gt; sun.7ad4: reply ok 96<br>
<br>
7&nbsp; 35.775236 ( 0.0018)&nbsp;&nbsp;&nbsp; sun.7ad5 &gt; bsdi.nfs: 112 lookup
&quot;Mail&quot;<br>
8&nbsp; 35.780914 ( 0.0057)&nbsp;&nbsp;&nbsp; bsdi.nfs &gt; sun.7ad5: reply ok 28<br>
<br>
9&nbsp; 35.782339 ( 0.0014)&nbsp;&nbsp;&nbsp; sun.7ad6 &gt; bsdi.nfs: 144 mkdir
&quot;Mail&quot;<br>
10&nbsp; 35.992354 ( 0.2100)&nbsp;&nbsp;&nbsp; bsdi.nfs &gt; sun.7ad6: reply ok 128<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 29.8 Функционирование NFS при смене
директории (cd) на NFS директорию, а затем создание
директории (mkdir).&nbsp;</small></p>

<p><small>При смене директории клиент вызывает
процедуру GETATTR дважды (строки 1-4). Когда мы создаем
новую директорию, клиент вызывает процедуру GETATTR
(строки 5 и 6), затем LOOKUP (строки 7 и 8, чтобы
проверить, что такой директории не существует),
затем MKDIR, чтобы создать директорию (строки 9 и 10).
Отклик OK в строке 8 не означает, что директория
существует. Он просто означает, что процедура
вернула какое-то значение. <a NAME="t296006"></a>tcpdump не
интерпретирует значение, возвращаемое NFS
процедурами. Команда просто печатает OK и
количество байт данных в отклике.</small></p>
<i><b>

<p><a NAME="t296007"></a>Безразличность</p>
</b></i>

<p><small>Одна из характеристик NFS (критики NFS
называют это бородавкой, а не характеристикой)
заключается в том, что NFS сервер безразличен.
Сервер не заботится о том, какие клиенты получают
доступ и к каким файлам. Заметьте, что в списке NFS
процедур, показанных ранее, нет процедуры
открытия или закрытия. Процедура LOOKUP напоминает
открытие, однако сервер никогда не знает,
осуществил ли клиент обращение к файлу, после
того как был сделан LOOKUP. </small></p>

<p><small>Причина такого &quot;безразличного
поведения&quot; заключается в том, чтобы упростить
восстановление после выхода из строя сервера,
после того как он сломался и перезагрузился.</small></p>
<i><b>

<p>Пример: выход сервера из строя</p>
</b></i>

<p><small>В следующем примере мы читаем файл с NFS
сервера, когда сервер выходит из строя и
перезагружается. Это покажет как
&quot;безразличность&quot; сервера позволяет, клиенту
&quot;не знать&quot; о том, что сервер вышел из строя.
Все то время, пока сервер сломался и
перезагружается, клиент не знает о проблеме, и
приложение клиента работает так же, как и раньше. </small></p>

<p><small>На клиенте sun мы стартовали <a NAME="t296008"></a>cat с
очень большим файлом в качестве аргумента
(/usr/share/lib/termcap на NFS сервере svr4), отсоединили Ethernet
кабель в процессе передачи, выключили и
перезагрузили сервер и затем снова подсоединили
кабель. Клиент был сконфигурирован таким
образом, чтобы читать 1024 байта за одно NFS чтение.
На рисунке 29.9 показан вывод tcpdump. </small></p>

<p><small>Строки 1-10 соответствуют открытию файла
клиентом. Эта операция напоминает ту, что
показана на рисунке 29.7. В строке 11 мы видим первое
чтение (READ) из файла 1024-х байт данных; отклик
возвратился в строке 12. Это продолжается до
строки 129 (чтение READ по 1024 байта и затем отклик OK). </small></p>

<p><small><a NAME="t296009"></a>В строках 130 и 131 мы видим два
запроса, которые отработаны по тайм-ауту и
повторно переданы в строках 132 и 133. Первый вопрос:
мы видим два запроса на чтение, один начинается
со смещения 65536, а другой начинается со смещения
73728, почему? Ядро клиента определило, что
приложение клиента осуществляет
последовательное считывание, и постаралось
получить блоки данных заранее. (Большинство Unix
ядер осуществляют это чтение вперед (read-ahead).) Ядро
клиента также запустило несколько NFS демонов
блочного ввода-вывода (I/O) (biod процессы), которые
стараются сгенерировать несколько RPC запросов от
имени клиента. Один демон считывает 8192 байта,
начиная с 65536 (в 1024-байтных цепочках), а другие
осуществляют чтение вперед по 8192 байта, начиная с
73728. </small></p>

<p><small>Повторные передачи клиента появляются в
строках 130-168. В строке 169 мы видим, что сервер
перезагрузился, и послал ARP запрос перед тем, как
откликнуться на NFS запрос клиента из строки 168.
Отклик на строку 168 посылается в строке 171.
Запросы клиента на чтение (READ) продолжаются.<a NAME="t296010"></a></small></p>

<p>&nbsp;</p>


<p><br>
&nbsp; 1&nbsp;&nbsp;&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.7ade
&gt; svr4.nfs: 104 getattr<br>
&nbsp; 2&nbsp;&nbsp;&nbsp; 0.007653 ( 0.0077)&nbsp;&nbsp;&nbsp; svr4.nfs &gt; sun.7ade:
reply ok 96<br>
<br>
&nbsp; 3&nbsp;&nbsp;&nbsp; 0.009041 ( 0.0014)&nbsp;&nbsp;&nbsp; sun.7adf &gt; svr4.nfs:
116 lookup &quot;share&quot;<br>
&nbsp; 4&nbsp;&nbsp;&nbsp; 0.017237 ( 0.0082)&nbsp;&nbsp;&nbsp; svr4.nfs &gt; sun.7adf:
reply ok 128<br>
<br>
&nbsp; 5&nbsp;&nbsp;&nbsp; 0.018518 ( 0.0013)&nbsp;&nbsp;&nbsp; sun.7ae0 &gt; svr4.nfs:
112 lookup &quot;lib&quot;<br>
&nbsp; 6&nbsp;&nbsp;&nbsp; 0.026802 ( 0.0083)&nbsp;&nbsp;&nbsp; svr4.nfs &gt; sun.7ae0:
reply ok 128<br>
<br>
&nbsp; 7&nbsp;&nbsp;&nbsp; 0.028096 ( 0.0013)&nbsp;&nbsp;&nbsp; sun.7ae1 &gt; svr4.nfs:
116 lookup &quot;termcap&quot;<br>
&nbsp; 8&nbsp;&nbsp;&nbsp; 0.036434 ( 0.0083)&nbsp;&nbsp;&nbsp; svr4.nfs &gt; sun.7ae1:
reply ok 128<br>
<br>
&nbsp; 9&nbsp;&nbsp;&nbsp; 0.038060 ( 0.0016)&nbsp;&nbsp;&nbsp; sun.7ae2 &gt; svr4.nfs:
104 getattr<br>
10&nbsp;&nbsp;&nbsp; 0.045821 ( 0.0078)&nbsp;&nbsp;&nbsp; svr4.nfs &gt; sun.7ae2: reply ok
96<br>
<br>
11&nbsp;&nbsp;&nbsp; 0.050984 ( 0.0052)&nbsp;&nbsp;&nbsp; sun.7ae3 &gt; svr4.nfs: 116 read
1024 bytes @ 0<br>
12&nbsp;&nbsp;&nbsp; 0.084995 ( 0.0340)&nbsp;&nbsp;&nbsp; svr4.nfs &gt; sun.7ae3: reply ok
1124<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; считывание<br>
<br>
128&nbsp;&nbsp;&nbsp; 3.430313 ( 0.0013)&nbsp;&nbsp;&nbsp; sun.7b22 &gt; svr4.nfs: 116
read 1024 bytes @ 64512<br>
129&nbsp;&nbsp;&nbsp; 3.441828 ( 0.0115)&nbsp;&nbsp;&nbsp; svr4.nfs &gt; sun.7b22: reply
ok 1124<br>
<br>
130&nbsp;&nbsp;&nbsp; 4.125031 ( 0.6832)&nbsp;&nbsp;&nbsp; sun.7b23 &gt; svr4.nfs: 116
read 1024 bytes @ 65536<br>
131&nbsp;&nbsp;&nbsp; 4.868593 ( 0.7436)&nbsp;&nbsp;&nbsp; sun.7b24 &gt; svr4.nfs: 116
read 1024 bytes @ 73728<br>
<br>
132&nbsp;&nbsp;&nbsp; 4.993021 ( 0.1244)&nbsp;&nbsp;&nbsp; sun.7b23 &gt; svr4.nfs: 116
read 1024 bytes @ 65536<br>
133&nbsp;&nbsp;&nbsp; 5.732217 ( 0.7392)&nbsp;&nbsp;&nbsp; sun.7b24 &gt; svr4.nfs: 116
read 1024 bytes @ 73728<br>
<br>
134&nbsp;&nbsp;&nbsp; 6.732084 ( 0.9999)&nbsp;&nbsp;&nbsp; sun.7b23 &gt; svr4.nfs: 116
read 1024 bytes @ 65536<br>
135&nbsp;&nbsp;&nbsp; 7.472098 ( 0.7400)&nbsp;&nbsp;&nbsp; sun.7b24 &gt; svr4.nfs: 116
read 1024 bytes @ 73728<br>
<br>
136&nbsp;&nbsp; 10.211964 ( 2.7399)&nbsp;&nbsp;&nbsp; sun.7b23 &gt; svr4.nfs: 116 read
1024 bytes @ 65536<br>
137&nbsp;&nbsp; 10.951960 ( 0.7400)&nbsp;&nbsp;&nbsp; sun.7b24 &gt; svr4.nfs: 116 read
1024 bytes @ 73728<br>
<br>
138&nbsp;&nbsp; 17.171767 ( 6.2198)&nbsp;&nbsp;&nbsp; sun.7b23 &gt; svr4.nfs: 116 read
1024 bytes @ 65536<br>
139&nbsp;&nbsp; 17.911762 ( 0.7400)&nbsp;&nbsp;&nbsp; sun.7b24 &gt; svr4.nfs: 116 read
1024 bytes @ 73728<br>
<br>
140&nbsp;&nbsp; 31.092136 (13.1804)&nbsp;&nbsp;&nbsp; sun.7b23 &gt; svr4.nfs: 116 read
1024 bytes @ 65536<br>
141&nbsp;&nbsp; 31.831432 ( 0.7393)&nbsp;&nbsp;&nbsp; sun.7b24 &gt; svr4.nfs: 116 read
1024 bytes @ 73728<br>
<br>
142&nbsp;&nbsp; 51.090854 (19.2594)&nbsp;&nbsp;&nbsp; sun.7b23 &gt; svr4.nfs: 116 read
1024 bytes @ 65536<br>
143&nbsp;&nbsp; 51.830939 ( 0.7401)&nbsp;&nbsp;&nbsp; sun.7b24 &gt; svr4.nfs: 116 read
1024 bytes @ 73728<br>
<br>
144&nbsp;&nbsp; 71.090305 (19.2594)&nbsp;&nbsp;&nbsp; sun.7b23 &gt; svr4.nfs: 116 read
1024 bytes @ 65536<br>
145&nbsp;&nbsp; 71.830155 ( 0.7398)&nbsp;&nbsp;&nbsp; sun.7b24 &gt; svr4.nfs: 116 read
1024 bytes @ 73728<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; повторные
передачи<br>
<br>
167&nbsp; 291.824285 ( 0.7400)&nbsp;&nbsp;&nbsp; sun.7b24 &gt; svr4.nfs: 116 read 1024
bytes @ 73728<br>
168&nbsp; 311.083676 (19.2594)&nbsp;&nbsp;&nbsp; sun.7b23 &gt; svr4.nfs: 116 read 1024
bytes @ 65536<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; сервер
перезагрузился<br>
<br>
169&nbsp; 311.149476 ( 0.0658)&nbsp;&nbsp;&nbsp; arp who-has sun tell svr4<br>
170&nbsp; 311.150004 ( 0.0005)&nbsp;&nbsp;&nbsp; arp reply sun is-at 8:0:20:3:f6:42<br>
<br>
171&nbsp; 311.154852 ( 0.0048)&nbsp;&nbsp;&nbsp; svr4.nfs &gt; sun.7b23: reply ok 1124<br>
<br>
172&nbsp; 311.156671 ( 0.0018)&nbsp;&nbsp;&nbsp; sun.7b25 &gt; svr4.nfs: 116 read 1024
bytes @ 66560<br>
173&nbsp; 311.168926 ( 0.0123)&nbsp;&nbsp;&nbsp; svr4.nfs &gt; sun.7b25: reply ok 1124<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; считывание<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 29.9 Считывание файла клиентом, когда
NFS сервер вышел из строя и перезагрузился.</small></p>

<p>&nbsp;</p>

<p><small>Приложение клиента никогда не узнает, что
сервер выходил из строя и перезагружался, за
исключением того, что между строками 129 и 171 была
5-минутная пауза, таким образом, выход из строя
сервера прозрачен для клиента. </small></p>

<p><small><a NAME="t296011"></a>Чтобы оценить
продолжительность тайм-аутов при повторных
передачах в этом примере, представьте, что
существуют два демона клиента, каждый со своими
собственными тайм-аутами. Интервалы для первого
демона (читающего со смещения 65536) примерно
следующие (округлено до двух знаков после
запятой): 0,68; 0,87; 1,74; 3,48; 6,96; 13,92; 20,0; 20,0; 20,0 и так
далее. Интервалы для второго демона (читающего со
смещения 73728) точно такие же. Это означает, что эти
NFS клиенты используют тайм-ауты, которые кратны
0,875 секунды с верхним пределом равным 20 секундам.
После каждого тайм-аута интервал повторной
передачи удваивается: 0,875; 1,75; 3,5; 7,0 и 14,0. </small></p>

<p><small>Сколько времени клиент будет осуществлять
повторные передачи? Клиент имеет две опции,
которые могут повлиять на это. Во-первых, если
файловая система сервера смонтирована <a NAME="t296012"></a>жестко
(hard) , клиент будет повторно передавать вечно,
однако если файловая система сервера
смонтирована <a NAME="t296013"></a>мягко (soft) , клиент
прекратит свои попытки после фиксированного
количества повторных передач. Также, в случае
жесткого монтирования клиент имеет опцию,
позволяющую пользователю прервать неудачные
повторные передачи или не прерывать. Если при
монтировании файловой системы сервера, хост
клиента указывает что прервать можно, и если мы
не хотим ждать 5 минут, пока сервер
перезагрузится после выхода из строя, мы можем
ввести символ прерывания, чтобы прекратить
работу приложения клиента.</small></p>
<i><b>

<p><a NAME="t296014"></a>Несколько одинаковых процедур</p>
</b></i>

<p><small>RPC процедуры могут быть исполнены сервером
несколько раз, но при этом все равно возвращают
тот же самый результат. Например, процедура
чтения NFS. Как мы видели на рисунке 29.9, клиент
просто повторно выдает вызов READ до тех пор, пока
он получает отклик. В нашем примере причина
повторной передачи была в том, что сервер вышел
из строя. Если сервер не вышел из строя, а
сообщения, содержащие RPC отклики, были потеряны
(так как UDP ненадежный протокол), клиент просто
повторно передает, и сервер снова осуществляет
то же самое чтение (READ). Та же самая часть того же
самого файла считывается снова и посылается
клиенту. </small></p>

<p><small>Это работает, потому что каждый запрос на
чтение READ содержит начальное смещение. Если бы NFS
процедура попросила сервер считать следующие N
байт файла, это бы не сработало. Если бы сервер не
был безразличным (это значение наоборот к
безразличности), и отклик потерян, а клиент
повторно выдает READ для следующих N байт,
результат будет отличаться. Именно поэтому
процедуры NFS READ и WRITE имеют начальное смещение.
Именно клиент поддерживает состояние (текущее
смещение для каждого файла), а не сервер. </small></p>

<p><small>К несчастью, не все операции с файловыми
системами можно исполнить несколько раз.
Например, представьте себе следующие шаги:
клиент NFS выдает запрос REMOVE, чтобы удалить файл; NFS
сервер удаляет файл и отвечает OK; отклик сервера
потерян; NFS клиент отрабатывает тайм-аут и
повторно передает запрос; NFS сервер не может
найти файл и возвращает ошибку; приложение
клиента получает ошибку, сообщающую о том, что
файл не существует. Эта ошибка возвращается
приложению клиента, и эта ошибка несет неверную
информацию - файл не существовал и был удален. </small></p>

<p><small>Ниже приведен список NFS процедур, которые
можно исполнить несколько раз: GETATTR, STATFS, LOOKUP, READ,
WRITE, READLINK и READDIR. Процедуры, которые нельзя
исполнить несколько раз: CREATE, REMOVE, RENAME, LINK, SYMLINK, MKDIR
и RMDIR. SETATTR обычно исполняется несколько раз, если
только она не была использована для того, чтобы
обрезать файл. </small></p>

<p><small>Так как в случае использования UDP всегда
могут появиться потерянные отклики, NFS сервера
должны иметь способ обработать операции, которые
нельзя исполнять несколько раз. <a NAME="t296015"></a>Большинство
серверов имеют кэш последних откликов, в котором
они хранят последние принятые отклики для
подобных операций. Каждый раз, когда сервер
получает запрос, он, во-первых, просматривает
свой кэш, и если найдено совпадение, возвращает
предыдущий отклик, вместо того чтобы вызывать NFS
процедуру снова. [<a NAME="t296016"></a>Juszczak 1989] описывает
детали этих типов кэша. </small></p>

<p><small>Подобный подход к процедурам на серверах
применяется ко всем приложениям, основанным на
UDP, а не только NFS. DNS, например, предоставляет
сервис, безболезненно используемый несколько
раз. DNS сервер может осуществить запрос
разборщика любое количество раз, что не приведет
к отрицательным результатам (может быть, кроме
того, что будут заняты сетевые ресурсы).</small></p>
<u><b>

<p><a NAME="t297000"></a>NFS версии 3</p>
</b></u>

<p><small>В течение 1994 года были выпущены
спецификации для версии 3 протокола NFS [<a NAME="t297001"></a>Sun
Microsystems 1993]. Реализации, как ожидается, станут
доступными в течение 1994 года. </small></p>

<p><small>Здесь вкратце описаны основные различия
между версиями 2 и 3. Мы будем называть их V2 и V3.</small></p>

<p><small>&nbsp;</small> 

<ol>
  <li><small>Описатели файлов в V2 это массив
    фиксированного размера - 32 байта. В V3 это массив
    переменного размера с размером до 64 байт. Массив
    переменной длины в XDR определяется 4-байтным
    счетчиком, за которым следуют реальные байты. Это
    уменьшает размер описателя файла в таких
    реализациях, как, например, Unix, где требуется
    всего около 12 байт, однако позволяет не-Unix
    реализациям обмениваться дополнительной
    информацией.</small></li>
  <li><small>V2 ограничивает количество байт на процедуры
    READ или WRITE RPC размером 8192 байта. Это ограничение не
    действует в V3, что, в свою очередь, означает, что с
    использованием UDP ограничение будет только в
    размере IP датаграммы (65535 байт). Это позволяет
    использовать большие пакеты при чтении и записи
    в быстрых сетях.</small></li>
  <li><small>Размеры файлов и начальное смещение байтов
    для процедур READ и WRITE расширены с 32 до 64 бит, что
    позволяет работать с файлами большего размера.</small></li>
  <li><small>Атрибуты файла возвращаются в каждом
    вызове, который может повлиять на атрибуты. Это
    уменьшает количество вызовов GETATTR, требуемых
    клиентом.</small></li>
  <li><small>Записи (WRITE) могут быть <a NAME="t297002"></a>асинхронными,
    тогда как в V2 они должны были быть <a NAME="t297003"></a>синхронными.
    Это может улучшить производительность процедуры
    WRITE.</small></li>
  <li><small>Одна процедура была удалена (STATFS) и семь были
    добавлены: ACCESS (проверка прав доступа к файлу), MKNOD
    (создание специального файла Unix), READDIRPLUS
    (возвращает имена файлов в директории вместе с их
    атрибутами), FSINFO (возвращает статистическую
    информацию о файловой системе), FSSTAT (возвращает
    динамическую информацию о файловой системе),
    PATHCONF (возвращает <a NAME="t297004"></a>POSIX.1 информацию о
    файле) и COMMIT (передает ранее сделанные
    асинхронные записи на постоянное хранение).</small></li>
</ol>

<p>&nbsp;</p>
<u><b>

<p><a NAME="t298000"></a>Краткие выводы</p>
</b></u>

<p><small>RPC это способ построить приложение
клиент-сервер таким образом, что клиент просто
вызывает процедуры на сервере. Все сетевые
детали спрятаны в stubах клиента и сервера, которые
генерируются для приложений пакетом RPC и в
подпрограммах библиотеки RPC. Мы показали формат
RPC сообщений вызова и отклика и упомянули, что XDR
используется, чтобы кодировать значения, что
позволяет RPC клиентам и серверам работать на
машинах с различной архитектурой. </small></p>

<p><small>Одно из наиболее широко используемых
приложений RPC это Sun NFS, протокол доступа к
разнородным файлам, который широко используется
на хостах практически всех размеров. Мы
рассмотрели NFS и то, как он использует UDP или TCP. В
протоколе NFS версии 2 (NFS Version 2) определено 15
процедур. </small></p>

<p><small>Доступ клиента к NFS серверу начинается с
протокола монтирования, после чего клиенту
возвращается описатель файла. Затем клиент может
получить доступ к файлам в файловой системе
сервера с использованием этого описателя файла.
Имена файлов просматриваются на сервере по
одному элементу имени за раз, при этом для
каждого элемента возвращается новый описатель
файла. Конечный результат это описатель того
файла, к которому было осуществлено обращение, и
который используется при последовательных
чтениях и записях. </small></p>

<p><small>NFS старается сделать все свои процедуры
независимыми от количества исполнений таким
образом, чтобы клиент мог просто повторно выдать
запрос, если отклик был потерян. Мы видели
примеры этого: в случае, когда клиент читал файл,
пока сервер вышел из строя и перезагружался.</small>&nbsp;</p>
<i><b>

<p>Упражнения</b></i> 

<ol>
  <li>На рисунке 29.7 мы видели, что tcpdump
    интерпретирует пакеты как NFS запросы и отклики, и
    при этом печатает <a NAME="t298001"></a>XID. Может ли tcpdump
    сделать это для любых RPC запросов или откликов?</li>
  <li>Как Вы думаете, почему в Unix системах программа RPC
    сервера использует динамически назначаемые
    порты, а не заранее известные?</li>
  <li>RPC клиент вызвал две процедуры сервера. Первая
    процедура потребовалось на исполнение 5 секунд, а
    второй - 1 секунда. Клиент имеет тайм-аут равный 4
    секундам. Нарисуйте временную диаграмму того,
    чем обмениваются клиент и сервер. (Представьте,
    что на прохождение сообщения от клиента к
    серверу и наоборот время не тратится.)</li>
  <li>Что произойдет в примере на рисунке 29.9, если
    пока NFS сервер был выключен, его Ethernet плата была
    удалена?</li>
  <li>Когда сервер перезагрузился на рисунке 29.9, он
    обрабатывал запрос, начинающийся на смещении 65536
    (строки 168 и 171), а затем обрабатывал следующий
    запрос, начинающийся со смещения 66560 (строки 172 и
    173). Что произойдет с запросом, начинающимся со
    смещением 73728 (строка 167)?</li>
  <li>Когда мы описывали независимые от количества
    исполнений NFS процедуры, то показали пример
    отклика REMOVE, который потерялся в сети. Что
    произойдет в этом случае, если используется TCP
    вместо UDP?</li>
  <li>Если NFS сервер использует динамически
    назначаемый порт вместо порта 2049, что произойдет
    с NFS клиентом, когда сервер выйдет из строя и
    перезагрузится?</li>
  <li><a NAME="t298002"></a>Номеров зарезервированных портов
    (глава 1, раздел <a HREF="tcp01.html#t019000">&quot;Номера
    портов&quot;</a>) очень-очень мало, их максимум 1023 на
    хост. Если NFS сервер требует, чтобы его клиенты
    имели зарезервированные порты (что обычно так и
    есть), и NFS клиент, использующий TCP, монтирует N
    файловых систем на N различных серверах,
    необходимо ли клиенту иметь различные
    зарезервированные номера портов для каждого
    соединения?</li>
</ol>

<hr>

</body>
</html>

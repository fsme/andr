<html>

<head>
<title>UDP: User Datagram Protocol</title>

<meta http-equiv="Content-type" content="text/html; charset=koi8-r">
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>




<p><a NAME="t110000"></a>Глава 11 UDP: User Datagram Protocol</p>
<u>

<p><b><a NAME="t111000"></a>Введение</p>
</b></u>

<p><small><a NAME="t111001"></a>UDP простой, ориентированный на
передачу датаграмм, протокол транспортного
уровня: за один раз процесс выдает одну UDP
датаграмму, в результате чего передается одна IP
датаграмма. Это отличается от
поток-ориентированных протоколов, таких как TCP,
где количество данных, которое выдается
приложением, практически не имеет отношения к
количеству отправленных IP датаграмм. </small></p>

<p><small>На рисунке 11.1 показана инкапсуляция UDP
датаграммы в IP датаграмму.<a NAME="t111002"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t11_1000.jpg" WIDTH="316" HEIGHT="105"></small></p>


<p ALIGN="CENTER"><small>Рисунок 11.1 UDP инкапсуляция.</small></p>

<p>&nbsp;</p>

<p><small>Официальная спецификация UDP приведена в RFC
768 [<a NAME="t111003"></a>Postel 1980]. </small></p>

<p><small>UDP является ненадежным протоколом: он
отправляет датаграммы, которые приложение пишет
в IP уровень, однако не существует гарантии того,
что они достигнут конечного пункта назначения. С
точки зрения надежности может возникнуть
предположение, что стоит избегать использовать
UDP и всегда пользоваться надежными протоколами,
такими как TCP. После того как TCP будет описан в <a HREF="tcp17.html">главе 17</a>, мы вернемся к этой теме и
посмотрим, какие типы приложений могут
использовать UDP. </small></p>

<p><small>Приложениям нет необходимости
беспокоиться о размере получившейся в
результате IP датаграммы. Если она по размеру
больше, чем MTU для данной сети (см. главу 2, раздел <a HREF="tcp02.html#t028000">&quot;MTU&quot;</a>), IP датаграмма будет
фрагментирована. Это применимо к каждой сети,
через которую пройдет датаграмма по пути от
источника до пункта назначения, кроме первой
сети, к которой подключен посылающий хост. (Мы
определили понятие транспортного MTU в разделе <a HREF="tcp02.html#t029000">&quot;Транспортный MTU&quot;</a> главы 2.)
Более подробно IP фрагментация будет рассмотрена
в разделе <a HREF="#t115000">&quot;Фрагментация IP&quot;</a> этой
главы.</small></p>
<u><b>

<p><a NAME="t112000"></a>UDP заголовок </p>
</b></u>

<p><small>На рисунке 11.2 показаны поля, присутствующие
в UDP заголовке.<a NAME="t112001"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t11_2000.jpg" WIDTH="528" HEIGHT="179"></small></p>


<p ALIGN="CENTER"><small>Рисунок 11.2 UDP заголовок.</small></p>

<p>&nbsp;</p>

<p><small><a NAME="t112002"></a>Номера портов (port numbers)
указывают на отправляющий и принимающий
процессы. На <a HREF="tcp01.html#t017001">рисунке 1.8</a>
показано, что TCP и UDP используют номер порта
назначения для демультиплексирования данных,
поступающих от IP. Так как IP осуществляет
демультиплексирование входящих IP датаграмм для
TCP и UDP (с использованием значения протокола в IP
заголовке), TCP просматривает номера портов TCP, а UDP
- номера портов UDP. Номера портов TCP независимы от
номеров портов UDP. </small></p>

<p>&nbsp;</p>


<p>Несмотря на подобную
независимость, если зарезервированный сервис
предоставляется обоими TCP и UDP, обычно выбирается
один и тот же номер порта для обоих транспортных
уровней. Это сделано для удобства, а не по
требованию протоколов.</p>


<p>&nbsp;</p>

<p><small><a NAME="t112003"></a>Поле длины UDP содержит длину в
байтах UDP заголовка и UDP данных. Минимальное
значение для этого поля составляет 8 байт. (Не
произойдет ничего страшного, если будет
отправлена UDP датаграмма с нулевой длиной
данных.) Параметр UDP длины - избыточный. IP
датаграмма содержит свою полную длину в байтах,
поэтому длина UDP датаграммы это <a NAME="t112004"></a>полная
длина минус длина IP заголовка (которая указана в
поле длины заголовка на <a HREF="tcp03.html#t032001">рисунке
3.1</a>).</small></p>
<u><b>

<p><a NAME="t113000"></a>Контрольная сумма UDP</p>
</b></u>

<p><small><a NAME="t113001"></a>Контрольная сумма UDP охватывает
UDP заголовок и UDP данные. Вспомним, что
контрольная сумма в IP заголовке охватывает
только IP заголовок - она не охватывает данные,
находящиеся в IP датаграмме. И UDP, и TCP содержат
контрольные суммы в своих заголовках, которые
охватывают как заголовок, так и данные. Для UDP
контрольная сумма необязательна, но для TCP она
обязательна. </small></p>

<p><small>Контрольная сумма UDP рассчитывается точно
так же, как (глава 3, раздел <a HREF="tcp03.html#t032000">&quot;IP
заголовок&quot;</a>) контрольная сумма IP заголовка
(сумма 16-битных слов с переполнением), хотя
существуют и отличия. Во-первых, UDP датаграмма
может состоять из нечетного количества байт,
тогда как при расчете контрольной суммы
складываются 16-битные слова. При этом в конец
датаграммы добавляются нулевые байты
заполнения, если это необходимо для расчета
контрольной суммы. (Байты заполнения не
передаются.) </small></p>

<p><small>В UDP и TCP существуют 12-байтовые <a NAME="t113002"></a>псевдозаголовки
(в UDP датаграммах и TCP сегментах) только для
расчета контрольной суммы. Псевдозаголовки
содержат в себе определенные поля из IP заголовка.
Все это сделано для двойной проверки того, что
данные достигли того пункта назначения, которому
предназначались (IP не принимает датаграммы,
которые не адресованы для данного хоста, и не
сможет передать UDP датаграммы, предназначенные
для другого верхнего уровня). На рисунке 11.3
показан <a NAME="t113003"></a>псевдозаголовок и UDP
датаграмма.<a NAME="t113004"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t11_3000.jpg" WIDTH="533" HEIGHT="326"></small></p>


<p ALIGN="CENTER"><small>Рисунок 11.3 Поля, используемые для
расчета контрольной суммы UDP.</small></p>

<p>&nbsp;</p>

<p><small>На этом рисунке мы специально показали
датаграмму с нечетной длиной, в этом случае
требуется дополнительный байт для расчета
контрольной суммы. Обратите внимание на то, что
длина UDP датаграммы, при расчете контрольной
суммы, появляется дважды. </small></p>

<p><small>Если рассчитанная контрольная сумма равна
0, она хранится как все единичные биты (65535), эти
значения эквивалентны в арифметике с
поразрядным дополнением (дополнение единицы)
(ones-complement). Если переданная контрольная сумма
равна 0, это означает, что отправитель не
рассчитал контрольную сумму. </small></p>

<p><small>Если отправитель все же рассчитал
контрольную сумму, а получатель определил
наличие ошибки, UDP датаграмма молча уничтожается,
сообщение об ошибке не генерируется. (То же самое
происходит, если IP уровень обнаружил ошибку в
контрольной сумме IP заголовка.) </small></p>

<p><small><a NAME="t113005"></a>Контрольная сумма UDP
рассчитывается отправителем и проверяется
получателем. Она позволяет определить любые
изменения в UDP заголовке или данных, которые
произошли на пути между отправителем и
получателем. </small></p>

<p><small>Несмотря на то, что для контрольная сумма UDP
- необязательный параметр, она должна
рассчитываться всегда. В конце 1980-х годов
некоторые производители компьютеров стали по
умолчанию отключать расчет контрольной суммы UDP,
чтобы увеличить скорость работы сетевой
файловой системы (NFS - Network File System), которая
использует UDP. Это может быть допустимым в одной
локальной сети, где рассчитывается циклический
избыточный код для фреймов на канальном уровне
(фреймы Ethernet или Token ring), с помощью которого можно
определить повреждение фрейма, когда датаграмма
проходит через маршрутизаторы. Поверите Вы или
нет, но существуют маршрутизаторы, у которых есть
ошибки в программном или аппаратном обеспечении
и которые изменяют биты в датаграммах, которые
они маршрутизируют. Эти ошибки не могут быть
выявлены в UDP датаграммах, если отключена опция
контрольной суммы. Также необходимо отметить,
что некоторые протоколы канального уровня
(например, SLIP) не имеют каких-либо форм расчета
контрольной суммы для данных в канале.</small></p>

<p>&nbsp;</p>


<p>Требования к хостам <a NAME="t113006"></a>Host Requirements RFC требуют, чтобы расчет
контрольной суммы UDP был включен по умолчанию.
Также они требуют, чтобы принятая контрольная
сумма обязательно проверялась, если ее рассчитал
отправитель (в том случае, если принятая
контрольная сумма не нулевая). Некоторые
реализации игнорируют это и проверяют принятую
контрольную сумму в том случае, если включена
опция расчета исходящей контрольной суммы.</p>


<p>&nbsp;</p>
<i><b>

<p>Вывод команды tcpdump</p>
</b></i>

<p><small>Довольно сложно определить, включена ли
опция расчета <a NAME="t113007"></a>контрольной суммы UDP на
конкретной системе. Обычно приложение не имеет
доступа к полю контрольной суммы принятого UDP
заголовка. Чтобы решить эту проблему, автор
добавил еще одну опцию к программе <a NAME="t113008"></a>tcpdump,
после чего та стала выдавать полученные
контрольные суммы UDP. Если полученное значение
равно 0, это означает, что отправитель не
рассчитал контрольную сумму. </small></p>

<p><small>На рисунке 11.4 показан вывод к трем системам
и от тех же трех различных систем в нашей сети. Мы
запустили программу <a NAME="t113009"></a>sock (<a HREF="tcp_c.html">приложение
С</a>), послав единственную UDP датаграмму с 9
байтами данных на стандартный эхо сервер.<a NAME="t113010"></a></small></p>

<p>&nbsp;</p>


<p>1&nbsp;&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.1900
&gt; gemini.echo: udp 9 (UDP cksum=6e90)<br>
2&nbsp;&nbsp; 0.303755 ( 0.3038)&nbsp;&nbsp;&nbsp;&nbsp; gemini.echo &gt; sun.1900: udp 9
(UDP cksum=0)<br>
<br>
3&nbsp; 17.392480 (17.0887)&nbsp;&nbsp;&nbsp;&nbsp; sun.1904 &gt; aix.echo: udp 9 (UDP
cksum=6e3b)<br>
4&nbsp; 17.614371 ( 0.2219)&nbsp;&nbsp;&nbsp;&nbsp; aix.echo &gt; sun.1904: udp 9 (UDP
cksum=6e3b)<br>
<br>
5&nbsp; 32.092454 (14.4781)&nbsp;&nbsp;&nbsp;&nbsp; sun.1907 &gt; solaris.echo: udp 9 (UDP
cksum=6e74)<br>
6&nbsp; 32.314378 ( 0.2219)&nbsp;&nbsp;&nbsp;&nbsp; solaris.echo &gt; sun.1907: udp 9 (UDP
cksum=6e74)<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 11.4 Вывод tcpdump, с помощью которого
можно определить, включена ли опция контрольной
суммы UDP на конкретном хосте.</small></p>

<p>&nbsp;</p>

<p><small>Отсюда мы видим, что у двух из трех систем
опция контрольной суммы UDP включена. </small></p>

<p><small>Также обратите внимание на то, что
исходящая датаграмма имеет такую же контрольную
сумму, как и входящая датаграмма (строки 3 и 4, 5 и 6).
На рисунке&nbsp;11.3, можно заметить, что два IP адреса
поменяны местами, так же, как и два номера порта.
Другие поля в псевдозаголовке и заголовке UDP
остались те же, так как данные были отражены эхом.
Это подтверждает, что контрольная сумма UDP (а в
действительности, и все контрольные суммы в
семействе протоколов TCP/IP) это простая 16-битовая
сумма. С ее помощью невозможно определить ошибку,
которая заключается в перемене мест двух
16-битных значений.</small></p>

<p>&nbsp;</p>


<p>Автор также направил DNS
запрос на каждый из восьми корневых серверов DNS,
описанных в разделе <a HREF="tcp14.html#t142000">&quot;Основы
DNS&quot;</a> главы 14. DNS использует UDP, и только на двух
из восьми была включена опция расчета
контрольной суммы UDP!</p>


<p>&nbsp;</p>
<i><b>

<p>Немного статистики</p>
</b></i>

<p><small>[<a NAME="t113011"></a>Mogul 1992] предоставляет некоторую
статистическую информацию о появлении <a NAME="t113012"></a>ошибок
контрольных сумм на довольно загруженном NFS
сервере, который работал в течение 40 дней. На
рисунке 11.5 приведены статистические данные.<a NAME="t113013"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="616">
  <tr>
    <td WIDTH="17%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Уровень</small></td>
    <td WIDTH="42%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Количество
    ошибок в контрольных суммах</small></td>
    <td WIDTH="41%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Приблизительное
    количество пакетов</small></td>
  </tr>
  <tr>
    <td WIDTH="17%" VALIGN="TOP"><small>Ethernet</small></td>
    <td WIDTH="42%" VALIGN="TOP"><p ALIGN="CENTER"><small>446</small></td>
    <td WIDTH="41%" VALIGN="TOP"><p ALIGN="CENTER"><small>170.000.000</small></td>
  </tr>
  <tr>
    <td WIDTH="17%" VALIGN="TOP"><small>IP</small></td>
    <td WIDTH="42%" VALIGN="TOP"><p ALIGN="CENTER"><small>14</small></td>
    <td WIDTH="41%" VALIGN="TOP"><p ALIGN="CENTER"><small>170.000.000</small></td>
  </tr>
  <tr>
    <td WIDTH="17%" VALIGN="TOP"><small>UDP</small></td>
    <td WIDTH="42%" VALIGN="TOP"><p ALIGN="CENTER"><small>5</small></td>
    <td WIDTH="41%" VALIGN="TOP"><p ALIGN="CENTER"><small>140.000.000</small></td>
  </tr>
  <tr>
    <td WIDTH="17%" VALIGN="TOP"><small>TCP</small></td>
    <td WIDTH="42%" VALIGN="TOP"><p ALIGN="CENTER"><small>350</small></td>
    <td WIDTH="41%" VALIGN="TOP"><p ALIGN="CENTER"><small>30.000.000</small></td>
  </tr>
</table>


<p><small>Рисунок 11.5 Статистика поврежденных
пакетов, определенных с использованием
контрольных сумм. </small></p>

<p>&nbsp;</p>

<p><small>В последней колонке приведено
приблизительное количество пакетов, так как и
другие протоколы используют Ethernet и IP уровень.
Например, не все Ethernet фреймы используются IP
датаграммами, ARP также использует Ethernet. Не все IP
датаграммы используются UDP или TCP, так как ICMP
также использует IP. </small></p>

<p><small>Обратите внимание на то, что выявлено
значительно больше ошибок <a NAME="t113014"></a>контрольных
сумм TCP, чем UDP. Это скорее всего вызвано тем, что с
помощью TCP обычно устанавливаются &quot;дальние&quot;
соединения (которые проходят через много
маршрутизаторов, мостов и так далее), тогда как UDP
траффик обычно локальный. </small></p>

<p><small>Поэтому ошибки, приведенные в нижней
строке, не всегда имеют отношение к канальному
уровню (Ethernet, Token ring). При передаче данных следует
всегда включать опцию <a NAME="t113015"></a>контрольную
сумму в оконечных точках. Однако, если
передаваемые данные представляют определенную
ценность, не стоит полностью доверять <a NAME="t113016"></a>контрольным
суммам UDP или TCP, так как это простые контрольные
суммы, и они не гарантируют, что защитят данные от
всех возможных ошибок. </small></p>
<u><b>

<p><a NAME="t114000"></a>Простой пример</p>
</b></u>

<p><small>Мы воспользуемся программой sock, чтобы
сгенерировать несколько UDP датаграмм, которые мы
просмотрим с использованием <a NAME="t114001"></a>tcpdump: </small></p>

<p>&nbsp;</p>


<p>bsdi % <b>sock -v -u -i -n4 svr4 discard<br>
</b>connected on 140.252.13.35.1108 to 140.252.13.34.9<br>
<br>
bsdi % <b>sock -v -u -i -n4 -w0 svr4 discard<br>
</b>connected on 140.252.13.35.1110 to 140.252.13.34.9&nbsp;</p>

<p>&nbsp;</p>

<p><small>В первом случае запуска программы
установлен отладочный режим (<a NAME="t114002"></a>-v), при
этом можно просмотреть номера динамически
назначаемых портов, указан UDP (<a NAME="t114003"></a>-u)
вместо TCP по умолчанию и установлен режим
источника, опция (<a NAME="t114004"></a>-i) , это означает,
что мы будем посылать данные, а не будем читать из
стандартного ввода или писать в стандартный
вывод. Опция <a NAME="t114005"></a>-n4 сообщает о
необходимости выдать 4 датаграммы (вместо того,
чтобы выдавать по умолчанию 1024) на хост
назначения svr4. Сервис discard описан в разделе <a HREF="tcp01.html#t01C000">&quot;Стандартные простые сервисы&quot;</a>
главы 1. Мы используем размер вывода по умолчанию
в 1024 байта на одну запись. </small></p>

<p><small>Второй раз мы запустили программу, указав <a NAME="t114006"></a>-w0, при этом будут выдаваться
датаграммы нулевой длины. На рисунке 11.6 показан
вывод команды tcpdump для двух примеров.<a NAME="t114007"></a></small></p>

<p>&nbsp;</p>


<p>1&nbsp;&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1108
&gt; svr4.discard: udp 1024<br>
2&nbsp;&nbsp; 0.002424 ( 0.0024)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1108 &gt; svr4.discard: udp
1024<br>
3&nbsp;&nbsp; 0.006210 ( 0.0038)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1108 &gt; svr4.discard: udp
1024<br>
4&nbsp;&nbsp; 0.010276 ( 0.0041)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1108 &gt; svr4.discard: udp
1024<br>
<br>
5&nbsp; 41.720114 (41.7098)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1110 &gt; svr4.discard: udp 0<br>
6&nbsp; 41.721072 ( 0.0010)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1110 &gt; svr4.discard: udp 0<br>
7&nbsp; 41.722094 ( 0.0010)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1110 &gt; svr4.discard: udp 0<br>
8&nbsp; 41.723070 ( 0.0010)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1110 &gt; svr4.discard: udp 0<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 11.6 Вывод команды tcpdump для случая,
когда UDP датаграммы посылаются в одном
направлении.</small></p>

<p>&nbsp;</p>

<p><small>В выводе показаны четыре датаграммы
размером 1024 байта, за которыми следуют четыре
датаграммы нулевой длинны. Каждая датаграмма
следует за предыдущей с интервалом в несколько
миллисекунд. (Для того чтобы ввести вторую
команду, потребовалась 41 секунда.) </small></p>

<p><small>До того как была отправлена первая
датаграмма, соединения между отправителем и
получателем не существовало. (В <a HREF="tcp17.html">главе
17</a>, где рассказывается о TCP, мы покажем, что перед
тем как будет отправлен первый байт данных,
должно быть установлено соединение.) Необходимо
отметить, что получатель не выдает
подтверждение, когда получает данные.
Отправитель, в этом примере, не имеет
представления о том, получены ли данные на
удаленном конце. </small></p>

<p><small>И в завершение, обратите внимание, что номер
порта источника UDP меняется каждый раз при
запуске программы. Сначала порт был 1108, затем 1110.
В разделе <a HREF="tcp01.html#t019000">&quot;Номера портов&quot;</a>
главы 1 мы показали, что номера динамически
назначаемых портов, используемых клиентами,
обычно находятся в диапазоне от 1024 до 5000.</small></p>
<u><b>

<p><a NAME="t115000"></a>Фрагментация IP</p>
</b></u>

<p><small>Как мы указали в разделе <a HREF="tcp02.html#t028000">&quot;MTU&quot;</a>
главы 2, физический сетевой уровень обычно имеет
ограничение максимального размера фрейма,
который может быть передан. Когда IP уровень
получает IP датаграмму, которую необходимо
отправить, он определяет, на какой локальнй
интерфейс отправляется датаграмма (или
маршрутизируется), и запрашивает интерфейс,
чтобы тот сообщил размер своего MTU. IP сравнивает
MTU с размером датаграммы и, если необходимо,
осуществляет фрагментацию. Фрагментация может
быть осуществлена как на отправляющем хосте, так
и на промежуточном маршрутизаторе. </small></p>

<p><small>Когда IP датаграмма фрагментирована, она не
собирается вновь до тех пор, пока не достигнет
конечного пункта назначения. (Для некоторых
других сетевых протоколов процесс повторной
сборки отличается от описанного выше, при этом <a NAME="t115001"></a>повторная сборка осуществляется на
маршрутизаторе следующей пересылки, а не в
конечном пункте назначения.) На уровне IP сборка
осуществляется в конечном пункте назначения. Это
сделано для того, чтобы сделать фрагментацию и
повторную сборку прозрачной для транспортных
уровней (TCP и UDP), хотя это может вести к некоторой
потере производительности. Существует
вероятность, что фрагмент датаграммы будет снова
фрагментирован (возможно даже несколько раз).
Информации, которая содержится в IP заголовке
вполне достаточно для фрагментации и повторной
сборки. </small></p>

<p><small>Вернемся снова к IP заголовку (см. <a HREF="tcp03.html#t032001">рисунок 3.1</a>) и рассмотрим, какие
поля используются в процессе фрагментации. <a NAME="t115002"></a>Поле идентификации содержит значение
уникальное для каждой отправленной IP датаграммы.
Это значение копируется в каждый фрагмент
конкретной датаграммы. В поле флагов один бит
означает, что &quot;дальше следуют еще фрагменты&quot;
(more fragments). Этот бит устанавливается в единицу для
каждого фрагмента, кроме последнего. <a NAME="t115003"></a>Поле
смещения фрагмента (fragment offset) содержит смещение
этого фрагмента от начала исходной датаграммы.
Когда датаграмма фрагментируется, <a NAME="t115004"></a>поле
полной длины каждого фрагмента изменяется, так
чтобы соответствовать размеру фрагмента. </small></p>

<p><small>И в заключение, один из битов в поле флагов
называется <a NAME="t115005"></a>&quot;не фрагментировать&quot;
(don't fragment). Если этот бит установлен в единицу, IP не
будет фрагментировать датаграмму. Вместо этого
датаграмма уничтожается, а отправителю
посылается ICMP ошибка <a NAME="t115006"></a>&quot;фрагментация
необходима, однако установлен бит не
фрагментировать&quot; (fragmentation needed but don't fragment bit set).
Мы рассмотрим эту ошибку более подробно в
следующем разделе. </small></p>

<p><small>Когда IP датаграмма фрагментируется, каждый
фрагмент становится пакетом, с собственным IP
заголовком, и маршрутизируется независимо от
других пакетов. Поэтому становится возможным,
что датаграммы прибудет в конечный пункт
назначения в другом порядке, нежели они были
исходно отправлены и фрагментированы. Однако, в IP
заголовке хранится достаточно информации для
того, чтобы датаграмма была собрана корректно. </small></p>

<p><small>Несмотря на то, что процесс фрагментации IP
выглядит довольно прозрачным, существует одна
особенность, которая делает его не всегда
желательным: если один фрагмент потерялся,
датаграмма должна быть целиком <a NAME="t115007"></a>повторно
передана. Это объясняется тем, что IP не имеет
тайм-аутов и не осуществляет повторной передачи -
за это несут ответственность верхние уровни. (TCP
осуществляет тайм-аут и повторную передачу, UDP -
нет. Некоторые UDP приложения осуществляют
тайм-аут и повторную передачу самостоятельно.)
Когда потерялся фрагмент из TCP сегмента, TCP
отработает тайм-аут и повторно передаст TCP
сегмент целиком (IP датаграмма). Не существует
способа повторно передать только один фрагмент
датаграммы. И действительно, если фрагментация
была осуществлена промежуточным
маршрутизатором, а не отправляющей системой,
отправляющая система не сможет знать как
датаграмма была фрагментирована в процессе
передачи. Именно по этой причине (всего одной)
фрагментации стараются избежать. <a NAME="t115008"></a>[Kent
and Mogul 1987] приводят аргументы, которые доказывают
необходимость избегать фрагментации. </small></p>

<p><small>С использованием UDP довольно легко добиться
IP фрагментации. (Позже мы увидим, что TCP старается
избежать фрагментации, и для приложения
практически невозможно заставить TCP отправлять
сегменты, которые нуждаются в фрагментации. То
есть, другими словами, отправить сегмент такого
размера, для которого потребуется фрагментация,
практически невозможно.) Мы воспользуемся
программой <a NAME="t115009"></a>sock, чтобы увеличить
размер датаграммы, с таким расчетом, чтобы была
осуществлена фрагментация. Максимальный размер
данных во фрейме Ethernet составляет 1500 байт (<a HREF="tcp02.html#t022001">рисунок 2.1</a>), при этом 1472 байта
предназначены для пользовательских данных, 20
байт отводится под IP заголовок и 8 байт под UDP
заголовок. Запустим программу sock с размером
данных 1471, 1472, 1473 и 1474 байта. Мы ожидаем, что в двух
последних случаях произойдет фрагментация:</small></p>

<p>&nbsp;</p>


<p>bsdi % <b>sock -u -i -n1 -w1471 svr4 discard<br>
</b>bsdi % <b>sock -u -i -n1 -w1472 svr4 discard<br>
</b>bsdi % <b>sock -u -i -n1 -w1473 svr4 discard<br>
</b>bsdi % <b>sock -u -i -n1 -w1474 svr4 discard</b>&nbsp;</p>

<p>&nbsp;</p>

<p><small>На рисунке 11.7 показан соответствующий
вывод команды <a NAME="t115010"></a>tcpdump.<a NAME="t115011"></a></small></p>

<p>&nbsp;</p>


<p>1&nbsp;&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1112
&gt; svr4.discard: udp 1471<br>
2&nbsp; 21.008303 (21.0083)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1114 &gt;
svr4.discard: udp 1472<br>
<br>
3&nbsp; 50.449704 (29.4414)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1116 &gt;
svr4.discard: udp 1473 (frag 26304:1480@0+)<br>
4&nbsp; 50.450040 ( 0.0003)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi &gt; svr4:
(frag 26304:1@1480)<br>
<br>
5&nbsp; 75.328650 (24.8786)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1118 &gt;
svr4.discard: udp 1474 (frag 26313:1480@0+)<br>
6&nbsp; 75.328982 ( 0.0003)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi &gt; svr4:
(frag 26313:2@1480)<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 11.7 Наблюдения за фрагментацией UDP
датаграмм.</small></p>

<p>&nbsp;</p>

<p><small>Первые две UDP датаграммы (строки 1 и 2)
помещаются в Ethernet фреймы и не фрагментируются.
Однако, длина IP датаграммы, в которую необходимо
записать 1473 байта данных, составляет 1501 байт,
поэтому она должна быть фрагментирована (строка 3
и 4). Точно так же, длина датаграммы, в которую
необходимо записать 1474 байта данных, будет
составлять 1502 байта, и она также должна быть
фрагментирована (строки 5 и 6). </small></p>

<p><small>Когда IP датаграмма фрагментирована, tcpdump
выводит дополнительную информацию. Во-первых,
выводится флаг frag 26304 (строки 3 и 4) и флаг frag 26313
(строки 5 и 6), который указывает на значение поля
идентификации в IP заголовке. </small></p>

<p><small>Число 1480 в строке 3 (между двоеточием и
символом @), это размер, за исключением IP
заголовка. Первые фрагменты обеих датаграмм
содержит 1480 байт данных: 8 байт UDP заголовока и 1472
байта пользовательских данных. (Если добавить 20
байт IP заголовка, получится точно размер пакета -
1500 байт.) Второй фрагмент первой датаграммы
(строка 4) содержит 1 байт данных - оставшийся байт
пользовательских данных. Второй фрагмент второй
датаграммы (строка 6) содержит 2 оставшихся байта
пользовательских данных. </small></p>

<p><small>При фрагментации требуется, чтобы порция
данных генерируемых фрагментов (за исключением IP
заголовока) была кратна 8 байтам для всех
фрагментов за исключением последнего. В этом
примере, число 1480 кратно восьми. </small></p>

<p><small>Число, следующее за символом @, это смещение
данных во фрагменте от начала датаграммы. Первый
фрагмент обеих датаграмм начинается с нуля
(строки 3 и 5), а второй фрагмент обеих датаграмм
начинается со смещения в 1480 байт (строки 4 и 6).
Символ плюс, который следует за смещением и
напечатан для первых фрагментов обеих датаграмм,
означает, что в данной датаграмме присутствуют
еще фрагменты. Знак плюс соответствует биту
&quot;дальше следуют еще фрагменты&quot; (more fragments) в
3-битовом поле флагов IP заголовка. Назначение
этого бита заключается в том, чтобы сообщить
принимающему о том, что сборка всех фрагментов
датаграммы полностью завершена. </small></p>

<p><small>И в завершение, обратите внимание на то, что
в строках 4 и 6 (не первые фрагменты) не указан
протокол (UDP), а также порты источника и
назначения. Протокол должен быть напечатан, так
как он находится в IP заголовке, который
копируется в каждый фрагмент. А номера портов
находятся в UDP заголовке, который присутствует
только в первом фрагменте. На рисунке 11.8
показано, что произойдет с третьей датаграммой
(которая содержит 1473 байта пользовательских
данных). Здесь мы видим подтверждение того, что
заголовок любого транспортного уровня
присутствует только в первом фрагменте. </small></p>

<p><small>Хочется обратить внимание на терминологию: <a NAME="t115012"></a>IP датаграмма (IP datagram) это блок, который
передается от одного конца IP уровня к другому
концу IP уровня (перед фрагментацией и после
повторной сборки), тогда как <a NAME="t115013"></a>пакет
(packet) это блок данных, который передается между IP
уровнем и канальным уровнем. Пакет может быть
полной IP датаграммой или всего лишь фрагментом IP
датаграммы.<a NAME="t115014"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t11_8000.jpg" WIDTH="531" HEIGHT="223"></small></p>


<p ALIGN="CENTER"><small>Рисунок 11.8 Пример UDP фрагментации.</small></p>
<u><b>

<p><a NAME="t116000"></a>ICMP ошибки о недоступности
(требуется фрагментация) </p>
</b></u>

<p><small>Необходимо обсудить еще одну ICMP ошибку о
недоступности. Она генерируется, когда
маршрутизатор принимает датаграмму, которую
необходимо фрагментировать, однако в IP заголовке
установлен флаг <a NAME="t116001"></a>&quot;не
фрагментировать&quot; (DF). Эта ошибка может быть
использована программой, которой необходимо
определить минимальный MTU в маршруте до пункта
назначения - что называется <a NAME="t116002"></a>механизмом
определения транспортного MTU (path MTU discovery) (глава 2,
раздел <a HREF="tcp02.html#t029000">&quot;Транспортный MTU&quot;</a>). </small></p>

<p><small>На рисунке 11.9 показан формат ICMP ошибки о
недоступности для данного случая. Он отличается
от формата, приведенного на <a HREF="tcp06.html#t065001">рисунке
6.10</a>, потому что биты 16-31 во втором 32-битном слове
могут содержать MTU следующей пересылки, вместо
того чтобы быть установленными в 0.<a NAME="t116003"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t11_9000.jpg" WIDTH="514" HEIGHT="168"></small></p>


<p ALIGN="CENTER"><small>Рисунок 11.9 ICMP ошибка о
недоступности, когда необходима фрагментация,
однако установлен бит &quot;не фрагментировать&quot;.</small></p>

<p>&nbsp;</p>

<p><small>Если маршрутизатор не поддерживает этот
новый формат ICMP ошибки, MTU следующей пересылки
устанавливается в 0. </small></p>

<p>&nbsp;</p>


<p>Новые требования к
маршрутизаторам <a NAME="t116004"></a>Router Requirements RFC [<a NAME="t116005"></a>Almquist 1993] указывают на то, что
маршрутизатор должен генерировать эту новую
форму, когда выдает ICMP сообщение о недоступности.</p>


<p>&nbsp;</p>
<i><b>

<p>Пример</p>
</b></i>

<p><small>Проблема, которую мы обсудим, возникла при
получении ICMP ошибки при попытке определить MTU SLIP
канала с дозвоном между маршрутизатором netb и
хостом sun. Мы знаем MTU этого канала от sun к netb, так
как, во-первых, это указывается при конфигурации
SLIP на хосте sun, во-вторых, мы видели MTU при запуске
команды <a NAME="t116006"></a>netstat в разделе <a HREF="tcp03.html#t039000">&quot;Команда netstat&quot;</a> главы 3. А
сейчас мы хотим определить MTU в другом
направлении. (В <a HREF="tcp25.html">главе 25</a>
рассказывается как определить MTU с
использованием SNMP.) Для каналов точка-точка нет
необходимости, чтобы MTU был одним и тем же в обоих
направлениях. </small></p>

<p><small>Для определения использована следующая
техника. Мы запустили <a NAME="t116007"></a>ping с хоста <a NAME="t116008"></a>solaris на хост bsdi, увеличивая размер
пакета данных до тех пор, пока к пакетам не была
применена фрагментация. Процесс показан на
рисунке&nbsp;11.10.<a NAME="t116009"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t11_1001.jpg" WIDTH="492" HEIGHT="167"></small></p>


<p ALIGN="CENTER"><small>Рисунок 11.10 Системы, которые были
использованы для определения MTU SLIP канала между
netb и sun.</small></p>

<p>&nbsp;</p>

<p><small>На хосте sun была запущена программа <a NAME="t116010"></a>tcpdump, которая позволила посмотреть, как
осуществляется фрагментация в SLIP канале.
Фрагментация не появлялась и все было отлично до
тех пор, пока размер данных в пакете ping не возрос
от 500 байт до 600. Входящие эхо запросы были видны
(как будто фрагментации не было), однако эхо
отклики исчезли. </small></p>

<p><small>Чтобы лучше разобраться в происходящем,
программа tcpdump также была запущена на bsdi, после
чего стало видно, что отправляется и что
принимается. На рисунке 11.11 показан вывод.<a NAME="t116011"></a></small></p>

<p>&nbsp;</p>


<p>1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; solaris
&gt; bsdi: icmp: echo request (DF)<br>
2&nbsp; 0.000000 (0.0000)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi &gt; solaris: icmp:
echo reply (DF)<br>
3&nbsp; 0.000000 (0.0000)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun &gt; bsdi: icmp: solaris
unreachable - <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; need
to frag, mtu = 0 (DF)<br>
<br>
4&nbsp; 0.738400 (0.7384)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; solaris &gt; bsdi: icmp:
echo request (DF)<br>
5&nbsp; 0.748800 (0.0104)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi &gt; solaris: icmp:
echo reply (DF)<br>
6&nbsp; 0.748800 (0.0000)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun &gt; bsdi: icmp: solaris
unreachable - <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; need
to frag, mtu = 0 (DF)<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 11.11 Вывод программы tcpdump от ping на bsdi
от solaris с IP датаграммой размером в 600 байт.</small></p>

<p>&nbsp;</p>

<p><small>Во-первых, выражение (DF) в каждой строке
означает, что в единицу установлен бит &quot;не
фрагментировать&quot; в IP заголовке. Это означает,
что Solaris 2.2 нормально устанавливает этот бит в
единицу, что является частью механизма
определения транспортного MTU. </small></p>

<p><small>Строка 1 указывает, что эхо запрос проходит
через маршрутизатор netb к sun без фрагментации и с
установленным битом DF, поэтому можно сделать
вывод, что критичный размер MTU для SLIP хоста netb еще
не достигнут. </small></p>

<p><small>Также, заметьте из строки номер 2, что DF флаг
копируется в каждый эхо отклик. Как раз это и
вызвало проблему. Эхо отклик того же размера, что
и эхо запрос (чуть больше 600 байт), однако MTU
исходящего SLIP интерфейса хоста sun равен 552. Эхо
отклик должен быть фрагментирован, однако
установлен флаг DF. Это заставляет sun генерировать
ICMP ошибку о недоступности и отправлять ее к bsdi
(где она уничтожается). </small></p>

<p><small>Именно поэтому мы не видели эхо отклики от
solaris. Отклики не проходили через sun. На рисунке 11.12
показан путь прохождения пакетов.<a NAME="t116012"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t11_1200.jpg" WIDTH="492" HEIGHT="217"></small></p>


<p ALIGN="CENTER"><small>Рисунок 11.12 Обмен пакетами для
данного примера.</small></p>

<p>&nbsp;</p>

<p><small>И в завершение, отметим, что выражение mtu=0 в
строках 3 и 6 на рисунке&nbsp;11.11 указывает на то, что
sun не возвращает MTU для исходящего интерфейса в ICMP
сообщении о недоступности, как показано на
рисунке 11.9. (В разделе <a HREF="tcp25.html#t259000">&quot;Дополнительные
примеры&quot;</a> главы 25 мы решим эту проблему с
использованием SNMP и убедимся в том, что MTU SLIP
интерфейса netb равен 1500.) </small></p>
<u><b>

<p><a NAME="t117000"></a>Определение транспортного MTU с
использованием Traceroute</p>
</b></u>

<p><small>Так как большинство систем не поддерживают
функцию определения транспортного MTU, мы
доработаем программу <a NAME="t117001"></a>traceroute (<a HREF="tcp08.html">глава 8</a>) так, чтобы она могла
определять транспортный MTU. Мы отправим пакет с
установленным битом &quot;не фрагментировать&quot;
(don't fragment). Размер первого отправляемого пакета
будет равен MTU исходящего интерфейса. Когда
вернется ICMP ошибка &quot;не могу
фрагментировать&quot; (can't fragment), мы уменьшим размер
пакета. Если маршрутизатор, отправивший ICMP
ошибку, поддерживает новую версию, которая
включает MTU исходящего интерфейса в ICMP сообщение,
мы используем полученное значение; иначе мы
попробуем следующий меньший MTU. Как утверждает RFC
1191 [<a NAME="t117002"></a>Mogul and Deering 1990], существует
ограниченное количество значений MTU, наша
программа имеет таблицу возможных значений и
просто перейдет на следующее меньшее значение. </small></p>

<p><small>Попробуем подобный алгоритм с хоста sun на
хост slip, зная, что SLIP канал имеет MTU равный 296: </small></p>

<p>&nbsp;</p>


<p>sun % <b>traceroute.pmtu slip</b><br>
traceroute to slip (140.252.13.65), 30 hops max<br>
outgoing MTU = 1500<br>
1 bsdi (140.252.13.35)&nbsp; 15 ms&nbsp; 6 ms&nbsp; 6 ms<br>
2 bsdi (140.252.13.35)&nbsp; 6 ms<br>
fragmentation required and DF set, trying new MTU = 1492<br>
fragmentation required and DF set, trying new MTU = 1006<br>
fragmentation required and DF set, trying new MTU = 576<br>
fragmentation required and DF set, trying new MTU = 552<br>
fragmentation required and DF set, trying new MTU = 544<br>
fragmentation required and DF set, trying new MTU = 512<br>
fragmentation required and DF set, trying new MTU = 508<br>
fragmentation required and DF set, trying new MTU = 296<br>
2 slip (140.252.13.65)&nbsp; 377 ms&nbsp; 377 ms&nbsp; 377 ms<br>
</p>

<p>&nbsp;</p>


<p><small>В этом примере маршрутизатор bsdi не вернул MTU
исходящего интерфейса в ICMP сообщении, поэтому мы
перейдем на следующее меньшее значение MTU. Первая
строка вывода для <a NAME="t117003"></a>TTL равного 2
сообщает имя хоста bsdi, однако это происходит
из-за того, оно было возвращено маршрутизатором в
ICMP ошибке. Последняя строка вывода для TTL равного
2 это как раз то, что мы ожидали. </small></p>

<p><small>Не составляет труда модифицировать ICMP код
на bsdi, чтобы получить MTU исходящего интерфейса. И
если мы сделаем это и вернемся к нашей программе,
то получим следующий вывод: </small></p>

<p>&nbsp;</p>


<p>sun % <b>traceroute.pmtu slip</b><br>
traceroute to slip (140.252.13.65), 30 hops max<br>
outgoing MTU = 1500<br>
1 bsdi (140.252.13.35)&nbsp; 53 ms&nbsp; 6 ms&nbsp; 6 ms<br>
2 bsdi (140.252.13.35)&nbsp; 6 ms<br>
fragmentation required and DF set, next hop MTU = 296<br>
2 slip (140.252.13.65)&nbsp; 377 ms&nbsp; 378 ms&nbsp; 377 ms<br>
</p>

<p>&nbsp;</p>


<p><small>Здесь нам нет смысла перебирать восемь
различных значений MTU, маршрутизатор сообщил
нужное значение.</small></p>
<i><b>

<p><a NAME="t117004"></a>Мировой Internet</p>
</b></i>

<p><small>Модифицированная версия traceroute была
запущена несколько раз на различные хосты по
всему миру. С ее помощью было достигнуто 15 стран
(включая Антарктику), при этом были использованы
различные трансатлантические и
транстихоокеанские каналы. Однако, до того как
сделать это, мы увеличили MTU SLIP канала с дозвоном
между нашей подсетью и маршрутизатором netb
(рисунок 11.12) до 1500, как в Ethernet. </small></p>

<p><small>Из 18 раз, когда была запущена программа,
только в двух случаях траспортный MTU был меньше
чем 1500. Один трансатлантический канал имел MTU
равный 572 (странное значение, которое даже не
приведено в списке в RFC 1191), и маршрутизатор не
вернул ICMP ошибку в новом формате. Еще один канал
между двумя маршрутизаторами в Японии не
обрабатывал фреймы размером 1500 байт, также
маршрутизатор не вернул ICMP ошибку в новом
формате. После того как MTU было уменьшено до 1006,
все заработало. </small></p>

<p><small>Вывод, который мы можем сделать из этих
экспериментов, заключается в том, что
большинство (но не все) глобальных сетей в
настоящее время могут обрабатывать пакеты
больше чем 512 байт. Использование характеристики
поиска транспортного MTU позволяет приложениям
работать значительно продуктивнее, пользуясь
большими MTU.</small></p>
<u><b>

<p><a NAME="t118000"></a>Определение транспортного MTU при
использовании UDP</p>
</b></u>

<p><small>Давайте рассмотрим взаимодействие между
приложением, использующим UDP, и механизмом
определения транспортного MTU. Нам необходимо
посмотреть, что произойдет в том случае, когда
приложение отправляет датаграмму, которая
слишком велика для некоторого промежуточного
канала. </small></p>
<i><b>

<p>Пример</p>
</b></i>

<p><small>Так как единственная система, которая
поддерживает механизм определения
транспортного MTU, это <a NAME="t118001"></a>Solaris 2.x, мы
используем ее как хост источник, чтобы отправить
датаграмму размером 650 байт на slip. Так как хост slip
находится позади SLIP канала с MTU равным 296, любая UDP
датаграмма больше чем 268 байт (296 - 20 - 8) с
установленным битом &quot;не фрагментировать&quot;
должна вызвать ICMP ошибку &quot;не могу
фрагментировать&quot; с маршрутизатора bsdi. На
рисунке 11.13 показана топология и MTU каналов.<a NAME="t118002"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t11_1300.jpg" WIDTH="508" HEIGHT="180"></small></p>


<p ALIGN="CENTER"><small>Рисунок 11.13 Системы, использованные
для определения транспортного MTU с
использованием UDP.</small></p>

<p>&nbsp;</p>

<p><small>Следующая команда генерирует десять UDP
датаграмм размером 650 байт с интервалом в 5
секунд:</small></p>

<p>&nbsp;</p>


<p>solaris % <b>sock -u -i -n10 -w650 -p5 slip
discard</p>
</b>

<p>&nbsp;</p>

<p><small>На рисунке 11.14 показан вывод команды <a NAME="t118003"></a>tcpdump. Когда этот пример был запущен,
маршрутизатор bsdi был сконфигурирован таким
образом, чтобы не возвращать MTU следующей
пересылки как часть ICMP ошибки &quot;не могу
фрагментировать&quot;.</small></p>

<p><small>Первая посланная датаграмма с
установленным битом <a NAME="t118004"></a>DF (строка 1)
генерирует ожидаемую ошибку от маршрутизатора
bsdi (строка 2). Что интересно, следующая датаграмма,
также посланная с установленным битом DF (строка
3), генерирует ту же самую ICMP ошибку (строка 4). Мы
ожидали, что эта датаграмма будет послана с
выключенным битом DF.</small></p>

<p><small>В строке 5 IP наконец понял, что датаграммы в
этот пункт назначения не должны посылаться с
установленным битом DF, после чего стал
фрагментировать датаграммы на хосте источнике.
Это поведение отличается от того, что было
показано в ранних примерах, где IP отправлял
датаграммы, которые он получал от UDP, и при этом
маршрутизаторам с более маленькими MTU (bsdi в
данном случае) позволялось осуществлять
фрагментацию.<a NAME="t118005"></a>&nbsp;</small></p>

<p>&nbsp;</p>


<p> 1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; solaris.38196
&gt; slip.discard: udp 650 (DF)<br>
2&nbsp; 0.004218 (0.0042)&nbsp;&nbsp; bsdi &gt; solaris: icmp: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slip
unreachable - need to frag, mtu = 0 (DF)<br>
<br>
3&nbsp; 4.980528 (4.9763)&nbsp;&nbsp; solaris.38196 &gt; slip.discard: udp 650 (DF)<br>
4&nbsp; 4.984503 (0.0040)&nbsp;&nbsp; bsdi &gt; solaris: icmp: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slip
unreachable - need to frag, mtu = 0 (DF)<br>
<br>
5&nbsp; 9.870407 (4.8859)&nbsp;&nbsp; solaris.38196 &gt; slip.discard: udp 650 (frag
47942:552@0+)<br>
6&nbsp; 9.960056 (0.0896)&nbsp;&nbsp; solaris &gt; slip: (frag 47942:106@552)<br>
<br>
7&nbsp; 14.940338 (4.9803)&nbsp; solaris.38196 &gt; slip.discard: udp 650 (DF)<br>
8&nbsp; 14.944466 (0.0041)&nbsp; bsdi &gt; solaris: icmp: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slip
unreachable - need to frag, mtu = 0 (DF)<br>
<br>
9&nbsp; 19.890015 (4.9455)&nbsp; solaris.38196 &gt; slip.discard: udp 650 (frag
47944:552@0+)<br>
10&nbsp; 19.950463 (0.0604)&nbsp; solaris &gt; slip: (frag 47944:106@552)<br>
<br>
11&nbsp; 24.870401 (4.9199)&nbsp; solaris.38196 &gt; slip.discard: udp 650 (frag
47945:552@0+)<br>
12&nbsp; 24.960038 (0.0896)&nbsp; solaris &gt; slip: (frag 47945:106@552)<br>
<br>
13&nbsp; 29.880182 (4.9201)&nbsp; solaris.38196 &gt; slip.discard: udp 650 (frag
47946:552@0+)<br>
14&nbsp; 29.940498 (0.0603)&nbsp; solaris &gt; slip: (frag 47946:106@552)<br>
<br>
15&nbsp; 34.860607 (4.9201)&nbsp; solaris.38196 &gt; slip.discard: udp 650 (frag
47947:552@0+)<br>
16&nbsp; 34.950051 (0.0894)&nbsp; solaris &gt; slip: (frag 47947:106@552)<br>
<br>
17&nbsp; 39.870216 (4.9202)&nbsp; solaris.38196 &gt; slip.discard: udp 650 (frag
47948:552@0+)<br>
18&nbsp; 39.930443 (0.0602)&nbsp; solaris &gt; slip: (frag 47948:106@552)<br>
<br>
19&nbsp; 44.940485 (5.0100)&nbsp; solaris.38196 &gt; slip.discard: udp 650 (DF)<br>
20&nbsp; 44.944432 (0.0039)&nbsp; bsdi &gt; solaris: icmp: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slip
unreachable - need to frag, mtu = 0 (DF)<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 11.14 Определение транспортного MTU с
использованием UDP.</small></p>

<p>&nbsp;</p>

<p><small>Так как ICMP сообщение &quot;не могу
фрагментировать&quot; не содержит MTU следующей
пересылки, это означает, что IP решил что всех
устраивает MTU равный 576. Первый фрагмент (строка 5)
содержит 544 байта UDP данных, 8 байт UDP заголовка и 20
байт IP заголовка, полный размер IP датаграммы
составляет 572 байта. Второй фрагмент (строка 6)
содержит оставшиеся 106 байт UDP данных и 20-байтный
IP заголовок. </small></p>

<p><small>К сожалению, следующая датаграмма, строка 7,
имеет установленный бит DF, поэтому она
отбрасывается bsdi, после чего возвращается ICMP
ошибка. Здесь произошло следующее: истек IP
таймер, который сообщил IP о необходимости
проверить, не увеличился ли транспортный MTU,
путем повторной установки бита DF. Мы увидим, что
это произойдет снова в строках 19 и 20. Сравнивая
времена в строках 7 и 19, где DF бит устанавливается
в единицу, мы видим, что проверка на увеличение
транспортного MTU осуществляется каждые 30 секунд.</small></p>

<p>&nbsp;</p>


<p>Этот 30-секундный таймер
слишком мал. RFC 1191 рекомендует установить
значение таймера в 10 минут. Величину таймера
можно изменить с помощью параметра <a NAME="t118006"></a>ip_ire_pathmtu_interval
(приложение E, раздел <a HREF="tcp_e.html#t354000">&quot;Solaris 2.2&quot;</a>).
В <a NAME="t118007"></a>Solaris 2.2 не существует способа
выключить определение транспортного MTU для
одного UDP приложения или для всех UDP приложений.
Оно может быть включено или выключено только для
всей системы в целом с помощью изменения
параметра <a NAME="t118008"></a>ip_path_mtu_discovery. Как мы видим
из данного примера, включение характеристики
определения транспортного MTU, когда UDP приложения
отправляют датаграммы, которые, возможно, будут
фрагментированы, приведет к тому, что датаграмма
может быть отброшена. </p>


<p>&nbsp;</p>

<p><small>Максимальный размер датаграммы,
воспринимаемый IP уровнем на solaris (576 байт),
неверен. На рисунке 11.13 мы видели, что реальный MTU
составляет 296 байт. Это означает, что фрагменты,
генерируемые solaris, снова фрагментируются на bsdi.
На рисунке 11.15 показан вывод <a NAME="t118009"></a>tcpdump,
полученный на хосте назначения (slip) для первой
прибывшей датаграммы (строки 5 и 6 на рисунке 11.14).<a NAME="t118010"></a></small></p>

<p>&nbsp;</p>


<p>1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; solaris.38196
&gt; slip.discard: udp 650 (frag 47942:272@0+)<br>
2&nbsp; 0.304513 (0.3045)&nbsp;&nbsp;&nbsp;&nbsp; solaris &gt; slip: (frag 47942:272@272+)<br>
3&nbsp; 0.334651 (0.0301)&nbsp;&nbsp;&nbsp;&nbsp; solaris &gt; slip: (frag 47942:8@544+)<br>
4&nbsp; 0.466642 (0.1320)&nbsp;&nbsp;&nbsp;&nbsp; solaris &gt; slip: (frag 47942:106@552)<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 11.15 Первая датаграмма, прибывшая на
хост slip от solaris.</small></p>

<p>&nbsp;</p>

<p><small>В этом примере хост solaris не должен
фрагментировать исходящие датаграммы, однако
должен выключить бит DF и позволить
маршрутизатору с меньшим MTU осуществить
фрагментацию. </small></p>

<p><small>Сейчас мы запустим тот же самый пример,
однако изменим поведение маршрутизатора bsdi так,
чтобы тот возвращал MTU следующей пересылки в ICMP
сообщении &quot;не могу фрагментировать&quot;. На
рисунке 11.16 показаны первые шесть строк вывода
tcpdump.<a NAME="t118011"></a></small></p>

<p>&nbsp;</p>


<p>1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; solaris.37974
&gt; slip.discard: udp 650 (DF)<br>
2&nbsp; 0.004199 (0.0042)&nbsp;&nbsp;&nbsp;&nbsp; bsdi &gt; solaris: icmp: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slip
unreachable - need to frag, mtu = 296 (DF)<br>
<br>
3&nbsp; 4.950193 (4.9460)&nbsp;&nbsp;&nbsp;&nbsp; solaris.37974 &gt; slip.discard: udp 650
(DF)<br>
4&nbsp; 4.954325 (0.0041)&nbsp;&nbsp;&nbsp;&nbsp; bsdi &gt; solaris: icmp: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slip
unreachable - need to frag, mtu = 296 (DF)<br>
<br>
5&nbsp; 9.779855 (4.8255)&nbsp;&nbsp;&nbsp;&nbsp; solaris.37974 &gt; slip.discard: udp 650
(frag 35278:272@0+)<br>
6&nbsp; 9.930018 (0.1502)&nbsp;&nbsp;&nbsp;&nbsp; solaris &gt; slip: (frag 35278:272@272+)<br>
7&nbsp; 9.990170 (0.0602)&nbsp;&nbsp;&nbsp;&nbsp; solaris &gt; slip: (frag 35278:114@544)<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 11.16 Определение транспортного MTU с
использованием UDP.</small></p>

<p>&nbsp;</p>

<p><small>И снова мы видим, что две первые датаграммы
отправлены с установленным битом DF, на обе
получены ICMP ошибки. Сейчас в ICMP ошибке
указывается MTU следующей пересылки, который
равен 296. </small></p>

<p><small>В строках 5, 6 и 7 мы видим, что хост источник
осуществляет фрагментацию, как на рисунке 11.14.
Если известен MTU следующей пересылки,
генерируются только три фрагмента, по сравнению
с четырьмя фрагментами, которые генерируются
маршрутизатором bsdi на рисунке 11.15.</small></p>
<u><b>

<p><a NAME="t119000"></a>Взаимодействие между UDP и ARP</p>
</b></u>

<p><small>Используя UDP, мы можем рассмотреть очень
интересное взаимодействие между UDP и типичной
реализацией ARP.</small></p>

<p><small>Мы используем программу <a NAME="t119001"></a>sock,
чтобы сгенерировать одну UDP датаграмму с 8192
байтами данных. Мы ожидаем, что в этом случае
будет сгенерировано шесть Ethernet фрагментов (см. <a HREF="#t11D001">упражнение 3</a> главы 11). Также, перед
запуском программы, мы убедимся в том, что ARP кэш
пуст, поэтому перед тем как будет отправлен
первый фрагмент, должен произойти обмен ARP
запросом и откликом.</small></p>

<p>&nbsp;</p>


<p>bsdi % <b>arp -a </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; проверяем,
что ARP кэш пуст<br>
bsdi % <b>sock -u -i -n1 -w8192 svr4 discard<br>
</p>
</b>

<p>&nbsp;</p>

<p><small>Мы ожидаем, что первая датаграмма вызовет
отправку ARP запроса. Следующие пять фрагментов,
которые генерируются IP, ставят перед нами два
вопроса, на которые мы можем ответить, только
воспользовавшись <a NAME="t119002"></a>tcpdump: будут ли
готовы к отправке оставшиеся фрагменты, перед
тем как будет получен ARP отклик, если так, что
будет делать ARP с этими несколькими пакетами
направляемыми на конкретный пункт назначения,
пока ожидается ARP отклик? На рисунке 11.17 показан
вывод программы tcpdump.<a NAME="t119003"></a></small></p>

<p>&nbsp;</p>


<p> 1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp
who-has svr4 tell bsdi<br>
2&nbsp; 0.001234 (0.0012)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp who-has svr4 tell bsdi<br>
3&nbsp; 0.001941 (0.0007)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp who-has svr4 tell bsdi<br>
4&nbsp; 0.002775 (0.0008)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp who-has svr4 tell bsdi<br>
5&nbsp; 0.003495 (0.0007)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp who-has svr4 tell bsdi<br>
6&nbsp; 0.004319 (0.0008)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp who-has svr4 tell bsdi<br>
7&nbsp; 0.008772 (0.0045)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp reply svr4 is-at
0:0:c0:c2:9b:26<br>
8&nbsp; 0.009911 (0.0011)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp reply svr4 is-at
0:0:c0:c2:9b:26<br>
9&nbsp; 0.011127 (0.0012)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi &gt; svr4: (frag
10863:800@7400)<br>
10&nbsp; 0.011255 (0.0001)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp reply svr4 is-at
0:0:c0:c2:9b:26<br>
11&nbsp; 0.012562 (0.0013)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp reply svr4 is-at
0:0:c0:c2:9b:26<br>
12&nbsp; 0.013458 (0.0009)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp reply svr4 is-at
0:0:c0:c2:9b:26<br>
13&nbsp; 0.014526 (0.0011)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp reply svr4 is-at
0:0:c0:c2:9b:26<br>
14&nbsp; 0.015583 (0.0011)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp reply svr4 is-at
0:0:c0:c2:9b:26<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 11.17 Обмен пакетами при отправке по
Ethernet UDP датаграммы размером 8192 байта.</small></p>

<p>&nbsp;</p>

<p><small>Этот вывод достаточно неожидан. Во-первых,
перед тем как получен первый ARP отклик,
генерируются шесть ARP запросов. Как можно
догадаться, IP быстро генерирует шесть
фрагментов, и для каждого отправляется ARP запрос. </small></p>

<p><small>Затем, когда получен первый ARP отклик
(строка 7), отправляется только последний
фрагмент (строка 9)! Это означает, что первые пять
фрагментов были отброшены. В действительности,
это пример обычного функционирования ARP.
Большинство реализаций держат только последний
пакет, который должен быть отправлен на хост
назначения, пока ожидается ARP отклик. </small></p>

<p>&nbsp;</p>


<p>Требования к хостам <a NAME="t119004"></a>Host Requirements RFC требуют от реализаций,
чтобы они предотвращали <a NAME="t119005"></a>лавинообразную
рассылку ARP запросов (повторная отправка ARP
запросов для одного и того же IP адреса с большой
частотой). Рекомендуемая максимальная частота
составляет один раз в секунду. Здесь мы видим
шесть ARP запросов в течение 4,3 миллисекунды.
Требования к хостам Host Requirements RFC требуют, чтобы ARP
сохранил по крайней мере один пакет, и это должен
быть самый последний пакет. Это как раз то, что мы
видели здесь.</p>


<p>&nbsp;</p>

<p><small>Следующая необъяснимая аномальность
заключается в том, что svr4 отправил назад семь ARP
откликов, а не шесть. </small></p>

<p><small>И последнее, про что хочется сказать, tcpdump
работал еще 5 минут после того, как вернулся
последний ARP отклик, ожидая увидеть, как svr4 пошлет
назад ICMP ошибку <a NAME="t119006"></a>&quot;время истекло в
течение повторной сборки&quot; (time exceeded during reassembly).
ICMP сообщение так и не появилось. (Мы показали
формат этого сообщения на <a HREF="tcp08.html#t083001">рисунке
8.2</a>. Поле код, установленное в 1, указывает на то,
что время истекло в течение <a NAME="t119007"></a>повторной
сборки датаграммы.)</small></p>

<p><small>IP уровень должен запустить таймер, когда
появляется первый фрагмент датаграммы. Здесь
&quot;первый&quot; означает первый из прибывших
фрагментов для данной датаграммы, а не просто
первый фрагмент (со <a NAME="t119008"></a>смещением
фрагмента равным 0). Обычное значение тайм-аута
находится в диапазоне от 30 до 60 секунд. Если все
фрагменты для этой датаграммы не прибыли за
время до истечения таймера, все фрагменты
отбрасываются. Если этого не сделать, фрагменты,
которые уже никогда не прибудут (как мы видели в
этом примере), могут вызвать переполнение <a NAME="t119009"></a>приемного буфера. </small></p>

<p><small>Существуют две причины, по которым мы не
увидели ICMP сообщение. Во-первых, большинство
реализаций Berkeley никогда не генерируют эту
ошибку! Эти реализации устанавливают таймер и
отбрасывают все фрагменты, когда таймер истечет,
однако ICMP ошибка не генерируется. Во-вторых,
первый фрагмент - фрагмент со смещением равным 0,
содержащий UDP заголовок, не был принят. (Это был
первый из пяти пакетов, отброшенных ARP.)
Реализация не требует генерировать ICMP ошибку,
если первый фрагмент не был принят. Причина
заключается в том, что приемник ICMP ошибки не
может сказать, который пользовательский процесс
отправил датаграмму, которая была отброшена,
потому что недоступен заголовок транспортного
уровня. А высший уровень (либо TCP приложение, либо
UDP приложение) отработает тайм-аут и повторит
передачу. </small></p>

<p><small>В этом разделе мы использовали IP
фрагментацию, чтобы посмотреть, как
осуществляется взаимодействие между UDP и ARP. Это
взаимодействие можно увидеть, если отправитель
быстро отправит несколько UDP датаграмм. Мы
воспользовались фрагментацией, потому что
пакеты быстро генерируются с помощью IP, что
значительно быстрее, чем генерация нескольких
пакетов пользовательским процессом.</small></p>
<u><b>

<p><a NAME="t11A000"></a>Максимальный размер UDP датаграммы</p>
</b></u>

<p><small>Теоретически максимальный размер IP
датаграммы может составлять 65535 байт, что
ограничивается 16-битным полем полной длины в IP
заголовке (см. <a HREF="tcp03.html#t032001">рисунок 3.1</a>). При
длине IP заголовка равной 20 байтам и длине UDP
заголовка равной 8 байтам в UDP датаграмме для
пользовательских данных остается максимум 65507
байт. В большинстве реализаций, однако,
используются датаграммы значительно меньшего
размера. </small></p>

<p><small>Обычно играют роль два ограничения.
Во-первых, программа приложение может быть
ограничена программным интерфейсом. <a NAME="t11A001"></a>Сокеты
API (глава 1, раздел <a HREF="tcp01.html#t01F000">&quot;Интерфейсы
прикладного программирования&quot;</a>)
предоставляют функцию, которая может быть
вызвана приложением, чтобы установить размер
буферов ввода и вывода. Для UDP сокета этот размер
напрямую связан с максимальным размером UDP
датаграммы, которая может быть прочитана и
записана UDP. В настоящее время большинство систем
предоставляют по умолчанию максимальный размер
UDP датаграммы, которая может быть прочитана или
записана, равный 8192 байтам. (Эта значение
установлено в 8192, потому что именно столько по
умолчанию читается и записывается системой NFS.) </small></p>

<p><small>Следующее ограничение определяется
реализацией ядра TCP/IP. Могут существовать
характеристики реализации (или ошибки), которые
ограничивают размер UDP датаграммы значением
меньшим, чем 65535 байт.</small></p>

<p>&nbsp;</p>


<p>Автор
экспериментировал с различными размерами UDP
датаграмм, используя программу <a NAME="t11A002"></a>sock. С
использованием <a NAME="t11A003"></a>loopback интерфейса под <a NAME="t11A004"></a>SunOS 4.1.3, максимальный размер UDP
датаграммы был 32767 байт. Использовать большее
значение не удавалось. При передаче по Ethernet от <a NAME="t11A005"></a>BSD/386 к SunOS 4.1.3, максимальный размер IP
датаграммы, которую мог принять Sun, составлял 32786
(при этом пользовательских данных было 32758 байт).
С использованием loopback интерфейса в <a NAME="t11A006"></a>Solaris
2.2 максимальный размер IP датаграммы, которая
могла быть отправлена и принята, составлял 65535
байт. При передаче от Solaris 2.2 к <a NAME="t11A007"></a>AIX 3.2.2
удалось передать IP датаграмму максимального
размера в 65535 байт.</p>


<p>&nbsp;</p>

<p><small>В разделе <a HREF="tcp03.html#t032000">&quot;IP заголовок&quot;</a>
главы 3 мы упомянули, что хосту необходимо
получать IP датаграммы размером по меньшей мере 576
байт. Большинство приложений UDP разработаны
таким образом, чтобы ограничивать свои
приложения в размере 512 байт данных или меньше,
чтобы уложиться в это ограничение. В разделе <a HREF="tcp10.html#t104000">&quot;RIP: протокол обмена информацией
о маршрутизации&quot;</a> главы 10, например, мы
видели, что RIP всегда посылает в датаграмме
меньше чем 512 байт. Это же самое ограничение мы
найдем и в других UDP приложениях: DNS (<a HREF="tcp14.html">глава
14</a>), TFTP (<a HREF="tcp15.htm">глава 15</a>), BOOTP (<a HREF="tcp16.html">глава
16</a>) и SNMP (<a HREF="tcp25.html">глава 25</a>).</small></p>
<i><b>

<p><a NAME="t11A008"></a>Усечение датаграмм</p>
</b></i>

<p><small>Из того что IP может отправлять и принимать
датаграммы определенного размера, не следует,
что принимающее приложение готово прочитать
датаграммы этого размера. Программный интерфейс
UDP позволяет приложениям указывать максимальное
количество байт, которые будут обработаны за
один раз. Что произойдет, если принятая
датаграмма по размеру больше, чем датаграмма,
которую готово принять приложение? </small></p>

<p><small>К сожалению, ответ зависит от программного
интерфейса и реализации.</small></p>

<p>&nbsp;</p>


<p>Традиционные версии
Berkeley сокет API обрезают датаграммы, отбрасывая
любые непоместившиеся данные. Будет ли
приложение поставлено в известность, зависит от
версии. (<a NAME="t11A009"></a>4.3 BSD Reno и более поздние
версии могут уведомить приложение о том, что
датаграмма была обрезана.) <a NAME="t11A010"></a>API сокеты
под <a NAME="t11A011"></a>SVR4 (включая Solaris 2.x) не обрезают
датаграммы. Любые непоместившиеся данные
последовательно считываются. Приложение не
уведомляется о нескольких циклах считывания и
ему будет передана одна UDP датаграмма. TLI API не
отбрасывают данные. Вместо этого возвращается
флаг, указывающий на то, что данных больше, чем
можно считать за один раз, поэтому приложение
начинает последовательно считывать оставшуюся
датаграмму.</p>


<p>&nbsp;</p>

<p><small>Когда мы будем обсуждать TCP, то увидим, что
этот протокол предоставляет последовательные
потоки байт, направляемые в приложение, без
каких-либо ограничений. TCP передает в приложение
данные любого размера, которые требуются для
приложения - причем данные на этом интерфейсе
никогда не теряются. </small></p>
<u><b>

<p><a NAME="t11B000"></a>ICMP ошибка подавления источника</p>
</b></u>

<p><small>Воспользовавшись UDP, можно сгенерировать ICMP
ошибку <a NAME="t11B001"></a>&quot;подавление источника&quot;
(source quench). Эта ошибка может быть сгенерирована
системой (маршрутизатором или хостом), когда она
принимает датаграммы быстрее, чем эти датаграммы
могут быть обработаны. Обратите внимание на
выражение &quot;могут быть&quot;. Система не требует
послать подавление источника, даже если буферы
переполнены и датаграммы отбрасываются. </small></p>

<p><small>На рисунке 11.18 показан формат ICMP ошибки
подавления источника. Мы имеем идеальную
возможность сгенерировать подобную ошибку в
нашей тестовой сети. Мы можем посылать
датаграммы с bsdi на маршрутизатор sun по Ethernet,
причем эти датаграммы должны быть
смаршрутизированы через SLIP канал. Так как SLIP
канал примерно в тысячу раз медленнее чем Ethernet,
мы легко можем переполнить буфер. Следующая
команда посылает 100 датаграмм размером 1024 байта с
хоста bsdi через маршрутизатор sun на solaris. Мы
отправляем датаграммы на стандартный discard
сервис, где они будут игнорированы:<a NAME="t11B002"></a></small></p>

<p>&nbsp;</p>


<p>bsdi % <b>sock -u -i -w1024 -n100 solaris
discard</p>
</b>

<p>&nbsp;</p>


<p ALIGN="CENTER"><small><img SRC="t11_1800.jpg" WIDTH="514" HEIGHT="168"></small></p>


<p ALIGN="CENTER"><small>Рисунок 11.18 ICMP ошибка подавления
источника.</small></p>

<p>&nbsp;</p>

<p><small>На рисунке 11.19 показан вывод команды tcpdump,
соответствующий этой команде.<a NAME="t11B003"></a></small></p>

<p>&nbsp;</p>


<p>&nbsp; 1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1403 &gt;
solaris.discard: udp 1024<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 26
строк не показано<br>
27&nbsp; 0.10 (0.00)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1403 &gt; solaris.discard: udp 1024<br>
28&nbsp; 0.11 (0.01)&nbsp;&nbsp;&nbsp;&nbsp; sun &gt; bsdi: icmp: source quench<br>
<br>
29&nbsp; 0.11 (0.00)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1403 &gt; solaris.discard: udp 1024<br>
30&nbsp; 0.11 (0.00)&nbsp;&nbsp;&nbsp;&nbsp; sun &gt; bsdi: icmp: source quench<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 142
строки не показано<br>
173&nbsp; 0.71 (0.06)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1403 &gt; solaris.discard: udp 1024<br>
174&nbsp; 0.71 (0.00)&nbsp;&nbsp;&nbsp;&nbsp; sun &gt; bsdi: icmp: source quench<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 11.19 ICMP подавление источника от
маршрутизатора sun.</small></p>

<p>&nbsp;</p>

<p><small>Из этого вывода мы удалили множество строк.
Первые 26 датаграмм приняты без ошибок: мы
показали вывод только для первой. Начиная с 27-й
датаграммы, каждый раз, когда отправляется
датаграмма, мы получаем ошибку подавление
источника. Всего было 26+(74х2)=174 строк вывода. </small></p>

<p><small>Из нашего расчета пропускной способности
последовательной линии, приведенного в разделе <a HREF="tcp02.html#t02A000">&quot;Вычисление загруженности
последовательной линии&quot;</a> главы 2, видно, что
на передачу датаграммы размером 1024 байта со
скоростью 9600 бит/сек потребуется больше одной
секунды. (В нашем примере для этого потребуется
больше времени, так как датаграмма размером 20+8+1024
байт будет фрагментирована, потому что MTU SLIP
канала от sun к netb составляет 552 байта.) Однако, из
показателей времени, приведенных на рисунке 11.19,
мы видим, что маршрутизатор sun получил все 100
датаграмм за время меньше чем одна секунда, перед
тем как первая была отправлена в SLIP канал. При
этом понятно, что мы использовали множество его
буферов. </small></p>

<p>&nbsp;</p>


<p>Несмотря на то, что RFC 1009
<a NAME="t11B004"></a>[Braden and Postel 1987] требует, чтобы
маршрутизатор генерировал ошибки подавления
источника, когда переполняются его буферы, новые
требования к маршрутизаторам <a NAME="t11B005"></a>Router
Requirements RFC [<a NAME="t11B006"></a>Almquist 1993] меняют это
положение и говорят, что маршрутизатор не должен
генерировать ошибки подавления источника.</p>


<p>&nbsp;</p>

<p><small>Следующий момент, на который необходимо
обратить внимание в примере, заключается в том,
что программа <a NAME="t11B007"></a>sock никогда не получала
уведомлений о том, что источник подавлен, или
если и получала их, то игнорировала. Это говорит о
том, что реализации BSD обычно игнорируют
полученные сообщения о подавлении источника в
случае использования протокола UDP. (В случае TCP,
при получении уведомления передача данных по
соединению, для которого сгенерировано
подавление источника, замедляется. Мы это
обсудим в разделе <a HREF="tcp21.html#t21A000">&quot;ICMP
ошибки&quot;</a> главы 21.) Проблема заключается в том,
что процесс, который сгенерировал данные,
которые, в свою очередь, вызвали подавление
источника, может уже завершиться, когда будет
принято сообщение о подавлении источника. И
действительно, если мы используем программу <a NAME="t11B008"></a>time в Unix, чтобы оценить, как долго
работает программа sock, то узнаем, что она
проработала всего лишь около 0,5 секунды. Однако
на рисунке 11.19 мы видели, что некоторые сообщения
о подавлении источника были получены через 0,71
секунды после отправки первой датаграммы, то
есть уже после того, как процесс прекратил
работу. Что произойдет, если наша программа
выдаст 100 датаграмм и завершится. Не все 100
датаграмм будут посланы - некоторые из них будут
стоять в выходной очереди. </small></p>

<p><small>Этот пример доказывает, что UDP - <a NAME="t11B009"></a>ненадежный
протокол и показывает важность контроля за
потоком данных (flow control). Несмотря на то, что
программа sock успешно выдала в сеть 100 датаграмм,
только 26 достигли пункта назначения. Остальные 74
скорее всего были отброшены промежуточным
маршрутизатором. Если приложение не
поддерживает какую-либо форму уведомлений,
отправитель не знает, принял ли получатель
данные.</small></p>
<u><b>

<p><a NAME="t11C000"></a>Сервер UDP</p>
</b></u>

<p><small>Существует несколько особенностей
использования UDP, которые отражаются на
разработке и реализации сервера. Разработка и
реализация клиентов обычно легче, чем реализация
серверов. Именно поэтому здесь мы обсудим
разработку сервера, а не разработку клиента.
Серверы обычно взаимодействуют с операционной
системой, и большинство серверов требуют, чтобы
существовал какой-либо способ, позволяющий
обработать запросы от нескольких клиентов
одновременно. </small></p>

<p><small>Обычно когда клиент стартует, он сразу же
устанавливает соединение с одним сервером.
Сервера, с другой стороны, стартуют и затем
&quot;засыпают&quot;, ожидая прибытия запроса от
клиента. В случае UDP, сервер &quot;просыпается&quot;,
когда прибывает датаграмма от клиента, эта
датаграмма может содержать запрос в какой-либо
форме. </small></p>

<p><small>Мы не будем рассматривать аспекты
программирования клиентов и серверов ([Stevens 1990]
описывает все более подробно), однако рассмотрим
характеристики протокола UDP, которые оказывают
влияние на разработку и реализацию сервера,
использующего UDP. (Мы обсудим подробности TCP
сервера в разделе <a HREF="tcp18.html#t18B000">&quot;Реализация
TCP сервера&quot;</a> главы 18.) Некоторые
характеристики мы обсудим в зависимости от
реализаций UDP, которые будут использоваться, а
также рассмотрим характеристики, которые
являются общими для большинства реализаций.</small></p>
<i><b>

<p><a NAME="t11C001"></a>IP адрес клиента и номер порта</p>
</b></i>

<p><small>От клиента прибывает UDP датаграмма. IP
заголовок содержит IP адреса источника и
назначения, а UDP заголовок содержит номера портов
UDP источника и назначения. Когда приложение
получает UDP датаграмму, операционная система
должна сообщить ему, кто послал сообщение - IP
адрес источника и номер порта.</small></p>

<p><small>Эта характеристика позволяет одному UDP
серверу обрабатывать несколько клиентов. Каждый
отклик отправляется тому клиенту, который послал
запрос.</small></p>
<i><b>

<p><a NAME="t11C002"></a>IP адрес назначения</p>
</b></i>

<p><small>Некоторым приложениям необходимо знать,
кому предназначена датаграмма, то есть IP адрес
назначения. Например, требования к хостам <a NAME="t11C003"></a>Host Requirements RFC определяют, что <a NAME="t11C004"></a>TFTP
сервер должен игнорировать принятые датаграммы,
которые рассылаются на широковещательный адрес.
(Мы опишем широковещательную адресацию в <a HREF="tcp12.htm">главе 12</a>, а TFTP в <a HREF="tcp15.html">главе 15</a>.)</small></p>

<p><small>Это означает, что операционная система
должна передать IP адрес назначения из принятой UDP
датаграммы в приложение. К сожалению, не все
реализации предоставляют эту возможность.</small></p>

<p>&nbsp;</p>


<p><a NAME="t11C005"></a>Сокеты API
предоставляют эту возможность с использованием
опции <a NAME="t11C006"></a>IP_RECVDSTADDR. Из систем, которые
описываются в тексте, только <a NAME="t11C007"></a>BSD/386, <a NAME="t11C008"></a>4.4BSD и <a NAME="t11C009"></a>AIX 3.2.2 поддерживают
эту опцию. <a NAME="t11C010"></a>SVR4, <a NAME="t11C011"></a>SunOS 4.x и <a NAME="t11C012"></a>Solaris 2.x не поддерживают.</p>


<p>&nbsp;</p>
<i><b>

<p><a NAME="t11C013"></a>Входная очередь UDP</p>
</b></i>

<p><small>В разделе <a HREF="tcp01.html#t018000">&quot;Модель
клиент-сервер&quot;</a> главы 1 мы говорили, что
большинство UDP серверов могут обслуживать все
запросы к клиентам с использованием одного UDP
порта (заранее известные порты серверов). </small></p>

<p><small>Обычно размер входной очереди, связанный с
каждым UDP портом, который используется
приложением, ограничен. Это означает, что
запросы, которые прибывают в одно и то же время от
различных клиентов, автоматически ставятся в
очередь UDP. Принятые UDP датаграммы передаются
приложению (когда оно требует следующую
датаграмму) в том порядке, в каком они были
приняты. </small></p>

<p><small>Однако существует вероятность, в случае
если очередь переполнена, что модуль UDP в ядре
отбросит входящие датаграммы. Мы можем
пронаблюдать это с помощью следующего
эксперимента. Стартуем нашу программу sock на
хосте bsdi, запустив таким образом UDP сервер: </small></p>

<p>&nbsp;</p>


<p>bsdi % <b>sock -s -u -v -E -R256 -r256 -P30 6666</b><br>
from 140.252.13.33, to 140.252.13.63: 1111111111
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; от sun на
широковещательный адрес<br>
from 140.252.13.34, to 140.252.13.35: 4444444444444&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; от
svr4 на персональный адрес<br>
</p>


<p>&nbsp;</p>

<p><small>Мы использовали следующие флаги : <a NAME="t11C014"></a>-s,
запускает программу в роли сервера, <a NAME="t11C015"></a>-u
для UDP, <a NAME="t11C016"></a>-v, печатает IP адрес клиента, и <a NAME="t11C017"></a>-E печатает IP адрес назначения (в данном
случае система это позволяет). В дополнение, мы
установили <a NAME="t11C018"></a>приемный буфер UDP для
этого порта в 256 байт (<a NAME="t11C019"></a>-R), вместе с
размером, который может быть прочитан каждым
приложением (<a NAME="t11C020"></a>-r). Флаг <a NAME="t11C021"></a>-P30
сообщает о необходимости подождать 30 секунд
после очистки UDP порта, перед считыванием первой
датаграммы. Это дает нам время стартовать
клиентов на двух других хостах, послать
некоторые датаграммы и посмотреть, как работает
очередь приема.</small></p>

<p><small>После того как сервер стартован и прошла
30-секундная пауза, мы стартуем одного клиента на
хосте sun и посылаем три датаграммы:</small></p>

<p>&nbsp;</p>


<p>sun % <b>sock -u -v 140.252.13.63 6666 </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; на
широковещательный адрес Ethernet<br>
connected on 140.252.13.33.1252 to 140.252.13.63.6666<br>
<b>1111111111 </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11
байт данных (с символом новой строки)<br>
<b>222222222 </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10
байт данных (с символом новой строки)<br>
<b>33333333333 </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12
байт данных (с символом новой строки)<br>
</p>


<p>&nbsp;</p>

<p><small>Адрес назначения это широковещательный
адрес (140.252.13.63). Затем мы стартовали еще одного
клиента на хосте svr4 и послали еще три датаграммы:</small></p>

<p>&nbsp;</p>


<p><br>
svr4 % <b>sock -u -v bsdi 6666</b><br>
connected on 0.0.0.0.1042 to 140.252.13.35.6666<br>
<b>4444444444444 </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14
байт данных (с символом новой строки)<br>
<b>555555555555555 </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16
байт данных (с символом новой строки)<br>
<b>66666666 </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9
байт данных (с символом новой строки)<br>
</p>


<p>&nbsp;</p>

<p><small>Первое, на что необходимо обратить внимание
в интерактивном выводе, показанном ранее на bsdi,
что только две датаграммы были приняты
приложением: первая от sun, состоящая из всех
единиц, и первая от svr4, состоящая из всех
четверок. Остальные четыре датаграммы были
отброшены. </small></p>

<p><small>Вывод команды <a NAME="t11C022"></a>tcpdump на рисунке
11.20 показывает, что все шесть датаграмм были
доставлены к хосту назначения. Датаграммы
прибыли от двух клиентов в обратном порядке:
первая от sun, затем от svr4 и так далее. Также мы
можем заметить, что все шесть были доставлены
примерно за 12 секунд, в течение 30-секундного
периода пока сервер &quot;спал&quot;.<a NAME="t11C023"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp;&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.1252
&gt; 140.252.13.63.6666: udp 11<br>
2&nbsp;&nbsp; 2.499184 (2.4992)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; svr4.1042
&gt; bsdi.6666: udp 14<br>
3&nbsp;&nbsp; 4.959166 (2.4600)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.1252
&gt; 140.252.13.63.6666: udp 10<br>
4&nbsp;&nbsp; 7.607149 (2.6480)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; svr4.1042
&gt; bsdi.6666: udp 16<br>
5&nbsp; 10.079059 (2.4719)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.1252 &gt;
140.252.13.63.6666: udp 12<br>
6&nbsp; 12.415943 (2.3369)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; svr4.1042 &gt;
bsdi.6666: udp 9<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 11.20 Вывод tcpdump для UDP датаграмм,
посланных двумя клиентами.</small></p>

<p>&nbsp;</p>

<p><small>Также необходимо отметить, что c опцией -E
сервер может узнать IP адрес назначения каждой
датаграммы. Сервер может выбирать, что сделать с
первой принятой датаграммой, которая была
отправлена на широковещательный адрес. </small></p>

<p><small>В этом примере необходимо обратить
внимание еще на некоторые особенности. Во-первых,
приложение не сообщило, когда была переполнена
входная очередь. Лишние датаграммы UDP просто
отбросил. Также в выводе tcpdump мы видим, что ничего
не было отправлено клиенту обратно, чтобы
сообщить ему о том, что датаграммы были
отброшены. Не было послано ничего похожего на ICMP
сообщение <a NAME="t11C024"></a>подавления источника,
абсолютно ничего. И в заключение, хочется
отметить, что входная очередь UDP функционирует по
принципу <a NAME="t11C025"></a>FIFO (первый вошел, первый
вышел), тогда как, что мы видели в разделе <a HREF="#t119000">&quot;Взаимодействие между UDP и ARP&quot;</a>
этой главы, входная очередь ARP - <a NAME="t11C026"></a>LIFO
(последний зашел, первый вышел).</small></p>
<i><b>

<p><a NAME="t11C027"></a>Ограничение локального IP адреса</p>
</b></i>

<p><small>Большинство UDP серверов используют <a NAME="t11C028"></a>символы подстановки для своих IP
адресов, когда создают конечные точки UDP. Это
означает, что входящая UDP датаграмма,
направляющаяся на порт сервера, будет принята
любым локальным интерфейсом. Например, мы можем
стартовать UDP сервер на порте 7777:</small></p>

<p>&nbsp;</p>


<p>sun % <b>sock -u -s 7777</p>
</b>

<p>&nbsp;</p>

<p><small>Затем мы воспользуемся командой <a NAME="t11C030"></a>netstat,
чтобы посмотреть состояние этой конечной точки:</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>netstat -a -n -f inet</b><br>
Active Internet connections (including servers)<br>
Proto Recv-Q Send-Q&nbsp;&nbsp; Local Address
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Foreign Address
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (state)<br>
udp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp; *.7777
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *.*<br>
</p>


<p>&nbsp;</p>

<p><small>В этом выводе мы удалили много строк и
оставили только те, которые нам интересны. Флаг <a NAME="t11C031"></a>-a сообщает о всех конечных точках сети.
Флаг <a NAME="t11C032"></a>-n печатает IP адреса в десятичном
представлении, вместо того чтобы использовать DNS
и конвертировать адреса в имена, а также печатает
номера портов вместо имен сервисов. Опция <a NAME="t11C033"></a>-f inet сообщает только о точках TCP и UDP. </small></p>

<p><small>Локальный адрес напечатан как *.7777, где
звездочка означает, что в качестве локального IP
адреса может быть подставлен любой адрес.</small></p>

<p><small>Когда сервер создает свою конечную точку,
он может указать один из локальных IP адресов
хоста, включая один из его широковещательных
адресов в качестве локального IP адреса конечной
точки. При этом входящая UDP датаграмма будет
передана на конечную точку только в том случае,
если IP адрес назначения совпадет с указанным
локальным адресом. С помощью программы sock можно
указать IP адрес перед номером порта, и этот IP
адрес становится локальным IP адресом для
конечной точки. Например,</small></p>

<p>&nbsp;</p>


<p>sun % <b>sock -u -s 140.252.1.29 7777</p>
</b>

<p>&nbsp;</p>

<p><small>из датаграмм, прибывающих на SLIP интерфейс,
выбирает датаграммы с адресом 140.252.1.29. Вывод
команды <a NAME="t11C034"></a>netstat будет выглядеть
следующим образом:</small></p>

<p>&nbsp;</p>


<p><br>
Proto Recv-Q Send-Q&nbsp;&nbsp; Local Address
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Foreign Address
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (state)<br>
udp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp; 140.252.1.29.7777&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *.*<br>
</p>


<p>&nbsp;</p>

<p><small>Если мы постараемся послать на этот сервер
датаграмму с хоста bsdi, адрес которого 140.252.13.35, по
Ethernet, вернется ICMP ошибка о <a NAME="t11C035"></a>недоступности
порта. Сервер никогда не увидит эту датаграмму.
На рисунке 11.21 это показано более подробно.<a NAME="t11C036"></a></small></p>

<p>&nbsp;</p>


<p><br>
1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1723
&gt; sun.7777: udp 13<br>
2&nbsp; 0.000822 (0.0008)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun &gt; bsdi: icmp: sun udp port
7777 unreachable<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 11.21 Отказ обработки UDP датаграммы,
вызванный несовпадением локального адреса
сервера.</small></p>

<p>&nbsp;</p>

<p><small>Существует возможность запустить другие
сервера для этого же порта, каждый с собственным
локальным IP адресом. Однако, приложение должно
разрешить системе повторно использовать тот же
самый номер порта.</small></p>

<p>&nbsp;</p>


<p>Должна быть указана
опция <a NAME="t11C037"></a>сокета в API <a NAME="t11C038"></a>SO_REUSEADDR.
Это делается нашей программой <a NAME="t11C039"></a>sock с
помощью опции <a NAME="t11C040"></a>-A. </p>


<p>&nbsp;</p>

<p><small>На хосте sun мы можем стартовать пять
различных серверов на одном и том же UDP порте (8888):</small></p>

<p>&nbsp;</p>


<p><br>
sun % <b>sock -u -s 140.252.1.29 8888 </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; для
канала SLIP<br>
sun % <b>sock -u -s -A 140.252.13.33 8888 </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; для Ethernet<br>
sun % <b>sock -u -s -A 127.0.0.1 8888 </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; для
loopback интерфейса<br>
sun % <b>sock -u -s -A 140.252.13.63 8888 </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; для
широковещательных запросов Ethernet<br>
sun % <b>sock -u -s -A 8888 </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; для
всего остального (метасимволы в IP адресе)<br>
</p>


<p>&nbsp;</p>

<p><small>Ожидалось, что первый из серверов будет
запущен с флагом -A, который сообщает системе о
том, что можно повторно использовать тот же самый
номер порта. Вывод команды netstat показывает
следующие пять серверов:</small></p>

<p>&nbsp;</p>


<p><br>
Proto Recv-Q Send-Q&nbsp;&nbsp; Local Address
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Foreign Address
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (state)<br>
udp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp; *.8888
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *.*<br>
udp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp; 140.252.13.63.8888&nbsp;&nbsp;&nbsp; *.*<br>
udp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp; 127.0.0.1 8888&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *.*<br>
udp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp; 140.252.13.33 8888&nbsp;&nbsp;&nbsp; *.*<br>
udp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp; 140.252.1.29 8888&nbsp;&nbsp;&nbsp;&nbsp; *.*<br>
</p>


<p>&nbsp;</p>

<p><small>В этом сценарии только датаграммы,
направляющиеся на адрес 140.252.1.255, будут попадать
на сервер с символами подстановки, используемыми
в качестве локального IP адреса, потому что другие
четыре сервера охватывают все возможные адреса. </small></p>

<p><small>При использовании подстановки IP адресов
используется система приоритетов. Конечная
точка с указанным IP адресом, который совпадает с
IP адресом назначения, всегда будет выбрана
раньше, чем адрес с символами подстановки.
Конечная точка с символами подстановки
используется только в том случае, когда не
найдено совпадение с указанным адресом.</small></p>
<i><b>

<p><a NAME="t11C041"></a>Ограничение внешних IP адресов</p>
</b></i>

<p><small>Во всех выводах команды <a NAME="t11C042"></a>netstat,
которую мы показывали ранее, удаленные IP адреса и
удаленные номера портов показаны как *.*. Это
означает, что конечная точка воспримет входящие
UDP датаграммы с любого IP адреса и любого номера
порта. В большинстве реализаций конечным точкам
UDP позволяется ограничивать удаленные адреса. </small></p>

<p><small>Другими словами, конечная точка может
воспринимать только UDP датаграммы от указанного
IP адреса и номера порта. Наша программа sock
использует опцию <a NAME="t11C043"></a>-f, чтобы указать
удаленный IP адрес и номер порта:</small></p>

<p>&nbsp;</p>


<p>sun % <b>sock -u -s -f
140.252.13.35.4444 5555</p>
</b>

<p>&nbsp;</p>

<p><small>При этом удаленный IP адрес устанавливается
в 140.252.13.35 (наш хост bsdi), а удаленный номер порта в
4444. Заранее-известный порт сервера 5555. Если мы
запустим netstat, то увидим, что локальный IP адрес
также установлен, даже если мы не указывали его
непосредственно:</small></p>

<p>&nbsp;</p>


<p><br>
Proto Recv-Q Send-Q&nbsp;&nbsp; Local Address
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Foreign Address
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (state)<br>
udp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp; 140.252.13.33.5555&nbsp;&nbsp;&nbsp; 140.252.13.35.4444<br>
</p>


<p>&nbsp;</p>

<p><small>Это побочный эффект указания удаленного IP
адреса и удаленного номера порта в системах Berkeley:
если локальный IP адрес не был выбран при
установке удаленного адреса, локальный адрес
выбирается автоматически. В качестве локального
IP адреса устанавливается IP адрес интерфейса,
который выбирается с помощью IP маршрутизации для
достижения указанного удаленного IP адреса. И
действительно, в этом примере IP адрес sun для Ethernet,
который подключен к удаленному адресу, это
140.252.13.33. </small></p>

<p><small>На рисунке 11.22 приведены три типа адресов и
портов, которые UDP сервер может установить для
самого себя.<a NAME="t11C044"></a></small></p>

<p>&nbsp;</p>


<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="715">
  <tr>
    <td WIDTH="20%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Локальный
    адрес</small></td>
    <td WIDTH="21%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Удаленный
    адрес</small></td>
    <td WIDTH="59%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small>Описание</small></td>
  </tr>
  <tr>
    <td WIDTH="20%" VALIGN="TOP"><p ALIGN="CENTER"><small>localIP.lport</small></td>
    <td WIDTH="21%" VALIGN="TOP"><p ALIGN="CENTER"><small>foreignIP.fport</small></td>
    <td WIDTH="59%" VALIGN="TOP"><small>ограничено одним
    клиентом</small></td>
  </tr>
  <tr>
    <td WIDTH="20%" VALIGN="TOP"><p ALIGN="CENTER"><small>localIP.lport</small></td>
    <td WIDTH="21%" VALIGN="TOP"><p ALIGN="CENTER"><small>*.*</small></td>
    <td WIDTH="59%" VALIGN="TOP"><small>ограничено
    датаграммами, прибывающими с одного локального
    интерфейса: localIP</small></td>
  </tr>
  <tr>
    <td WIDTH="20%" VALIGN="TOP"><p ALIGN="CENTER"><small>*.lport</small></td>
    <td WIDTH="21%" VALIGN="TOP"><p ALIGN="CENTER"><small>*.*</small></td>
    <td WIDTH="59%" VALIGN="TOP"><small>принимает все
    датаграммы, посланные на lport</small></td>
  </tr>
</table>


<p><small>Рисунок 11.22 Указание локального и
удаленного IP адресов и номера порта для UDP
сервера.</small></p>

<p>&nbsp;</p>

<p><small>Во всех случаях lport это заранее-известный
порт сервера, а localIP должен быть IP адресом
локального интерфейса. Порядок, в котором
расположены три строки на рисунке 11.22, показывает
тот порядок, в котором UDP модуль старается
определить, на которую локальную конечную точку
принята входящая датаграмма. Наиболее жесткая
связь адреса с портом (первая строка) выбирается
в первую очередь, а менее жесткая (последняя
строка, где и IP адрес, и номер порта указаны в виде
метасимволов) выбирается последней.</small></p>
<i><b>

<p><a NAME="t11C045"></a>Множественный прием на порт</p>
</b></i>

<p><small>Несмотря на то, что это не описано в RFC,
большинство реализаций позволяют только одному
приложению в одно и то же время быть связанным с
одним локальным адресом и номером UDP порта. Когда
UDP датаграмма прибывает на хост назначения на
свой IP адрес и номер порта, одна копия
доставляется в единственную конечную точку. IP
адрес конечной точки может быть представлен в
виде символов подстановки, как было показано
ранее.</small></p>

<p><small>Например, в <a NAME="t11C046"></a>SunOS 4.1.3 мы стартовали
один сервер на порт 9999 с локальным IP адресом в
виде символов подстановки: </small></p>

<p>&nbsp;</p>


<p>sun % <b>sock -u -s 9999</p>
</b>

<p>&nbsp;</p>

<p><small>Если затем попробовать стартовать еще один
сервер с тем же локальным адресом в виде символов
подстановки и с тем же портом, это не сработает,
даже если мы укажем опцию <a NAME="t11C047"></a>-A:</small></p>

<p>&nbsp;</p>


<p>sun % <b>sock -u -s 9999 </b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; так
получиться не должно<br>
can't bind local address: Address already in use<br>
<br>
sun % <b>sock -u -s -A 9999 </b>&nbsp;&nbsp;&nbsp;&nbsp; поэтому мы
указали флаг -A<br>
can't bind local address: Address already in use<br>
</p>


<p>&nbsp;</p>

<p><small>Для систем, которые поддерживают групповую
адресацию (см. <a HREF="tcp12.html">главу 12</a>), все обстоит
иначе. Несколько конечных точек могут
использовать один и тот же локальный адрес и
номер UDP порта, однако приложение должно сообщить
API, что это допустимо (флаг -A использует опцию
сокета <a NAME="t11C048"></a>SO_REUSEADDR). </small></p>

<p>&nbsp;</p>


<p><a NAME="t11C049"></a>4.4BSD,
которая поддерживает групповую адресацию,
требует, чтобы приложение установило другую
опцию сокета (<a NAME="t11C050"></a>SO_REUSEPORT), чтобы
позволить нескольким конечным точкам делить
один и тот же порт. Более того, каждая конечная
точка должна указать эту опцию, включая первую
конечную точку, которая использует этот порт.</p>


<p>&nbsp;</p>

<p><small>Когда UDP датаграмма прибывает на свой IP
адрес назначения, который является
широковещательным или групповым адресом, при
этом с этим IP адресом и номером порта связано
несколько конечных точек, копия входящей
датаграммы направляется каждой конечной точке.
(Локальный IP адрес конечной точки может быть
указан в виде символов подстановки, при этом он
совпадет с любым IP адресом назначения.) Однако,
если у прибывшей IP датаграммы IP адрес назначения
- персональный адрес, только одна копия
датаграммы доставляется в одну конечную точку.
Которая конечная точка получит датаграмму с
персональным адресом, зависит от реализации.</small></p>
<u><b>

<p><a NAME="t11D000"></a>Краткие выводы</p>
</b></u>

<p><small>UDP это простой протокол. Официальная
спецификация RFC 768 [<a NAME="t11D014"></a>Postel 1980] состоит
всего лишь из трех страниц. Сервисы, которые он
предоставляет пользовательским процессам,
находящиеся над и позади <a NAME="t11D002"></a>IP, это
номера портов и необязательные контрольные
суммы. Мы использовали UDP, чтобы просмотреть
расчет контрольных сумм и посмотреть, как
осуществляется фрагментация. </small></p>

<p><small>Затем мы рассмотрели ICMP ошибку о
недоступности, которая является частью новой
характеристики определения транспортного MTU (см.
главу 2, раздел <a HREF="tcp02.html#t029000">&quot;Транспортный
MTU&quot;</a>). Мы рассмотрели определение
транспортного MTU с использованием Traceroute и UDP.
Также рассмотрен процесс взаимодействия UDP и ARP. </small></p>

<p><small>Мы убедились, что ICMP ошибка подавления
источника может быть послана системой, которая
принимает IP датаграммы быстрее, чем может
обработать. Существует возможность легко
генерировать эти ICMP ошибки с использованием UDP.</small></p>
<i><b>

<p><a NAME="t11D001"></a>Упражнения</b></i> 

<ol>
  <li>В разделе <a HREF="#t115000">&quot;Фрагментация
    IP&quot;</a> этой главы мы вызвали фрагментацию в <a NAME="t11D003"></a>Ethernet, записав UDP датаграмму с размером
    пользовательских данных в 1473 байта. Какой
    наименьший размер пользовательских данных может
    вызвать фрагментацию в Ethernet, если используется <a NAME="t11D004"></a>инкапсуляция IEEE 802 (глава 2, раздел <a HREF="tcp02.html#t022000">&quot;Ethernet и IEEE 802 инкапсуляция&quot;</a>)?</li>
  <li>Прочитайте RFC 791 [<a NAME="t11D005"></a>Postel 1981a] и скажите,
    почему все фрагменты кроме последнего должны
    иметь длину кратную 8 байтам.</li>
  <li>Представьте себе Ethernet и UDP датаграмму с 8192
    байтами пользовательских данных. Сколько
    фрагментов будет передано и какова будет длина
    смещения для каждого фрагмента?</li>
  <li>Продолжая предыдущий пример, представьте себе,
    что эти датаграммы затем передаются в SLIP канал с
    MTU равным 552. Вам необходимо помнить, что
    количество данных в каждом фрагменте (все кроме IP
    заголовка) должно быть кратно 8 байтам. Сколько
    фрагментов передано и каковы смещение и длина
    каждого фрагмента?</li>
  <li><a NAME="t11D006"></a>Приложение, использующее UDP,
    посылает датаграмму, которая фрагментирована на
    4 части. Представьте себе, что фрагменты 1 и 2
    достигли своего пункта назначения, тогда как
    фрагменты 3 и 4 были потеряны. Приложение
    отрабатывает тайм-аут, а затем, через 10 секунд,
    повторяет передачу UDP датаграммы. Эта датаграмма
    фрагментируется точно так же, как и при первой
    передаче (то же смещение и та же длина). Теперь
    представьте, что фрагменты 1 и 2 потеряны, однако
    фрагменты 3 и 4 достигли своего пункта назначения.
    <a NAME="t11D007"></a>Таймер повторной сборки на
    принимающем хосте установлен в 60 секунд, поэтому
    когда фрагменты 3 и 4 прибыли на конечный пункт
    назначения, фрагменты 1 и 2 из первой передачи еще
    не были отброшены. Может ли получатель собрать IP
    датаграмму из этих четырех фрагментов?</li>
  <li>Как Вы можете узнать, что фрагменты на рисунке
    11.15 действительно соответствуют строкам 5 и 6 на
    рисунке 11.14?</li>
  <li><a NAME="t11D008"></a>После того как хост gemini работал 33
    дня, программа netstat показала, что 129 IP датаграмм из
    48 миллионов были отброшены из-за несовпадения
    контрольной суммы заголовка, а 20 сегментов из 30
    миллионов сегментов TCP были отброшены из-за
    несовпадения контрольной суммы TCP. Однако,
    примерно из 18 миллионов UDP датаграмм ни одна не
    была отброшена по причине ошибки в контрольной
    сумме UDP. Приведите минимум две причины, почему
    это могло произойти. (Подсказка: см. рисунок 11.4.)</li>
  <li>В нашем описании фрагментации мы ни разу не
    упомянули, что происходит с <a NAME="t11D009"></a>IP опциями
    в IP заголовке - либо они копируются как часть IP
    заголовка в каждый фрагмент, либо остаются
    только в первом фрагменте? Мы описали следующие
    опции: <a NAME="t11D010"></a>запись маршрута (глава 7,
    раздел <a HREF="tcp07.html#t073000">&quot;Опция записи IP
    маршрута&quot;</a>), <a NAME="t11D011"></a>временная марка
    (глава 7, раздел <a HREF="tcp07.html#t074000">&quot;IP опция
    временной марки&quot;</a>), <a NAME="t11D012"></a>жесткая и
    свободная маршрутизация от источника (глава 8,
    раздел <a HREF="tcp08.html#t085000">&quot;Опция IP маршрутизации
    от источника&quot;</a>). Как Вы считаете, как при
    фрагментации обрабатываются эти опции?
    Сопоставьте Ваш ответ с RFC 791.</li>
  <li>На <a HREF="tcp01.html#t017001">рисунке 1.8</a> мы сказали, что
    входящие IP датаграммы <a NAME="t11D013"></a>демультиплексируются
    на основе номера порта назначения UDP. Правильно
    ли это?</li>
</ol>

<hr>

</body>
</html>

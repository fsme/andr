<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
   <TITLE>Введение</TITLE>


<meta http-equiv="Content-type" content="text/html; charset=koi8-r">
<link rel="stylesheet" type="text/css" href="style.css">
</HEAD>
<body>
<P><A NAME="t010000"></A>Глава 1 Введение
<P><A NAME="t011000"></A><B><U>Введение</U></B>
<P>Семейство протоколов TCP/IP работает
на любых моделях компьютеров, произведенных различными производителями
компьютерной техники и работающих под управлением различных операционных
систем. С помощью протоколов TCP/IP можно объединить практически любые
компьютеры. И что самое удивительное, сегодняшние реализации протокола
TCP/IP очень далеки от того, как он задумывался исходно. В конце 60-х годов
начался исследовательский проект, финансируемый правительством США, по
разработке сети пакетной коммутации, а в 90-х годах результаты этих исследований
превратились в наиболее широко используемую форму сетевого взаимодействия
между компьютерами. В настоящее время это действительно&nbsp;<A NAME="t011001"></A>открытая
система, а именно, семейство протоколов и большое количество бесплатных
реализаций (либо достаточно дешевых). Они составляют основу того, что в
настоящее время называется словом&nbsp;<A NAME="t011002"></A>Internet.
<P>В этой главе мы познакомимся с семейством
протоколов TCP/IP, для того чтобы подойти к чтению следующих глав более
или менее подготовленными. Чтобы познакомиться с ранней историей разработки
TCP/IP, можно обратиться к<A NAME="t012004"></A> <A HREF="tcp_g.html#t370175">[Lynch
1993]</A>.
<P><A NAME="t012000"></A><B><U>Уровни</U></B>
<P>Сетевые протоколы обычно разрабатываются
по уровням, причем каждый уровень отвечает за собственную фазу коммуникаций.&nbsp;<A NAME="t012001"></A>Семейства
протоколов, такие как TCP/IP, это комбинации различных протоколов на различных
уровнях.&nbsp;<A NAME="t012002"></A>TCP/IP состоит из четырех уровней,
как показано на рисунке 1.1.<A NAME="t012003"></A>
<BR>&nbsp;
<BR>&nbsp;
<BR>&nbsp;
<TABLE BORDER CELLPADDING=5 WIDTH="679" BORDERCOLOR="#000000" >
<TR>
<TD VALIGN=TOP WIDTH="37%">Прикладной</TD>

<TD VALIGN=TOP WIDTH="63%">Telnet, FTP, e-mail и т.д.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="37%">Транспортный</TD>

<TD VALIGN=TOP WIDTH="63%">TCP,UDP</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="37%">Сетевой</TD>

<TD VALIGN=TOP WIDTH="63%">IP, ICMP, IGMP</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="37%">Канальный</TD>

<TD VALIGN=TOP WIDTH="63%">драйвер устройства и интерфейсная
плата</TD>
</TR>
</TABLE>

<P>Рисунок 1.1 Четыре уровня протоколов
TCP/IP.
<BR>&nbsp;
<BR>&nbsp;
<P>Каждый уровень несет собственную функциональную
нагрузку.
<OL>
<LI>
Канальный уровень (link layer). Еще его
называют&nbsp;<A NAME="t012005"></A>уровнем сетевого интефейса. Обычно
включает в себя драйвер устройства в операционной системе и соответствующую
сетевую интерфейсную плату в компьютере. Вместе они обеспечивают аппаратную
поддержку физического соединения с сетью (с кабелем или с другой используемой
средой передачи).</LI>

<LI>
<A NAME="t012006"></A>Сетевой уровень
(network layer), иногда называемый уровнем межсетевого взаимодействия,
отвечает за передачу пакетов по сети. Маршрутизация пакетов осуществляется
именно на этом уровне. IP (Internet Protocol - протокол Internet), ICMP
(Internet Control Message Protocol - протокол управления сообщениями Internet)
и IGMP (Internet Group Management Protocol - протокол управления группами
Internet) обеспечивают сетевой уровень в семействе протоколов TCP/IP.</LI>

<LI>
<A NAME="t012007"></A>Транспортный уровень
(transport layer) отвечает за передачу потока данных между двумя компьютерами
и обеспечивает работу прикладного уровня, который находится выше. В семействе
протоколов TCP/IP существует два транспортных протокола: TCP (Transmission
Control Protocol) и UDP (User Datagram Protocol). TCP осуществляет надежную
передачу данных между двумя компьютерами. Он обеспечивает деление данных,
передающихся от одного приложения к другому, на пакеты подходящего для
сетевого уровня размера, подтверждение принятых пакетов, установку тайм-аутов,
в течение которых должно прийти подтверждение на пакет, и так далее. Так
как надежность передачи данных гарантируется на транспортном уровне, на
прикладном уровне эти детали игнорируются. UDP предоставляет более простой
сервис для прикладного уровня. Он просто отсылает пакеты, которые называются&nbsp;<A NAME="t012008"></A>датаграммами
(datagram) от одного компьютера к другому. При этом нет никакой гарантии,
что датаграмма дойдет до пункта назначения. За надежность передачи данных,
при использовании датаграмм отвечает прикладной уровень. Для каждого транспортного
протокола существуют различные приложения, которые их используют.</LI>

<LI>
<A NAME="t012009"></A>Прикладной уровень
(application layer) определяет детали каждого конкретного приложения. Существует
несколько распространенных приложений TCP/IP, которые присутствуют практически
в каждой реализации:</LI>
</OL>

<UL>
<DIR>
<DIR>
<UL>
<LI>
Telnet - удаленный терминал</LI>

<LI>
FTP, File Transfer Protocol - протокол
передачи файлов</LI>

<LI>
SMTP, Simple Mail Transfer Protocol -
простой протокол передачи электронной почты</LI>

<LI>
SNMP, Simple Network Management Protocol
- простой протокол управления сетью.</LI>
</UL>
</DIR>
</DIR>
</UL>
Если у нас есть два компьютера в&nbsp;<A NAME="t012010"></A>локальной
сети, (например, Ethernet) и на обоих запущен FTP, то данные протоколы
будут работать так, как показано на рисунке 1.2.<A NAME="t012011"></A>
<BR>&nbsp;
<P><BR>
<CENTER>
<P><IMG SRC="t1_2_200.jpg" HEIGHT=313 WIDTH=483>
<P>Рисунок 1.2 Два хоста в локальной сети
с работающим FTP.</CENTER>

<BR>&nbsp;
<P><BR>
<BR>
<BR>
<P>Мы пометили один квадратик на прикладном
уровне как FTP&nbsp;<A NAME="t012012"></A>клиент, а другой как FTP&nbsp;<A NAME="t012013"></A>сервер.
Большинство сетевых приложений работают именно таким образом, то есть,
на одном конце клиент, а на другом сервер. Сервер предоставляет некоторые
типы сервиса клиентам. В данном случае это доступ к файлам на сервере.
Telnet предоставляет сервис, позволяющий клиенту зайти на сервер удаленным
терминалом.
<P>Каждый уровень имеет один или несколько
протоколов, который позволяет общаться с удаленным узлом на том же уровне.
Один протокол, например, позволяет общаться двум TCP уровням, а другой
протокол обеспечивает коммуникации между двумя IP уровнями.
<P>С правой стороны на рисунке 1.2 мы
видим, что прикладной уровень обеспечивается пользовательским процессом,
тогда как три нижних уровня обычно встроены в ядро операционной системы.
Несмотря на то, что возможны и другие способы реализации, во всех UNIX
системах все построено именно по такому принципу.
<P>Существует еще одно отличие между верхним
уровнем и тремя нижними уровнями, приведенными на рисунке 1.2. Прикладной
уровень обычно является приложением и взаимодействует с пользователем,
а не занимается передачей данных по сети. Три нижних уровня ничего не знают
о работающих над ними приложениях, однако отвечают за все детали коммуникаций.
<P>На рисунке 1.2 мы показали четыре протокола,
каждый на своем уровне. FTP это протокол прикладного уровня, TCP - протокол
транспортного уровня, IP - протокол сетевого уровня, а протоколы Ethernet
обеспечивают канальный уровень. Семейство протоколов TCP/IP объединяет
в себе множество протоколов, однако наиболее часто используемые названия
для данного семейства это TCP/IP, TCP и IP (иногда семейство называют Семейство
Протоколов Internet).
<P>Цели, решаемые сетевым и прикладным
уровнями, различны - первый обеспечивает взаимодействие с различными средами
передачи (Ethernet, Token ring, и т.д.), второй работает с конкретными
пользовательскими приложениями (FTP, Telnet, и т.д.). На первый взгляд,
разница между сетевым и транспортным уровнями достаточно туманна. На основании
чего между ними проводится разграничение? Чтобы понять это, мы рассмотрим
не одну отдельно взятую сеть, а несколько сетей.
<P>Одной из причин феноменального роста
сетевых технологий в течение 80-х годов явилось понимание того, что отдельно
стоящий компьютер практически бесполезен. Несколько отдельных систем были
объединены вместе в сеть. Однако, как выяснилось позже, а именно в 90-х
годах, отдельно стоящая сеть также практически бесполезна. Поэтому люди
начали объединять сети вместе. Именно результат такого объединения получил
название internet (межсетевое взаимодействие).&nbsp;<A NAME="t012014"></A>internet
это несколько объединенных сетей, которые используют одно и то же семейство
протоколов.
<P>Наиболее простой путь осуществить межсетевое
взаимодействие - это объединить две или более сетей с помощью&nbsp;<A NAME="t012015"></A>маршрутизатора.
Как правило, маршрутизатор представляет из себя аппаратное устройство.
Огромное достоинство маршрутизаторов заключается в том, что они могут объединить
сети, построенные на различных физических принципах: Ethernet, Token ring,
point-to-point,&nbsp;<A NAME="t012016"></A>FDDI (Fiber Distributed Data
Interface), и так далее.
<P>Эти устройства
также иногда называются&nbsp;<A NAME="t012017"></A>IP маршрутизаторами
(IP router), однако мы будем использовать термин маршрутизатор (router).
<P>Исторически эти
устройства назывались&nbsp;<A NAME="t012018"></A>шлюзами (gateway), и этот
термин до сих пор широко используется в литературе о TCP/IP. Сегодня чаще
всего термин шлюз используется для обозначения шлюза между&nbsp;<A NAME="t012019"></A>приложениями:
процесс, который объединяет два различных семейства протоколов (скажем,
TCP/IP и IBM SNA) в одном конкретном приложении (чаще всего это электронная
почта или передача файлов).
<P>На рисунке 1.3 показано объединение
двух сетей: Ethernet и Token ring с помощью маршрутизатора. Несмотря на
то что мы показали связь только между двумя компьютерами, подсоединенными
к маршрутизатору из разных сетей, любой компьютер в Ethernet может общаться
с любым компьютером в Token ring.
<P>На рисунке 1.3 мы также можем проследить
разницу между&nbsp;<A NAME="t012020"></A>конечной системой (end system),
в данном случае это два компьютера на каждой стороне, и&nbsp;<A NAME="t012021"></A>промежуточной
системой (intermediate system), в данном случае это маршрутизатор в середине.
Прикладной и транспортный уровни используют протоколы,&nbsp;<A NAME="t012022"></A>ориентированные
на соединение (end-to-end). На рисунке эти два уровня используются только
конечными системами. Сетевой уровень, однако, использует протокол, не требующий
соединения (<A NAME="t012023"></A>пересылка-за-пересылкой - hop-by-hop),
он используется в данном случае двумя конечными системами и каждой промежуточной
системой.&nbsp;<A NAME="t012024"></A>
<BR>&nbsp;
<P><BR>
<CENTER>
<P><IMG SRC="t1_3_200.jpg" HEIGHT=298 WIDTH=439>
<P>Рисунок 1.3 Две сети, соединенные через
маршрутизатор.</CENTER>

<BR>&nbsp;
<P><BR>
<BR>
<BR>
<P>В семействе протоколов TCP/IP сетевой
уровень - IP. Он предоставляет&nbsp;<A NAME="t012025"></A>ненадежный сервис.
Это означает, что в процессе своей работы протокол передает пакет от источника
к пункту назначения, однако не предоставляет никаких гарантий того, что
пакет дойдет по назначению. TCP, с другой стороны, предоставляет надежный
транспортный уровень, который пользуется ненадежным сервисом IP. Чтобы
обеспечить подобный сервис, TCP выставляет тайм-ауты и осуществляет повторные
передачи, отсылает и принимает подтверждения и так далее. Транспортный
уровень и сетевой уровень несут различную ответственность за передачу данных.
<P>Маршрутизатор, по определению, имеет
два или несколько интерфейсов сетевого уровня (если он объединяет две или
более сетей). Любая система с несколькими интерфейсами называется&nbsp;<A NAME="t012026"></A>многоинтерфейсной
(multihomed). Компьютер, имеющий несколько интерфейсов, но не перенаправляющий
пакеты с одного интерфейса на другой, не может называться маршрутизатором.
Большинство реализаций TCP/IP позволяют компьютерам с несколькими интерфейсами
функционировать в качестве маршрутизаторов. Однако компьютеры должны быть
специально сконфигурированы, чтобы решать задачи маршрутизации. Таким образом,
мы можем называть систему хостом, когда на нем работают такие приложения
как FTP или Telnet, или маршрутизатором, когда он осуществляет передачу
пакетов из одной сети в другую. В зависимости от того какие функции выполняются
компьютером, мы будем использовать тот или иной термин.
<P>Одна из основных задач объединения
сетей заключается в том, чтобы скрыть все детали физического процесса передачи
информации между приложениями, находящимися в разных сетях. Поэтому нет
ничего удивительного в том, что в объединенных сетях, как, например, на
рисунке 1.3, прикладные уровни не заботятся (и не должны заботиться) о
том, что один компьютер находится в сети Ethernet, а другой в сети Token
ring с маршрутизатором между ними. Даже если бы между сетями было 20 маршрутизаторов
и различные типы физического соединения, приложения работали бы точно так
же. Подобная концепция, при которой детали физического объединения сетей
скрыты от приложений, определяет мощность и гибкость такой технологии объединения
сетей.
<P>Существует еще один метод объединения
сетей - с помощью&nbsp;<A NAME="t012027"></A>мостов (bridge). В этом случае
сети объединяются на канальном уровне, тогда как маршрутизаторы объединяют
сети на сетевом уровне.
<P>Стоит отметить, что объединение TCP/IP
сетей осуществляется в основном с помощью маршрутизаторов, а не с помощью
мостов. Поэтому мы более подробно рассмотрим маршрутизаторы. В главе 12<A NAME="t012028"></A>
<A HREF="tcp_g.html#t370223">[Perlman 1992]</A> сравниваются маршрутизаторы
и мосты.
<P><A NAME="t013000"></A><B><U>Уровни
TCP/IP</U></B>
<P>В действительности, семейство протоколов
TCP/IP объединяет значительно больше протоколов. На рисунке 1.4 показаны
некоторые дополнительные протоколы, которые мы рассмотрим в книге.<A NAME="t013001"></A>
<BR>&nbsp;
<P><BR>
<CENTER>
<P><A NAME="t1.4"></A><IMG SRC="t1_4_200.jpg" HEIGHT=472 WIDTH=480>
<P>Рисунок 1.4 Различные протоколы на
разных уровнях семейства протоколов TCP/IP.</CENTER>

<BR>&nbsp;
<P><BR>
<BR>
<BR>
<P>TCP и UDP - два основных протокола
транспортного уровня. Оба используют IP в качестве сетевого уровня.
<P>TCP предоставляет надежный транспортный
уровень, даже несмотря на то что он использует ненадежный сервис IP. В
главах <A HREF="tcp17.htm">17</A>, <A HREF="tcp18.htm">18</A>, <A HREF="tcp19.html">19</A>,
<A HREF="tcp20.htm">20</A>, <A HREF="tcp21.htm">21</A> и <A HREF="tcp22.html">22</A>
мы подробно рассмотрим функционирование TCP. Затем мы рассмотрим некоторые
приложения TCP: Telnet и Rlogin в <A HREF="tcp26.html">главе 26</A>, FTP
в <A HREF="tcp27.htm">главе 27</A> и SMTP в <A HREF="tcp28.html">главе 28</A>.
Приложения - это, как правило, пользовательские процессы.
<P>UDP отправляет и принимает&nbsp;<A NAME="t013002"></A>датаграммы
(datagram). Датаграмма это блок информации (определенное количество байт
информации, которое указывается отправителем), который отправляется от
отправителя к приемнику. В отличие от TCP, UDP является ненадежным протоколом.
Не существует гарантий, что датаграмма достигнет конечной точки назначения.
В <A HREF="tcp11.htm">главе 11</A> мы рассмотрим UDP, а затем в <A HREF="tcp14.html">главе
14</A> - систему имен доменов (Domain Name System), в <A HREF="tcp15.html">главе
15</A> - простой протокол передачи файлов (Trivial File Transfer Protocol)
и в <A HREF="tcp16.html">главе 16</A> - протокол загрузки (Bootstrap Protocol).
Это приложения, которые используют UDP. SNMP (Простой протокол управления
сетью - Simple Network Management Protocol) также использует UDP, однако
он работает с некоторыми другими протоколами, которые мы будем рассматривать
вплоть до <A HREF="tcp25.html">главы 25</A>.
<P>IP это основной протокол сетевого уровня.
Он используется как TCP, так и UDP. Каждый блок информации TCP и UDP, который
передается по объединенным сетям, проходит через IP уровень в каждой конечной
системе и в каждом промежуточном маршрутизаторе. На рисунке 1.4 показаны
приложения, которые имеют прямой доступ к IP. Такой доступ используется
довольно редко, но существует возможность его осуществить (некоторые ранние
протоколы маршрутизации были разработаны именно подобным образом). Также
в процессе экспериментов при создании новых транспортных уровней используется
возможность доступа к протоколу IP. В <A HREF="tcp03.html">главе 3</A> рассматривается
протокол IP, более подробно IP рассматривается в последующих главах. В
<A HREF="tcp09.htm">главе 9</A> и <A HREF="tcp10.html">главе 10</A> рассказывают
о том как осуществляется IP маршрутизация.
<P>ICMP является дополнением к протоколу
IP. Он используется IP уровнем для обмена сообщениями об ошибках и другой
жизненно важной информацией уровня IP. <A HREF="tcp06.html">Глава 6</A>
рассказывает об ICMP более подробно. Несмотря на то, что ICMP используется
в основном IP уровнем, приложения также могут получить доступ к ICMP. Мы
рассмотрим два наиболее популярных диагностических средства, Ping и Traceroute
(<A HREF="tcp07.htm">глава 7</A> и <A HREF="tcp08.html">глава 8</A>), использующих
ICMP.
<P>Протокол управления группами Internet
(IGMP - Internet Groupe Management Protocol), используется при групповой
адресации: при этом UDP датаграммы рассылаются нескольким получателям.
Мы опишем основные особенности широковещательной адресации (рассылка UDP
датаграмм каждому компьютеру в указанной сети) и групповой адресации в
<A HREF="tcp12.htm">главе 12</A>, а затем опишем сам IGMP в <A HREF="tcp13.html">главе
13</A>.
<P>Протокол определения адреса (ARP -
Address Resolution Protocol) и обратный протокол определения адреса (RARP
- Reverse Address Resolution Protocol) это специализированные протоколы,
используемые только с определенным типом сетевых интерфейсов (такие как
Ethernet и Token ring). Они применяются для преобразования формата адресов,
используемого IP уровнем в формат адресов, используемый сетевым интерфейсом.
Мы рассмотрим эти протоколы в <A HREF="tcp04.htm">главе 4</A> и <A HREF="tcp05.html">главе
5</A> соответственно.
<P><A NAME="t014000"></A><B><U>Адресация
Internet</U></B>
<P>Каждый интерфейс в объединенной сети
должен иметь уникальный&nbsp;<A NAME="t014004"></A>IP адрес. Эти адреса
представляют из себя тридцатидвухбитовые числа. Cуществует определенная
структура адреса&nbsp;<A NAME="t014002"></A>Internet. На рисунке 1.5 показано
5 классов адресов Internet.
<P>Эти 32-битные адреса обычно записываются
как 4 десятичных числа, по одному на каждый байт адреса. Такая форма записи
называется&nbsp;<A NAME="t014003"></A>"десятичной записью с точками" (dotted-decimal).
Например, адрес сети класса B может быть записан как 140.252.13.33.
<P>Определить класс адреса, или класс
сети, можно по первому числу в адресе. На рисунке 1.6 показаны различные
классы, причем первое число выделено.<A NAME="t014001"></A>
<BR>&nbsp;
<P><BR>
<CENTER>
<P><IMG SRC="t1_5_200.jpg" HEIGHT=342 WIDTH=451>
<P><A NAME="t014005"></A>Рисунок 1.5 Пять
классов адресов Internet.</CENTER>

<BR>&nbsp;
<P><BR>
<BR>&nbsp;&nbsp;
<CENTER><TABLE BORDER CELLPADDING=5 WIDTH="391" BORDERCOLOR="#000000" >
<TR>
<TD VALIGN=TOP BGCOLOR="#FFFFFF">
<CENTER>Класс</CENTER>
</TD>

<TD VALIGN=TOP BGCOLOR="#FFFFFF">
<CENTER>Диапазон</CENTER>
</TD>
</TR>

<TR>
<TD VALIGN=TOP>
<CENTER>A</CENTER>
</TD>

<TD>
<CENTER><B>0</B>.0.0.0 - <B>127</B>.255.255.255</CENTER>
</TD>
</TR>

<TR>
<TD VALIGN=TOP>
<CENTER>B</CENTER>
</TD>

<TD>
<CENTER><B>128</B>.0.0.0 - <B>191</B>.255.255.255</CENTER>
</TD>
</TR>

<TR>
<TD VALIGN=TOP>
<CENTER>C</CENTER>
</TD>

<TD>
<CENTER><B>192</B>.0.0.0 - <B>223</B>.255.255.255</CENTER>
</TD>
</TR>

<TR>
<TD VALIGN=TOP>
<CENTER>D</CENTER>
</TD>

<TD>
<CENTER><B>224</B>.0.0.0 - <B>239</B>.255.255.255</CENTER>
</TD>
</TR>

<TR>
<TD VALIGN=TOP>
<CENTER>E</CENTER>
</TD>

<TD>
<CENTER><B>240</B>.0.0.0 - <B>247</B>.255.255.255</CENTER>
</TD>
</TR>
</TABLE></CENTER>

<CENTER>Рисунок 1.6 Диапазоны IP адресов
в разных классах сетей.</CENTER>

<BR>&nbsp;
<P><BR>
<BR>
<BR>
<P>Здесь хотелось бы отметить, что хосты
с несколькими интерфейсами имеют несколько&nbsp;<A NAME="t014006"></A>IP
адресов: по одному на каждый интерфейс.
<P>Так как каждый интерфейс, подключенный
к сети, должен иметь уникальный адрес, встает вопрос распределения IP адресов
в глобальной сети&nbsp;<A NAME="t014007"></A>Internet. Этим занимается&nbsp;<A NAME="t014008"></A>сетевой
информационный центр (Internet Network Information Center или InterNIC).&nbsp;<A NAME="t014009"></A>InterNIC
назначает только сетевые идентификаторы (ID). Назначением идентификаторов
хостов в сети занимаются системные администраторы.
<BR>&nbsp;
<BR>&nbsp;
<P>Регистрация сервисов
Internet (IP адреса и имена доменов DNS) осуществляется в NIC,&nbsp;<A NAME="t014010"></A>nic.ddn.mil.
InterNIC была создана 1 апреля 1993 года. В настоящее время NIC регистрирует
сервисы только для сети министерства обороны (<A NAME="t014011"></A>DDN
- Defence Data Network). Все другие пользователи Internet в настоящее время
используют регистрационный сервис InterNIC в rs.internic.net.
<P>Реально существует
три части InterNIC: регистрационный сервис (rs.internic.net), сервис баз
данных (ds.internic.net) и информационный сервис (<A NAME="t014012"></A>is.internic.net).
См. <A HREF="#t01H001">Упражнение 8</A> главы 1.
<BR>&nbsp;
<BR>&nbsp;
<P>Существует три типа IP адресов:&nbsp;<A NAME="t014013"></A>персональный
адрес (unicast) - указывает на один хост,&nbsp;<A NAME="t014014"></A>широковещательный
адрес (broadcast) - указывает на все хосты в указанной сети, и&nbsp;<A NAME="t014015"></A>групповой
адрес (multicast) - указывает на группу хостов, принадлежащей к группе
адресации. В <A HREF="tcp12.htm">главе 12</A> и <A HREF="tcp13.html">главе
13</A> мы рассмотрим широковещательные и групповые запросы более подробно.
<P>В разделе <A HREF="tcp03.html#t034000">"Адресация
подсетей"</A> главы 3 мы продолжим описание IP адресации, включая подсети,
после того как опишем IP маршрутизацию. На <A HREF="tcp03.html#t3.9">рисунке
3.9</A> показаны особые случаи IP адресов: идентификатор хоста и идентификатор
сети, установленные во все нули или во все единицы.
<P><A NAME="t015000"></A><B><U>Система
имен доменов (DNS - Domain Name System)</U></B>
<P>Несмотря на то что каждый сетевой интерфейс
компьютера имеет свой собственный&nbsp;<A NAME="t015001"></A>IP адрес,
пользователи привыкли работать с именами хостов. Существует распределенная
мировая база данных TCP/IP, называемая системой имен доменов (DNS - Domain
Name System), которая позволяет установить соответствие между IP адресами
и именами хостов. В <A HREF="tcp14.html">главе 14</A> мы рассмотрим DNS
более подробно.
<P>А теперь мы должны быть уверены, что
любое приложение может вызвать функцию из стандартной библиотеки, для того
чтобы определить IP адрес (или адреса, соответствующие данному имени хоста).
Точно так же эта функция предоставляет возможность осуществить и обратную
процедуру, то есть по заданному IP адресу определить соответствующее имя
хоста.
<P>Большинство приложений, которые воспринимают
имя хоста в качестве аргумента, также воспринимают и IP адреса. Когда мы
используем Telnet, в <A HREF="tcp04.html">главе 4</A>, например, в одном
случае мы указываем имя хоста, а в другом случае - IP адрес.
<P><A NAME="t016000"></A><B><U>Инкапсуляция</U></B>
<P>Когда приложение посылает данные с
использованием TCP, данные опускаются вниз по стеку протоколов, проходя
через каждый уровень, до тех пор пока они не будут отправлены в виде потока
битов по сети. Каждый уровень добавляет свою информацию к данным путем
пристыковки заголовков (а иногда завершителей). На рисунке 1.7 показан
этот процесс. Блок данных, который TCP посылает в IP, называется&nbsp;<A NAME="t016007"></A>TCP
сегментом. Блок данных, который IP посылает в сетевой интерфейс, называется&nbsp;<A NAME="t016002"></A>IP
датаграммой. Поток битов, который передается по Ethernet, называется&nbsp;<A NAME="t016003"></A>фреймом
(frame).
<P>Числа, стоящие под заголовком и завершителем
Ethernet фрейма на рисунке 1.7, показывают стандартный размер заголовков
в байтах. В следующих разделах мы расскажем о заголовках более подробно.
<P>Одной из физических характеристик фрейма
Ethernet является та, что размер данных должен быть в диапазоне между 46
и 1500 байт. Минимальный размер мы обсудим в разделе <A HREF="tcp04.html#t045000">"Примеры
ARP"</A> главы 4, а максимальный в разделе <A HREF="tcp02.html#t028000">"MTU"</A>
главы 2.
<BR>&nbsp;
<BR>&nbsp;
<P>Все стандарты&nbsp;<A NAME="t016004"></A>Internet
и большинство книг про TCP/IP используют термин&nbsp;<A NAME="t016005"></A>октет
(octet) вместо слова байт. Такая терминология сложилась исторически, однако
мы будем использовать именно слово байт (byte).
<P>Чтобы быть максимально
точными, рассматривая рисунок 1.7, мы должны сказать, что блок данных,
передаваемый между IP и сетевым интерфейсом, называется&nbsp;<A NAME="t016006"></A>пакетом
(packet). Этот пакет может быть как IP датаграммой, так и фрагментом IP
датаграммы. Мы рассмотрим фрагментацию более подробно в разделе <A HREF="tcp11.html#t115000">"Фрагментация
IP"</A> главы 11.
<BR>&nbsp;
<BR>&nbsp;
<P>Что касается UDP данных, то картина
там практически идентичная. Единственное различие заключается в том, что
блок информации, который UDP передает в IP, называется UDP датаграммой,
а размер UDP заголовка составляет 8 байт.&nbsp;<A NAME="t016001"></A>
<BR>&nbsp;
<P><BR>
<CENTER>
<P><IMG SRC="t1_7_200.jpg" HEIGHT=444 WIDTH=468>
<P>Рисунок 1.7 Инкапсуляция данных, осуществляемая
по мере того, как они проходят по стеку протоколов.</CENTER>

<BR>&nbsp;
<P><BR>
<BR>
<BR>
<P>Снова обратимся к <A HREF="#t1.4">рисунку
1.4</A>, на котором показано как TCP, UDP, ICMP и IGMP посылают данные
в IP. IP должен добавить какой-либо идентификатор к IP заголовку, который
он генерирует, чтобы указать какому уровню принадлежат данные. IP делает
это путем сохранения восьмибитного значения в своем заголовке, которое
называется полем протокола. Это значение равно 1 для ICMP, 2 для IGMP,
6 для TCP и 17 для UDP.
<P>Точно так же различные приложения могут
использовать TCP или UDP в одно и то же время. Протоколы транспортного
уровня сохраняют в заголовке идентификатор приложения, которое их использует.
TCP и UDP оба используют шестнадцатибитный&nbsp;<A NAME="t016008"></A>номер
порта (port number), чтобы указать на приложения. TCP и UDP сохраняют номер
порта источника и номер порта назначения в своих заголовках.
<P>Сетевой интерфейс посылает и принимает
фреймы, принадлежащие IP, ARP и RARP. Должна существовать форма идентификации
в заголовке Ethernet, которая бы указывала, какой сетевой уровень сгенерировал
данные. Для этого существует шестнадцатибитное поле типа фрейма в заголовке
Ethernet.
<P><A NAME="t017000"></A><B><U>Демультиплексирование
(Demultiplexing)</U></B>
<P>Когда фрейм Ethernet принимается компьютером
приемником, он начинает свой путь вверх по стеку протоколов, при этом все
заголовки удаляются в соответствующих уровнях. Каждый протокол просматривает
определенные идентификаторы в заголовке, чтобы определить, какой следующий
верхний уровень должен получить данные. Этот процесс называется&nbsp;<A NAME="t017002"></A>демультиплексированием
(demultiplexing), он проиллюстрирован на рисунке 1.8.<A NAME="t017001"></A>
<BR>&nbsp;
<P><BR>
<CENTER>
<P><IMG SRC="t1_8_200.jpg" HEIGHT=425 WIDTH=536>
<P>Рисунок 1.8 Демультиплексирование полученного
Ethernet фрейма.</CENTER>

<BR>&nbsp;
<P><BR>
<BR>
<BR>
<P>Местоположение
квадратиков, помеченных именами протоколов "ICMP" и "IGMP", всегда различно.
На <A HREF="#t1.4">рисунке 1.4</A> мы показали их на том же уровне, что
и IP, потому что в действительности они являются дополнением к протоколу
IP. Однако здесь мы показали их выше чем IP, чтобы подчеркнуть то, что
сообщения ICMP и IGMP инкапсулируются в IP датаграммы.
<P>Тот же самый
подход был использован с квадратиками, помеченными "ARP" и "RARP". Здесь
мы показали их выше чем драйвер устройства Ethernet, потому что оба они
имеют свой собственный тип фреймов Ethernet, как IP датаграммы. Однако
на <A HREF="tcp02.html#t2.4">рисунке 2.4</A> мы покажем ARP как часть драйвера
устройства Ethernet, что будет более логично.
<P>Естественно,
что рисунки, иллюстрирующие протоколы и их взаимодействия, всегда несовершенны.
<BR>&nbsp;
<BR>&nbsp;
<P>Когда мы будем рассматривать TCP более
подробно, мы увидим, что в действительности демультиплексирование входящих
сегментов использует номер порта назначения, IP адрес источника и номер
порта источника.
<P><A NAME="t018000"></A><B><U>Модель
Клиент-Сервер</U></B>
<P>Большинство сетевых приложений написано
таким образом, что с одной стороны присутствует клиент, а с другой - сервер.
При этом сервер предоставляет определенные сервисы клиентам.
<P>Можно подразделить серверы на два класса:&nbsp;<A NAME="t018001"></A>последовательные
(iterative) и&nbsp;<A NAME="t018002"></A>конкурентные (concurrent). Последовательный
сервер функционирует следующим образом.
<BR>&nbsp;
<P><BR>
<CENTER>
<P><IMG SRC="t1_8_100.jpg" ALT="t1_8_1.jpg (18114 bytes)" HEIGHT=389 WIDTH=317>
<P>Рисунок 1.8.1 Алгоритм работы последоватеьного
сервера</CENTER>

<BR>&nbsp;
<P><BR>
<P>В процессе выполнения шага П2 могут
возникнуть проблема. Она заключается в том, что в это время никакие другие
клиенты не могут быть обслужены.
<P>Конкурентный сервер, с другой стороны,
работает следующим образом.
<BR>&nbsp;
<P><BR>
<CENTER>
<P><IMG SRC="t1_8_300.jpg" ALT="t1_8_3.jpg (15683 bytes)" HEIGHT=311 WIDTH=317>
<P>Рисунок 1.8.2 Алгоритм работы конкурентного
сервера</CENTER>

<BR>&nbsp;
<P><BR>
<P>Запуск нового сервера на шаге К2 для
обработки запроса клиента может выглядеть как создание нового процесса,
задачи, в зависимости от того какая операционная система лежит в основе
этого сервера. Новый сервер обрабатывает поступивший запрос клиента целиком.
По завершении сервер уничтожается.
<P>Преимущество конкурентного сервера
заключается в том, что он просто запускает другие сервера для обработки
запросов от клиентов. В подобном случае каждый клиент имеет собственный
сервер. Предполагается, что операционная система поддерживает многозадачность
и обслуживание нескольких клиентов одновременно.
<P>Мы подразделили именно сервера, а не
клиентов, специально, потому что в обычных условиях клиент не может сказать,
с каким сервером, последовательным или конкурирующим, он общается.
<P>В общем случае, серверы TCP - конкурентные,
а серверы UDP - последовательные. Однако из этого правила могут быть исключения.
Более подробно мы рассмотрим UDP серверы в разделе <A HREF="tcp11.html#t11C000">"Сервер
UDP"</A> главы 11, а TCP серверы - в разделе <A HREF="tcp18.html#t18B000">"Реализация
TCP сервера"</A> главы 18.
<P><A NAME="t019000"></A><B><U>Номера
портов</U></B>
<P>Как мы уже сказали, TCP и UDP идентифицируют
приложения с использованием 16-битных номеров порта. Рассмотрим, как выбираются
эти номера портов.
<P>Обычно серверы знают свои&nbsp;<A NAME="t019001"></A>заранее
известные (well-known) номера портов. Например, каждая реализация TCP/IP,
предоставляющая FTP сервер, знает, что сервисный порт TCP номер 21 зарезервирован
для FTP сервиса. Каждый Telnet сервер имеет порт номер 23. Каждая реализация
TFTP (Trivial File Transfer Protocol) использует UDP порт 69. Подобные
сервисы, предоставляемые в любой реализации TCP/IP, имеют заранее известные
номера портов в диапазоне от 1 до 1023. Заранее известные порты обслуживаются&nbsp;<A NAME="t019002"></A>Internet
Assigned Numbers Authority (IANA).
<BR>&nbsp;
<BR>&nbsp;
<P>До 1992 года
номера заранее известных портов находились в диапазоне от 1 до 255. Порты
между 256 и 1023 обычно использовались UNIX системами для специальных сервисов.
Эти сервисы присутствовали в UNIX системах, однако могли не присутствовать
в других операционных системах. В настоящее время IANA обслуживает порты
в диапазоне от 1 до 1023.
<P>В качестве примера
различия между Internet сервисом и специализированным UNIX сервисом можно
показать различие между Telnet и Rlogin. Оба позволяют осуществить терминальный
заход по сети на удаленный компьютер. Telnet это стандарт TCP/IP с номером
заранее известного порта 23. Он поддерживается практически во всех операционных
системах. Rlogin, с другой стороны, исходно был разработан в UNIX системах
(однако многие не UNIX системы в настоящее время также предоставляют этот
сервис). Однако заранее известный порт был выбран в начале 80-годов и установлен
в значение 513.
<BR>&nbsp;
<BR>&nbsp;
<P>Клиент обычно не заботится о том, какой
порт используется с его стороны. Все что ему необходимо, это быть уверенным,
что данный номер порта уникален на его компьютере. Номер порта клиента
называется&nbsp;<A NAME="t019003"></A>динамически назначаемым портом (ephemeral
port), то есть портом с коротким временем жизни. Это объясняется тем, что
клиент обычно существует ровно столько времени, сколько пользователь нуждается
в клиентском сервисе, тогда как сервера функционируют все время, пока запущен
компьютер.
<P><A NAME="t019004"></A>Большинство реализаций
TCP/IP располагают номера динамически назначаемых портов в диапазоне значений
между 1024 и 5000. Номера портов свыше 5000 предназначены для других серверов
(не зарезервированных в сети Internet) . Далее по тексту мы встретим множество
примеров того, как располагаются или назначаются динамически назначаемые
порты.
<BR>&nbsp;
<BR>&nbsp;
<P><A NAME="t019005"></A>Solaris
2.2 является исключением. По умолчанию, динамически назначаемые порты TCP
и UDP начинаются с 32768. В разделе <A HREF="tcp_e.html#t354000">"Solaris
2.2"</A> приложения E подробно рассматриваются опции конфигурирования,
которые могут быть модифицированы системным администратором, чтобы изменить
установки по умолчанию.
<BR>&nbsp;
<BR>&nbsp;
<P>В большинстве UNIX систем номера заранее
известных портов находятся в файле&nbsp;<A NAME="t019006"></A>/etc/services.
Чтобы найти номер порта для сервера Telnet и Domain Name System, можно
исполнить следующую команду:
<BR>&nbsp;
<BR>&nbsp;
<P>sun % <B>grep telnet /etc/services</B>
<BR>telnet 23/tcp используется порт
TCP 23
<BR>sun %<B> grep domain /etc/services</B>
<BR>domain 53/udp используются порты
UDP 53
<BR>domain 53/tcp и TCP порт 53
<BR>&nbsp;
<BR>&nbsp;
<P><A NAME="t019007"></A><B><I>Зарезервированные
порты</I></B>
<P>В Unix системах реализуется концепция
зарезервированных портов. Только процесс с привилегиями суперпользователя
может назначить себе зарезервированный порт.
<P><A NAME="t019008"></A>Эти номера портов
находятся в диапазоне от 1 до 1023 и используются некоторыми приложениями
(например, Rlogin, глава 26, раздел <A HREF="tcp26.html#t262000">"Протокол
Rlogin"</A>) для разграничения прав доступа при общении клиент-сервер.
<P><A NAME="t01A000"></A><B><U>Процесс
стандартизации</U></B>
<P>Кто контролирует семейство протоколов
TCP/IP, добавляет новые стандарты и так далее? Существует 4 группы, которые
несут ответственность за технологию&nbsp;<A NAME="t01A001"></A>Internet.
<P>&nbsp;
<OL>
<LI>
<A NAME="t01A002"></A>Internet Society
(ISOC) это сообщество профессионалов, которое отвечает за настройку и поддержку
роста Internet как мировой исследовательской коммуникационной инфраструктуры.</LI>

<LI>
<A NAME="t01A003"></A>Internet Architecture
Board (IAB) занимается технической координацией. Состоит примерно из 15
добровольцев по всему миру, которые отвечают за различные дисциплины и
являются последней инстанцией при принятии и оценке качества стандартов
Internet. IAB находится под управлением ISOC.</LI>

<LI>
<A NAME="t01A004"></A>Internet Engineering
Task Force (IETF) - группа, занимающаяся стандартами. Поделена на 9 зон
(приложения, маршрутизация и адресация, безопасность, и так далее). IETF
разрабатывает спецификации, которые становятся стандартами Internet. В
помощь IETF была сформирована группа&nbsp;<A NAME="t01A005"></A>Internet
Engineering Steering Group (IESG).</LI>

<LI>
<A NAME="t01A006"></A>Internet Research
Task Force (IRTF) занимается долговременными проектами.</LI>
</OL>

<P>IRTF и IETF находятся под управлением
IAB.<A NAME="t01A007"></A> <A HREF="tcp_g.html#t370066">[Crocker 1993]</A>
предоставляет дополнительную информацию о процессе стандартизации в рамках&nbsp;<A NAME="t01A008"></A>Internet.
<P><A NAME="t01B000"></A><B><U>RFC</U></B>
<P>Все официальные стандарты сообщества
internet публикуются в&nbsp;<A NAME="t01B001"></A>Request for Comment,
или в RFC. В дополнение, существует множество RFC, которые не являются
официальными стандартами, однако они публикуются с информационными целями.
Диапазон размеров RFC колеблется от 1 до почти 200 страниц. Каждый из них
имеет собственный номер.
<P>Все RFC доступны бесплатно по электронной
почте или с использованием FTP через Internet. Послать электронную почту
можно следующим образом:
<BR>&nbsp;
<BR>&nbsp;
<P>To: rfc-info@ISI.EDU
<BR>Subject: getting rfcs
<P>help: ways_to_get_rfcs
<BR>&nbsp;
<BR>&nbsp;
<P>после чего можно получить подробный
список возможных путей получения RFC.
<P>Начиная изучать какую-либо проблему,
наиболее полезным является просмотреть последние RFC. Для отслеживания
новых публикаций существует индекс RFC, который содержит подробную информацию
о том когда были заменены RFC на более новые и какая информация появилась
во вновь вышедших RFC.
<P>Существует несколько важных RFC.
<OL>
<LI>
<A NAME="t01B002"></A>Assigned Numbers
RFC содержит в себе все числа и константы, которые используются в протоколах
Internet. В настоящее время самая последняя версия этого RFC имеет номер
1340<A NAME="t01B003"></A> <A HREF="tcp_g.html#t370253">[Reynolds and Postel
1992]</A>. Также здесь описаны все заранее известные порты глобальной сети
Internet.</LI>

<P><BR>Когда RFC обновляется (обычно это
происходит ежегодно), список индексов для 1340 указывает, какой RFC заменил
его.
<LI>
Официальные стандарты протоколов Internet
(Internet Official Protocol Standards), в настоящее время RFC 1600<A NAME="t01B004"></A>
[Postel 1994]. Этот RFC содержит информацию о состоянии стандартизации
различных протоколов Internet. Каждый протокол имеет одно из следующих
состояний стандартизации: стандарт, необязательный стандарт, рекомендованный
стандарт, экспериментальный, информационный, или исторический. В дополнение,
каждый протокол имеет уровень необходимости: необходим, рекомендуется,
на выбор, с ограниченным использованием, или не рекомендуется.</LI>

<P><BR>Как и&nbsp;<A NAME="t01B005"></A>Assigned
Numbers RFC, этот RFC регулярно переиздается. При чтении этого RFC убедитесь,
что Вы используете последнюю копию.
<LI>
Требования к хостам&nbsp;<A NAME="t01B006"></A>Host
Requirements RFC, 1122 и 1123<A NAME="t01B007"></A> <A HREF="tcp_g.html#t370023">[Braden
1989a, 1989b]</A>. RFC 1122 описывает канальный уровень, сетевой уровень
и транспортный уровень, тогда как RFC 1123 описывает прикладной уровень.
Эти два RFC корректируют и интерпретируют различные важные RFC, вышедшие
раньше, и часто являются исходной точкой при изучении деталей того или
иного протокола. Список характеристик и конкретных подробностей протоколов
следующий: "должен", "следует", "может", "не следует" или "не должен".</LI>

<P><BR><A NAME="t01B008"></A> <A HREF="tcp_g.html#t370021">[Borman
1993b]</A> приводит практический взгляд на эти два RFC, а RFC 1127 <A HREF="tcp_g.html#tbr1989">[Braden
1989c]</A> содержит краткий информационный справочник дискуссий и выводов
в рабочих группах, которые разрабатывали Host Requirements RFC.
<LI>
Требования к маршрутизаторам&nbsp;<A NAME="t01B009"></A>Router
Requirements RFC. Официальная версия этого RFC - RFC 1009<A NAME="t01B010"></A>
<A HREF="tcp_g.html#t370033">[Braden and Postel 1987]</A>, однако новая
версия близка к завершению<A NAME="t01B011"></A> <A HREF="tcp_g.html#t370009">[Almquist
1993]</A>. Это RFC напоминает RFC требования к компьютерам, однако содержит
уникальные требования к маршрутизаторам.</LI>
</OL>
<A NAME="t01C000"></A><B><U>Стандартные
простые сервисы</U></B>
<P>Существует несколько стандартных простых
сервисов, которые присутствуют практически в каждой реализации. Мы используем
некоторые из этих сервисов по тексту, обычно с клиентом Telnet. Эти сервисы
описываются на рисунке 1.9. Можно заметить, что когда один и тот же сервис
предоставляется с использованием и TCP и UDP, оба номера порта обычно выбираются
одинаковыми.
<BR>&nbsp;
<BR>&nbsp;
<P>Если повнимательнее
посмотреть на номера портов этих и других стандартных сервисов TCP/IP (Telnet,
FTP, SMTP, и так далее), то можно заметить, что большинство из них имеют
нечетные номера. Так сложилось исторически, так как номера портов были
заимствованы от номеров портов NCP.&nbsp;<A NAME="t01C001"></A>Протокол
управления сетью (NCP - Network Control Protocol) предшествовал TCP в качестве
транспортного уровня для&nbsp;<A NAME="t01C002"></A>ARPANET. NCP был симплексный,
не&nbsp;<A NAME="t01C003"></A>полнодуплексный, каждое приложение требовало
двух соединений, поэтому пара четных-нечетных чисел в качестве номеров
портов, была зарезервирована для каждого приложения. Когда TCP и UDP стали
стандартными транспортными уровнями, на каждое приложение потребовался
один номер порта, поэтому в качестве номеров порта были использованы нечетные
номера портов NCP.<A NAME="t01C004"></A>
<BR>&nbsp;
<BR>&nbsp;
<BR>&nbsp;
<TABLE BORDER CELLPADDING=5 WIDTH="690" BORDERCOLOR="#000000" >
<TR>
<TD VALIGN=TOP WIDTH="15%" BGCOLOR="#FFFFFF">
<CENTER>Имя</CENTER>
</TD>

<TD VALIGN=TOP WIDTH="14%" BGCOLOR="#FFFFFF">
<CENTER>порт TCP</CENTER>
</TD>

<TD VALIGN=TOP WIDTH="15%" BGCOLOR="#FFFFFF">
<CENTER>порт UDP</CENTER>
</TD>

<TD VALIGN=TOP WIDTH="11%" BGCOLOR="#FFFFFF">
<CENTER>RFC</CENTER>
</TD>

<TD VALIGN=TOP WIDTH="45%" BGCOLOR="#FFFFFF">
<CENTER>Описание</CENTER>
</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="15%"><A NAME="t01C005"></A>echo</TD>

<TD VALIGN=TOP WIDTH="14%">
<CENTER>7</CENTER>
</TD>

<TD VALIGN=TOP WIDTH="15%">
<CENTER>7</CENTER>
</TD>

<TD VALIGN=TOP WIDTH="11%">
<CENTER>862</CENTER>
</TD>

<TD VALIGN=TOP WIDTH="45%">Сервер возвращает все посланное
клиентом</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="15%"><A NAME="t01C006"></A>discard</TD>

<TD VALIGN=TOP WIDTH="14%">
<CENTER>9</CENTER>
</TD>

<TD VALIGN=TOP WIDTH="15%">
<CENTER>9</CENTER>
</TD>

<TD VALIGN=TOP WIDTH="11%">
<CENTER>863</CENTER>
</TD>

<TD VALIGN=TOP WIDTH="45%">Сервер игнорирует все посланное
клиентом</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="15%"><A NAME="t01C007"></A>daytime</TD>

<TD VALIGN=TOP WIDTH="14%">
<CENTER>13</CENTER>
</TD>

<TD VALIGN=TOP WIDTH="15%">
<CENTER>13</CENTER>
</TD>

<TD VALIGN=TOP WIDTH="11%">
<CENTER>867</CENTER>
</TD>

<TD VALIGN=TOP WIDTH="45%">Сервер выдает время и дату
в читаемом формате</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="15%"><A NAME="t01C008"></A>chargen</TD>

<TD VALIGN=TOP WIDTH="14%">
<CENTER>19</CENTER>
</TD>

<TD VALIGN=TOP WIDTH="15%">
<CENTER>19</CENTER>
</TD>

<TD VALIGN=TOP WIDTH="11%">
<CENTER>864</CENTER>
</TD>

<TD VALIGN=TOP WIDTH="45%">TCP сервер посылает продолжающийся
поток символов, до тех пор пока соединение не будет разорвано клиентом.
UDP сервер посылает датаграммы с произвольным количеством каждый раз когда
пользователь посылает датаграмму</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="15%"><A NAME="t01C009"></A>time</TD>

<TD VALIGN=TOP WIDTH="14%">
<CENTER>37</CENTER>
</TD>

<TD VALIGN=TOP WIDTH="15%">
<CENTER>37</CENTER>
</TD>

<TD VALIGN=TOP WIDTH="11%">
<CENTER>868</CENTER>
</TD>

<TD VALIGN=TOP WIDTH="45%">Сервер выдает время как 32-х
битовое бинарное число. Это число означает количество секунд с полуночи
1- го Января 1900,&nbsp;<A NAME="t01C010"></A>UTC.</TD>
</TR>
</TABLE>

<P>Рисунок 1.9 Стандартные сервисы, предоставляемые
большинством реализаций.
<P><A NAME="t01D000"></A>
<P><B><U>Internet</U></B>
<P>На рисунке 1.3 показано соединение
двух сетей - Ethernet и Token ring. В разделах <A HREF="#t014000">"Адресация
Internet"</A> и <A HREF="#t019000">"Номера портов"</A> главы 1 мы говорили
о глобальной сети Internet и о необходимости централизованного распределения
IP адресов (<A NAME="t01D001"></A>InterNIC), а также о заранее известных
номерах портов (<A NAME="t01D002"></A>IANA) . Само слово internet имеет
различный смысл, в зависимости от того, начинается ли оно с большой буквы
или с маленькой.
<P>Слово internet означает несколько сетей,
соединенных вместе, использующих общее семейство протоколов. Слово Internet,
начинающееся с большой буквы, обозначает определенное количество компьютеров
(более миллиона), находящихся по всему миру, которые могут общаться друг
с другом с использованием TCP/IP. Поэтому Internet это internet, а не наоборот.
<P><A NAME="t01E000"></A><B><U>Реализации</U></B>
<P>Де факто стандарт для реализаций TCP/IP
появился в группе компьютерных исследований Калифорнийского университета
в Berkeley. Исторически он распространялся с 4.x&nbsp;<A NAME="t01E006"></A>BSD
system (Berkeley Software Distribution), и с BSD Networking Releases. Исходные
тексты этой реализации явились отправной точкой для множества последующих.
<P>На рисунке 1.10 показана хронология
появления различных релизов BSD и указаны важнейшие характеристики TCP/IP.
BSD Networking Releases, показанный слева, свободно распространяемый исходный
код, который содержит все исходные сетевые коды: как самих протоколов,
так и большинства приложений и утилит (таких как Telnet и FTP).
<BR>&nbsp;
<BR>&nbsp;
<P>Надо сказать,
что довольно сложно вычислить, когда и как появился релиз Net/3.
<BR>&nbsp;
<BR>&nbsp;
<P>По тексту мы используем термин&nbsp;<A NAME="t01E002"></A>"реализации,
произошедшие от Berkeley" или "Berkeley реализации", чтобы указать на следующие
реализации:&nbsp;<A NAME="t01E003"></A>SunOS 4.x,&nbsp;<A NAME="t01E004"></A>SVR4,
и&nbsp;<A NAME="t01E005"></A>AIX 3.2, которые были разработаны с использованием
исходных текстов Berkeley.<A NAME="t01E001"></A><A NAME="t01E007"></A><A NAME="t01E008"></A><A NAME="t01E009"></A><A NAME="t01E010"></A><A NAME="t01E011"></A><A NAME="t01E012"></A><A NAME="t01E013"></A><A NAME="t01E014"></A>
<BR>&nbsp;
<P><BR>
<CENTER>
<P><IMG SRC="t1_10_20.jpg" HEIGHT=363 WIDTH=400>
<P>Рисунок 1.10 Различные релизы BSD и
их важнейшие функции.</CENTER>

<BR>&nbsp;
<P><BR>
<BR>
<BR>
<P>Эти реализации имеют очень много общего,
включая одни и те же ошибки!
<P>Большинство исследований в&nbsp;<A NAME="t01E015"></A>Internet
до сих пор осуществляется с использованием системы&nbsp;<A NAME="t01E016"></A>Berkeley
- новые алгоритмы предотвращения переполнения (глава 21, раздел <A HREF="tcp21.html#t217000">"Быстрая
повторная передача и алгоритм быстрого восстановления"</A>), групповые
запросы (глава 12, раздел <A HREF="tcp12.html#t124000">"Рассылка групповых
сообщений"</A>), работа с каналами с повышенной пропускной способностью
(глава 24, раздел <A HREF="tcp24.html#t243000">"Каналы с повышенной пропускной
способностью (Long Fat Pipes)"</A>) и так далее.
<P><A NAME="t01F000"></A><B><U>Интерфейсы
прикладного программирования</U></B>
<P>Два популярных интерфейса прикладного
программирования (<A NAME="t01F001"></A>API - application programming interface)
для приложений, использующих протоколы TCP/IP, называются&nbsp;<A NAME="t01F002"></A>сокетами
(sockets) и&nbsp;<A NAME="t01F003"></A>интерфейсом транспортного уровня
(TLI - Transport Layer Interface) . Первый иногда называется "Berkeley
sockets", что указывает на то где он был разработан. Последний, исходно
разработанный в AT&amp;T, иногда называется&nbsp;<A NAME="t01F004"></A>XTI
(X/Open Transport Interface), это работа, произведенная&nbsp;<A NAME="t01F005"></A>X/Open,
международной группой поставщиков компьютеров, которые создали свой собственный
набор стандартов. XTI в действительности является расширением TLI.
<P>При написании этой книги мы не задавались
целью подробно рассматривать низкий уровень программирования, однако, где
это возможно, будем ссылаться на отдельные характеристики TCP/IP, в частности
на большинство популярных API. Все детали программирования, как для сокет
так и для TLI, можно найти в <A HREF="tcp_g.html#t370280">[Stevens 1990]</A>.
<P><A NAME="t01G000"></A><B><U>Тестируемая
сеть</U></B>
<P>На рисунке 1.11 показана тестируемая
сеть, которая используется для всех примеров в тексте этой книги.<A NAME="t01G001"></A>
<BR>&nbsp;
<P><BR>
<CENTER>
<P><A NAME="t1.11"></A><IMG SRC="t1_11_20.jpg" HEIGHT=320 WIDTH=495>
<P>Рисунок 1.11 Сеть, используемая для
всех примеров в тексте. Все IP адреса начинаются с 140.252.</CENTER>

<BR>&nbsp;
<P><BR>
<BR>
<BR>
<P>Большинство примеров запускаются на
четырех системах, которые показаны в нижней части рисунка. Все IP адреса
на этом рисунке принадлежат сети класса B 140.252. Все имена хостов принадлежат
домену .tuc.noao.edu (<A NAME="t01G002"></A>noao это "National Optical
Astronomy Observatories", а tuc это Tuscon). Например, нижняя правая система
имеет полное имя хоста svr4.tuc.noao.edu с IP адресом 140.252.13.34. Над
каждым квадратиком указана операционная система, под управлением которой
работает данный компьютер. Подобный набор систем и сетей, компьютеров и
маршрутизаторов позволяет подробно рассмотреть различные реализации TCP/IP.
<P>Необходимо отметить, что в действительности,
в домене&nbsp;<A NAME="t01G003"></A>noao.edu значительно больше сетей и
хостов, нежели тех, что показаны на рисунке 1.11. Однако здесь показаны
те системы, которые использовались в качестве примеров в книге.
<P>В разделе <A HREF="tcp03.html#t034000">"Адресация
подсетей"</A> главы 3 мы опишем способ деления этой сети на подсети, а
в разделе <A HREF="tcp04.html#t046000">"Уполномоченный агент ARP"</A> главы
4 подробно рассмотрим dialup SLIP (IP по последовательной линии с дозвоном)
соединения между sun и netb. В разделе <A HREF="tcp02.html#t024000">"SLIP:
IP по последовательной линии"</A> главы 2 SLIP описан более подробно.
<P><A NAME="t01H000"></A><B><U>Краткие
выводы</U></B>
<P>В этой главе мы совершили короткое
путешествие в огромный мир семейства протоколов TCP/IP, представили большинство
терминов и протоколов, которые будут обсуждены более подробно в следующих
главах.
<P>Существует четыре уровня семейства
протоколов TCP/IP - канальный уровень (link layer), сетевой уровень (network
layer), транспортный уровень (transport layer) и прикладной уровень (application
layer). Мы показали, за что отвечает каждый из этих уровней. В TCP/IP существуют
серьезные различия между сетевым и транспортным уровнями: сетевой уровень
(IP) предоставляет сервис, не ориентированный на соединение (пересылка
за пересылкой - hop-by-hop), тогда как транспортный уровень предоставляет
сервис с соединением (точка в точку - end-to-end) (TCP и UDP).
<P>"internet" это несколько сетей. Основное
средство, используемое для объединения сетей (internet) это маршрутизатор,
который соединяет сети на IP уровне. Заглавная "I" в слове&nbsp;<A NAME="t01H007"></A>"Internet"
обозначает сеть, которая охватывает весь земной шар.
<P>В сети каждый интерфейс имеет уникальный
IP адрес, однако пользователи могут использовать имена хостов вместо IP
адресов. Система имен доменов (DNS) позволяет установить динамическое соответствие
между именами хостов и IP адресами. Номера портов используются для идентификации
приложений, общающихся друг с другом. При этом мы сказали, что сервера
используют заранее-известные порты (well-known), тогда как клиенты используют
динамически назначаемые порты (ephemeral port).
<P><A NAME="t01H001"></A><B><I>Упражнения</I></B>
<OL>
<LI>
Вычислите максимально возможное количество
компьютеров в сетях класса A, B и C.</LI>

<LI>
Воспользовавшись анонимным FTP (глава
27, раздел <A HREF="tcp27.html#t273000">"Примеры FTP"</A>), получите файл
nfsnet/statistics/history.netcount с хоста <A HREF="ftp://nic.merit.edu/">ftp://nic.merit.edu</A>.
В этом файле содержится количество местных и иностранных сетей, объявленных
в инфраструктуре NFSNET. Распределите полное количество сетей по годам
(по оси ОХ - годы, по OY - количество сетей). Максимальное значение по
оси OY должно совпадать со значением, рассчитанным в предыдущем упражнении.
Если данные примерно совпадут, экстраполируйте значения, чтобы оценить,
когда текущая схема адресации переполнится сетевыми идентификаторами (раздел
<A HREF="tcp03.html#t03A000">"Будущее IP"</A> главы 3 рассказывает о том,
как можно решить подобную проблему).</LI>

<LI>
Достаньте копию&nbsp;<A NAME="t01H002"></A>Host
Requirements RFC [<A NAME="t01H003"></A>Braden 1989a] и рассмотрите&nbsp;<A NAME="t01H004"></A>принцип
непотопляемости (robustness principle) , который применяется к каждому
уровню семейства протоколов TCP/IP. Какое применение можно найти для этого
принципа?</LI>

<LI>
Получите копию последнего&nbsp;<A NAME="t01H005"></A>Assigned
Numbers RFC. Каков зарезервированный порт протокола "quote of the day"?
Какой RFC определяет этот протокол?</LI>

<LI>
Имеете ли Вы компьютер, который подключен
к сети TCP/IP, какой его основной IP адрес? Подключен ли этот компьютер
к мировой сети Internet? Имеет ли он несколько интерфейсов?</LI>

<LI>
Получите копию RFC 1000, чтобы понять,
откуда появился термин RFC.</LI>

<LI>
Установите контакт с сообществом Internet,
<A HREF="mailto:soc@isoc.org">isoc@isoc.org</A> или + 1 703 648 9888, чтобы
получить информацию о вступлении.</LI>

<LI>
Получите файл about-internic/information-about-the-internic,
используя анонимный FTP с хоста&nbsp;<A NAME="t01H006"></A><A HREF="ftp://is.internic.net/">ftp://is.internic.net</A>.</LI>
</OL>
<BR>&nbsp;
<BR>&nbsp;
<hr>
</body>
</html>

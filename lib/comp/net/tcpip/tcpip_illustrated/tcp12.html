<html>

<head>
<title>Широковещательная и групповая адресация</title>

<meta http-equiv="Content-type" content="text/html; charset=koi8-r">
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>




<p><a NAME="t120000"></a>Глава 12 Широковещательная и
групповая адресация</p>
<u>

<p><b><a NAME="t121000"></a>Введение</p>
</b></u>

<p><small>В <a HREF="tcp01.html">главе 1</a> мы упомянули, что
существуют три типа IP адресов: <a NAME="t121001"></a>персональный
(unicast), <a NAME="t121002"></a>широковещательный (broadcast) и <a NAME="t121003"></a>групповой (multicast) . В этой главе мы
обсудим широковещательные и групповые адреса
более подробно. </small></p>

<p><small>Широковещательные и групповые запросы
применимы только к UDP, подобные типы запросов
позволяют приложению послать одно сообщение
нескольким получателям. TCP - протокол,
ориентированный на соединение, с его помощью
устанавливается соединение между двумя хостами
(по указанному IP адресу) с использованием одного
процесса на каждом хосте (который
идентифицируется по номеру порта). </small></p>

<p><small>Представьте себе несколько хостов в Ethernet
сети. Каждый Ethernet фрейм содержит Ethernet адрес
источника и назначения (48 бит). И обычно каждый
фрейм предназначается одному получателю. Адрес
назначения, указывающий на один интерфейс, -
называется персональным (unicast). Остальные хосты,
присутствующие на кабеле, не участвуют в общении
между двумя хостами (если не учитывать то, что все
хосты находятся все-таки на одном кабеле). </small></p>

<p><small>Однако иногда возникает необходимость
послать фрейм всем хостам, находящимся на кабеле,
- это называется широковещательной рассылкой
(broadcast). Мы видели это, когда рассматривали ARP и RARP.
Групповая адресация логически находится между
персональной и широковещательной: фрейм должен
быть доставлен определенному количеству хостов,
которые принадлежат к группе. </small></p>

<p><small>Для того чтобы понять принцип
широковещательной и групповой адресации,
необходимо отметить, что на каждом хосте
происходит фильтрация, каждый раз когда фрейм
проходит по кабелю. На рисунке 12.1 показано как
это происходит. </small></p>

<p><small>Во-первых, сетевая плата просматривает
каждый фрейм, который передается по кабелю, и
определяет, необходимо ли принять этот фрейм и
доставить его в драйвер устройства. Обычно
сетевая плата принимает только те фреймы, адрес
назначения которых совпадает с аппаратным
адресом интерфейса или с широковещательным
адресом. В дополнение, большинство интерфейсов
могут находиться в смешанном режиме, когда она
принимает копию каждого фрейма. Этот режим
используется, например, программой <a NAME="t121004"></a>tcpdump.<a NAME="t121005"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t12_1000.jpg" WIDTH="230" HEIGHT="296"></small></p>


<p ALIGN="CENTER"><small>Рисунок 12.1 Фильтрация, которая
осуществляется стеком протоколов, когда
принимается фрейм.</small></p>

<p>&nbsp;</p>

<p><small>В настоящее время большинство интерфейсов
могут быть сконфигурированы таким образом, чтобы
принимать фреймы, IP адрес которых является
групповым адресом или групповым адресом
какой-либо подгруппы. В групповом адресе Ethernet
младший бит старшего байта установлен в единицу.
В шестнадцатиричном представлении этот бит
выглядит следующим образом: 01:00:00:00:00:00. (Мы можем
считать, что широковещательный адрес Ethernet
ff:ff:ff:ff:ff:ff это особый случай группового адреса
Ethernet.) </small></p>

<p><small>Когда сетевая плата получает фрейм, она
передает его в драйвер устройства. (Сетевая плата
может отбросить фрейм только в том случае, если
не сошлась <a NAME="t121006"></a>контрольная сумма Ethernet.)
Дополнительная фильтрация осуществляется
драйвером устройства. Во-первых, тип фрейма
должен принадлежать соответствующему протоколу
(IP, ARP и так далее). Во-вторых, может быть
осуществлена дополнительная групповая
фильтрация, чтобы проверить, принадлежит ли хост
к адресуемой группе. </small></p>

<p><small>Затем драйвер устройства передает фрейм
следующему уровню, например, IP, если фрейм
является IP датаграммой. IP также осуществляет
фильтрацию, основанную на проверке IP адресов
источника и назначения, и, в свою очередь,
передает датаграмму следующему уровню (например
TCP или UDP, если все в порядке). </small></p>

<p><small>Каждый раз когда UDP получает датаграмму от
IP, он осуществляет фильтрацию, основанную на
номере порта назначения, а иногда и на номере
порта источника. Если указанный порт не
обслуживается в текущий момент каким-либо
процессом, датаграмма отбрасывается, и
генерируется <a NAME="t121007"></a>ICMP сообщение о
недоступности порта. (TCP осуществляет подобную
фильтрацию, основанную на своих номерах портов.) <a NAME="t121008"></a>Если в UDP датаграмме обнаружена ошибка
контрольной суммы, UDP молча ее отбрасывает.</small></p>

<p><small>Проблема широковещательных запросов
заключается в том, что хосты, которые совсем не
заинтересованы в получении этих запросов, должны
их обрабатывать. Представьте себе приложение,
которое должно обрабатывать широковещательные
запросы UDP. Если на кабеле находится 50 хостов, но
только из них 20 участвуют в работе этого
приложения, в каждый момент времени один из 20
посылает широковещательный запрос UDP, при этом
остальные 30 хостов должны обработать этот
запрос, который проходит весь путь по стеку
протоколов до UDP уровня, прежде чем датаграмма
будет отброшена. UDP датаграмма отбрасывается
этими 30-ю хостами, потому что порта назначения не
обслуживается каким-либо процессом. </small></p>

<p><small>Основная задача групповых запросов -
уменьшить загрузку хостов, не учавствующих в
работе определенного приложения. Хост может
принадлежать к одной или нескольким группам.
Если это возможно, сетевая плата сообщает, к
какой группе принадлежит хост, после чего
сетевой платой принимаются только фреймы
определенной группы.</small></p>
<u><b>

<p><a NAME="t122000"></a>Широковещательные запросы</p>
</b></u>

<p><small>На <a HREF="tcp03.html#t036001">рисунке 3.9</a> показаны
четыре различные формы широковещательных
адресов IP. Сейчас мы опишем их более подробно.</small></p>
<i><b>

<p>Ограниченный широковещательный запрос</p>
</b></i>

<p><small><a NAME="t122001"></a>Ограниченный
широковещательный адрес (limited broadcast address) - это
адрес 255.255.255.255. Он может быть использован в
качестве адреса назначения для IP датаграмм в
процессе конфигурации хоста, когда хост может не
знать собственной маски подсети и даже своего IP
адреса. </small></p>

<p><small>Датаграмма, направляющаяся на ограниченный
широковещательный адрес, никогда (ни при каких
условиях) не будет перенаправлена
маршрутизатором. Она может существовать только
на локальном кабеле. </small></p>

<p><small><a NAME="t122002"></a>Но тут возникает вопрос, на
который практически невозможно дать ответ: если
хост имеет несколько интерфейсов и процесс
посылает датаграмму с ограниченным
широковещательным адресом, должна ли датаграмма
быть отправлена на каждый подсоединенный
интерфейс, который поддерживает
широковещательную адресацию? Если нет, то
приложение, которое хочет разослать
широковещательный запрос на все интерфейсы,
должно само определить все интерфейсы хоста,
которые поддерживают широковещательную
адресацию, и послать копию на каждый интерфейс. </small></p>

<p><small>Большинство BSD систем воспринимают 255.255.255.255
как адрес широковещательного адреса первого
интерфейса, который был сконфигурирован, и не
позволяют послать датаграмму на все
подключенные интерфейсы, поддерживающие
широковещательную адресацию. И действительно,
два приложения, которые посылают UDP датаграммы на
каждый интерфейс, это <a NAME="t122003"></a>routed (глава 10,
раздел <a HREF="tcp10.html#t103000">&quot;Демоны маршрутизации в
Unix&quot;</a>) и <a NAME="t122004"></a>rwhod (сервер BSD клиента <a NAME="t122005"></a>rwho). Оба этих приложения проходят через
похожую процедуру запуска, чтобы определить все
интерфейсы хоста и те, которые поддерживают
широковещательную адресацию. Широковещательный
адрес сети, соответствующий этому интерфейсу
затем используется как адрес назначения для
датаграмм, которые посылаются в этот интерфейс.</small></p>

<p>&nbsp;</p>


<p>Требования к хостам <a NAME="t122006"></a>Host Requirements RFC не определяют, должен ли
хост, имеющий несколько интерфейсов, посылать
ограниченный broadcast на все свои интерфейсы.</p>


<p>&nbsp;</p>
<i><b>

<p><a NAME="t122007"></a>Широковещательный запрос в сеть</p>
</b></i>

<p><small>В широковещательном адресе сети (net-directed
broadcast) идентификатор хоста устанавливается во
все единичные биты. Широковещательный адрес для
сети класса А, имеет вид netid.255.255.255, где netid это
идентификатор сети класса А.</small></p>

<p><small>Маршрутизаторы должны перенаправлять
широковещательные запросы, направляемые в сеть,
однако должна присутствовать опция, позволяющая
отключить это перенаправление.</small></p>
<i><b>

<p><a NAME="t122008"></a>Широковещательный запрос в подсеть</p>
</b></i>

<p><small>Широковещательный адрес подсети (subnet-directed
broadcast address) имеет идентификатор хоста,
установленный в единицы, однако определенный
идентификатор подсети. Для того, чтобы
классифицировать адрес как широковещательный
адрес подсети, необходимо знать маску подсети.
Например, если маршрутизатор получил датаграмму,
с адресом назначения 128.1.2.255, можно считать, что
это широковещательный запрос, направленный в
подсеть, если сеть класса В 128.1 имеет маску
подсети 255.255.255.0, однако это не широковещательный
запрос, если маска подсети 255.255.254.0 (0xfffffe00).</small></p>
<i><b>

<p><a NAME="t122009"></a>Широковещательный запрос,
направленный во все подсети</p>
</b></i>

<p><small>Широковещательный адрес всех подсетей
(all-subnets-directed broadcast address), также требует знания
маски подсети в сети назначения. Только в этом
случае можно определить различие между
широковещательным адресом всех подсетей и
широковещательным адресом сети. И идентификатор
подсети, и идентификатор хоста, в данном случае,
устанавливаются в единицы. Например, если маска
подсети назначения 255.255.255.0, то IP адрес 128.1.255.255 это
широковещательный запрос, направленный во все
подсети. Однако, если сеть не разбита на подсети,
это широковещательный запрос, направляемый в
сеть.</small></p>

<p><small>В настоящее время такой тип
широковещательных запросов считается
устаревшим [Almquist 1993]. В настоящее время
используются групповые запросы, а не
широковещательные запросы, направленные во все
подсети.</small></p>

<p>&nbsp;</p>


<p>[<a NAME="t122010"></a>Almquist 1993]
отмечает, что в RFC 922 требуется, чтобы
широковещательные запросы, направленные во все
подсети, посылались во все подсети, однако не все
маршрутизаторы это поддерживают. И это хорошо,
так как неверно сконфигурированый хост, без
собственной маски подсети, будет посылать эти
&quot;локальные&quot; широковещательные запросы во
все подсети. Например, если хост с IP адресом 128.1.2.3
не имеет установленной маски подсети, его
широковещательный адрес по умолчанию
устанавливается в 128.1.255.255. Однако, если маска
подсети должна быть определена как 255.255.255.0, то
широковещательные запросы от неправильно
сконфигурированного хоста появятся во всех
подсетях.</p>

<p>&nbsp;</p>

<p>Первая широкораспространенная
реализация TCP/IP, в системе <a NAME="t122011"></a>4.2BSD (1983 год),
использовала для широковещательных адресов
идентификатор хоста, установленного во все нули.
Один из самых ранних примеров обращения к
широковещательным IP адресам это IEN 212 <a NAME="t122012"></a>[Gurwitz
and Hinden 1982], и именно здесь было определено
использовать широковещательные IP адреса с
идентификаторами хостов, установленными во все
единицы. (<a NAME="t122013"></a>IEN это Internet Experiment Notes,
непосредственный предшественник RFC.) В RFC 894 [<a NAME="t122014"></a>Hornig 1984] говорится, что 4.2BSD использует
нестандартный широковещательный адрес, однако в
RFC 906 [<a NAME="t122015"></a>Finlayson 1984] замечается, что тогда
не существовало стандарта Internet для
широковещательных адресов. При редакции RFC была
сделана сноска на RFC 906, где говорилось об
отсутствии стандарта на широковещательные
адреса, однако очень рекомендовалось
использовать широковещательные адреса с
идентификаторами хоста, установленными во все
единицы. К тому же, Berkeley начал использовать все
единичные биты для широковещательного адреса,
начиная с <a NAME="t122016"></a>4.3BSD (1986 год), однако
некоторые операционные системы (и что интересно,
даже <a NAME="t122017"></a>SunOS&nbsp;4.x) продолжали
использовать нестандартные широковещательные
адреса до начала 90-х.</p>


<p><small><a NAME="t123000"></a>&nbsp;</small></p>
<u><b>

<p>Примеры широковещательных запросов</p>
</b></u>

<p><small>Как рассылаются широковещательные запросы
и что делают маршрутизаторы и хосты с этими
запросами? К сожалению, на этот вопрос очень
сложно ответить, потому что это зависит от типа
широковещательного адреса, приложения,
реализации TCP/IP и возможной конфигурации. </small></p>

<p><small>Во-первых, приложение должно поддерживать
широковещательные запросы. Если мы запустим</small></p>

<p>&nbsp;</p>


<p>sun % <b>ping 255.255.255.255<br>
</b>/usr/etc/ping: unknown host 255.255.255.255</p>


<p>&nbsp;</p>

<p><small>то есть постараемся послать запрос на
локальный кабель, это не сработает. Однако
проблема здесь заключена в самом приложении (ping).
Большинство приложений, которые воспринимают
как цифровые IP адреса (в десятичном выражении),
так и имена хостов, вызывают функцию <a NAME="t123001"></a>inet_addr
(3), чтобы конвертировать строку чисел в 32-битный
двоичный IP адрес, и если это не удалось,
воспринимают строку символов как имя хоста. Эта
библиотечная функция возвращает код ошибки -1
если в строке обнаружен символ, отличный от цифры
или десятичной точки, в случае <a NAME="t123002"></a>ограниченного
широковещательного адреса (255.255.255.255) также
выдается код -1. Большинство программ, которые
воспринимают символьную строку как имя хоста,
обрабатывают его с использованием DNS (<a HREF="tcp14.html">глава
14</a>) и ограничиваются выводом ошибки, такой как
&quot;неизвестный хост&quot; (unknown host). </small></p>

<p><small>Даже если мы исправим эту ошибку в
программе <a NAME="t123003"></a>ping, результаты будут все
равно не такими как хотелось бы. Из шести
протестированных систем, только одна
генерировала широковещательные пакеты в
локальный кабель. Большинство ищут IP адрес
255.255.255.255 в таблице маршрутизации, в конце концов
находят маршрут по умолчанию и посылают
персональный пакет на маршрутизатор по
умолчанию. Естественно, такой пакет
уничтожается. </small></p>

<p><small>В подобном случае необходимо использовать
широковещательные запросы, направленные в
подсеть. И действительно, в разделе <a HREF="tcp06.html#t063000">&quot;ICMP запрос и отклик маски
адреса&quot;</a> главы 6 мы посылали датаграммы на IP
адрес 140.252.13.63 для нижнего Ethernet в нашей тестовой
сети и получали отклики от всех хостов Ethernet. <a NAME="t123004"></a>Широковещательный адрес, направленный
в подсеть, соответствует каждому интерфейсу,
именно этот адрес используется командой <a NAME="t123005"></a>ifconfig (глава 3, раздел <a HREF="tcp03.html#t038000">&quot;Команда
ifconfig&quot;</a>). Если мы пошлем ping на этот адрес,
результат будет таким, как мы хотели:</small></p>

<p>&nbsp;</p>


<p>sun % <b>arp -a</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARP
кэш пуст<br>
<br>
sun % <b>ping 140.252.13.63</b><br>
PING 140.252.13.63: 56 data bytes<br>
64 bytes from sun (140.252.13.33): icmp_seq=0. time=4. ms<br>
64 bytes from bsdi (140.252.13.35): icmp_seq=0. time=172. ms<br>
64 bytes from svr4 (140.252.13.34): icmp_seq=0. time=192. ms<br>
<br>
64 bytes from sun (140.252.13.33): icmp_seq=1. time=1. ms<br>
64 bytes from bsdi (140.252.13.35): icmp_seq=1. time=52. ms<br>
64 bytes from svr4 (140.252.13.34): icmp_seq=1. time=90. ms<br>
<br>
^<b>?</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; введен
символ прерывани<br>
----140.252.13.63 PING Statistics----<br>
2 packets transmitted, 6 packets received, -200% packet loss<br>
round-trip (ms) min/avg/max = 1/85/192<br>
<br>
sun % <b>arp -a</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; снова
проверяем ARP кэш<br>
svr4 (140.252.13.34) at 0:0:c0:c2:9b:26<br>
bsdi (140.252.13.35) at 0:0:c0:6f:2d:40<br>
</p>


<p>&nbsp;</p>

<p><small>IP определяет, что адрес назначения (140.252.13.63)
- это широковещательный адрес, направленный в
подсеть, и посылает датаграммы на
широковещательный адрес канального уровня. </small></p>

<p><small>Мы упоминали в разделе <a HREF="tcp06.html#t063000">&quot;ICMP
запрос и отклик маски адреса&quot;</a> главы 6, что
этот тип широковещательных запросов означает
обращение ко всем хостам локальной сети, включая
отправителя. Из примера видно, что мы получили
отклик от отправляющего хоста sun и от всех
остальных хостов, находящихся на кабеле.</small></p>

<p><small>В этом примере показан ARP кэш перед и после
того, как был запущен ping на широковещательный
адрес. Это сделано для того, чтобы показать
взаимосвязь между рассылкой широковещательных
запросов и состоянием ARP. ARP кэш пуст перед
запуском ping, и заполнен по окончании. (В кэше
находится по одной записи на каждый хост,
находящийся на кабеле и ответивший на эхо
запрос.) Как заполнился кэш, раз мы сказали, что
Ethernet фрейм посылается на широковещательный
адрес канального уровня 0xffffffff? Отправка этих
фреймов хостом sun не требует ARP. </small></p>

<p><small>Если мы посмотрим работу ping с
использованием <a NAME="t123006"></a>tcpdump, то увидим, что
получатели широковещательных фреймов
генерируют ARP запрос на sun, перед тем как
отправить отклик. Причем, надо отметить, что
каждый отклик персональный. Мы говорили в
разделе <a HREF="tcp04.html#t045000">&quot;Примеры ARP&quot;</a> главы
4, что получатель ARP запроса (sun в данном примере)
обычно добавляет IP адрес и аппаратный адрес
запрашивающего в свой ARP кэш, и отправляет ARP
отклик. Это делается из предположения, что если
запрашивающий послал нам пакет, мы, возможно, в
будущем захотим послать что-нибудь и ему. </small></p>

<p><small>Использование ping - это особый случай, потому
что подобный тип программного интерфейса,
(который в большинстве Unix реализаций называется
&quot;символьный сокет&quot; (raw socket)), всегда позволяет
послать датаграмму на широковещательный адрес.
Что если мы воспользуемся приложением, которое
не поддерживает широковещательные запросы, как,
например, TFTP? (Мы опишем <a NAME="t123007"></a>TFTP более
подробно в <a HREF="tcp15.html">главе 15</a>.) </small></p>

<p>&nbsp;</p>


<p><br>
bsdi % <b>tftp </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; запускаем
клиента<br>
tftp&gt; <b>connect 140.252.13.63 </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; указываем IP адрес
сервера<br>
tftp&gt; <b>get temp.foo </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; и
пытаемся получить файл с сервера<br>
tftp: sendto: Permission denied<br>
tftp&gt; <b>quit </b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; прекращение
работы клиента<br>
</p>


<p>&nbsp;</p>

<p><small>Здесь мы получаем ошибку мгновенно, при
этом в кабель ничего не посылается. Это
объясняется тем, что <a NAME="t123008"></a>сокеты API не
позволяют процессу отправлять UDP датаграммы на
широковещательный адрес, если процесс
специально не заявил, что он планирует
использовать широковещательные запросы. Это
сделано для того, чтобы предотвратить ошибочное
указание широковещательного адреса
пользователем (именно так, как поступили мы в
данном случае), тогда как приложение не
предназначено для рассылки широковещательных
запросов.</small></p>

<p>&nbsp;</p>


<p>Для сокет API, приложение
должно установить опцию сокет <a NAME="t123009"></a>SO_BROADCAST
перед отправкой UDP датаграммы на
широковещательный адрес. Однако, не все системы
применяют это ограничение. Некоторые реализации
позволяют любому процессу отправлять UDP
датаграммы широковещательным образом, причем не
требуют от процесса, чтобы он объявлял об этом.
Другие имеют более строгие ограничения и
требуют, чтобы процесс имел привилегии
суперпользователя, чтобы использовать
широковещательную рассылку.</p>


<p>&nbsp;</p>

<p><small>Следующий вопрос заключается в том,
перенаправляются ли широковещательные пакеты.
Некоторые ядра и маршрутизаторы имеют опцию,
которая позволяет включить или выключить эту
характеристику. (См. <a HREF="tcp_e.html">приложение Е</a>.) </small></p>

<p><small>Если мы включим характеристику
перенаправления широковещательных пакетов на
маршрутизаторе bsdi и запустим ping с хоста slip, то
увидим, что bsdi перенаправляет <a NAME="t123010"></a>широковещательные
запросы, направленные в подсеть. <a NAME="t123011"></a>Перенаправление
направленных широковещательных запросов
означает, что маршрутизатор воспринимает
входящие датаграммы как персональные,
определяет, что адрес назначения это
направленный широковещательный адрес одного из
его интерфейсов, и затем перенаправляет
датаграммы в соответствующую сеть, используя
широковещательный адрес канального уровня.</small></p>

<p>&nbsp;</p>


<p><br>
slip % <b>ping 140.252.13.63</b><br>
PING 140.252.13.63 (140.252.13.63): 56 data bytes<br>
64 bytes from 140.252.13.35: icmp_seq=0 ttl=255 time=190 ms<br>
64 bytes from 140.252.13.33: icmp_seq=0 ttl=254 time=280 ms (DUP!)<br>
64 bytes from 140.252.13.34: icmp_seq=0 ttl=254 time=360 ms (DUP!)<br>
<br>
64 bytes from 140.252.13.35: icmp_seq=1 ttl=255 time=190 ms<br>
64 bytes from 140.252.13.33: icmp_seq=1 ttl=254 time=270 ms (DUP!)<br>
64 bytes from 140.252.13.34: icmp_seq=1 ttl=254 time=360 ms (DUP!)<br>
<br>
^<b>?</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; введен
символ прерывания<br>
--- 140.252.13.63 ping statistics ---<br>
3 packets transmitted, 2 packets received, +4 duplicates, 33% packet loss<br>
round-trip min/avg/max = 180/273/360 ms<br>
</p>


<p>&nbsp;</p>

<p><small>Мы видим, что это работает. Также мы видим,
что программа ping в BSD проверяет отслеживает
повторные номера последовательности и помечает
их как DUP!. Это обычно означает, что пакет был
каким-либо образом продублирован, однако здесь
именно это и должно было произойти, так как
запросы были отправлены на широковещательный
адрес. </small></p>

<p><small>Этот тест можно запустить с более
удаленного хоста (от той сети, к которой
направляется широковещательный запрос). Мы
запустили ping с хоста vangogh.cs.berkeley.edu (который
находится на расстоянии 14 пересылок от нашей
сети), и это также будет работать, если
маршрутизатор sun сконфигурирован таким образом,
чтобы перенаправлять направленные
широковещательные запросы. В данном случае IP
датаграммы (переносящие <a NAME="t123012"></a>ICMP эхо
запросы) перенаправляются каждым
маршрутизатором, встречающимся им на пути, как
обычные датаграммы. Никто из них не знает, что в
действительности это направленные
широковещательные запросы. И последний
маршрутизатор, netb, думает, что пакеты
предназначены хосту с идентификатором равным 63,
и перенаправляет их на sun. В этом месте sun
определяет, что IP адрес назначения в
действительности это широковещательный адрес
подключенного интерфейса, и передает датаграммы
в виде широковещательных запросов канального
уровня для этой сети. </small></p>

<p><small>Рассылка широковещательных запросов это
характеристика, которую необходимо использовать
с очень большой осторожностью. В большинстве
случаев групповая адресация IP предоставляет
лучшее решение практически всех проблем.</small></p>
<u><b>

<p><a NAME="t124000"></a>Рассылка групповых сообщений</p>
</b></u>

<p><small>Рассылка групповых сообщений IP
предоставляет приложениям два сервиса.</small> 

<ol>
  <li><small>Доставка к нескольким пунктам назначения.
    Существует множество приложений, которые
    доставляют информацию нескольким адресатам,
    например, диалоговые конференции,
    распространение почты или новостей. Если
    групповая адресация не используется, эти типы
    сервисов вынуждены использовать TCP (при этом
    осуществляется доставка отдельной копии на
    каждый пункт назначения). Даже при существовании
    групповой формы сообщений, некоторые приложения
    все-таки используют TCP из-за его надежности.</small></li>
  <li><small>Запрос от клиента к серверу. Например,
    бездисковая рабочая станция старается
    определить положение сервера загрузки. В
    настоящее время это осуществляется с
    использованием широковещательных запросов (как
    мы увидим в случае с BOOTP в <a HREF="tcp16.html">главе 16</a>),
    однако решение с использованием групповых
    запросов может уменьшить загруженность хостов,
    которые не предоставляют этот сервис.</small></li>
</ol>

<p><small>В этом разделе мы рассмотрим <a NAME="t124001"></a>групповые
адреса, а в <a HREF="tcp13.html">следующей</a> главе
рассмотрим протоколы, которые используют
групповую адресацию хостов и маршрутизаторов
(IGMP).</small></p>
<i><b>

<p><a NAME="t124002"></a>Адреса групп</p>
</b></i>

<p><small>На рисунке 12.2 показан формат <a NAME="t124003"></a>IP
адреса класса D.<a NAME="t124004"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t12_2000.jpg" WIDTH="468" HEIGHT="39"></small></p>


<p ALIGN="CENTER"><small>Рисунок 12.2 <a NAME="t124005"></a>Формат IP
адреса класса D.</small></p>

<p>&nbsp;</p>

<p><small>В отличие от трех других классов IP адресов
(A,B и C), форматы которых приведены на <a HREF="tcp01.html#t014001">рисунке 1.5</a>, 28 бит, отведенные под
групповой идентификатор, не подвергаются
дальнейшему делению. </small></p>

<p><small><a NAME="t124006"></a>Групповой адрес (multicast group address)
состоит из четырех старших бит, установленных в
1110, и идентификатора группы. В десятичном виде
групповые адреса находятся в диапазоне от 224.0.0.0
до 239.255.255.255. </small></p>

<p><small>Некоторое количество хостов,
просматривающих определенный групповой IP адрес,
называется <a NAME="t124007"></a>группой хостов (host group).
Группа хостов может объединять хосты в разных
сетях. Членство в группе динамическое - хост
может вступать в группу и выходить из группы по
собственному желанию. Не существует ограничений
на количество хостов в группе, и хост не должен
принадлежать к группе, чтобы послать сообщение в
эту группу. </small></p>

<p><small>Некоторые адреса групп назначаются как
заранее известные адреса от <a NAME="t124008"></a>IANA (Internet
Assigned Numbers Authority). В этом случае группа считается <a NAME="t124009"></a>постоянной группой хостов (permanent host
group). Заранее известные групповые адреса
приведены в последних RFC назначенных номеров (<a NAME="t124010"></a>Assigned Numbers RFC). Обратите внимание на то,
что постоянным в данном случае является
групповой адрес, а не членство в группе.</small></p>

<p><small>Например, 224.0.0.1 означает &quot;все системы в
этой подсети&quot;, а 224.0.0.2 означает &quot;все
маршрутизаторы в этой подсети&quot;. Групповой
адрес 224.0.1.1 предназначен для сетевого протокола
времени (<a NAME="t124011"></a>NTP - Network Time Protocol), 224.0.0.9 для <a NAME="t124012"></a>RIP-2 (глава 10, раздел <a HREF="tcp10.html#t105000">&quot;RIP
Version 2&quot;</a>) и 224.0.1.2 для SGI (Silicon Graphics) dogfight
приложений.</small></p>
<i><b>

<p><a NAME="t124013"></a>Преобразование групповых адресов в
адреса Ethernet</p>
</b></i>

<p><small>IANA владеет блоком Ethernet адресов, которые в
шестнадцатиричном представлении выглядят как
00:00:5e. Это старшие 24 бита Ethernet адреса, означающие,
что блок включает адреса в диапазоне от 00:00:5e:00:00:00
до 00:00:5e:ff:ff:ff. IANA отвела половину этого блока для
групповых адресов. Установлено правило, что
первый байт Ethernet адреса равный 01 указывает на
групповой адрес. Это означает, что Ethernet адреса,
соответствующие групповым адресам IP, должны
находиться в диапазоне от 01:00:5e:00:00:00 до 01:00:5e:7f:ff:ff.</small></p>

<p>&nbsp;</p>


<p>Приведенные здесь
выражения используют стандартную
последовательность битов для Internet, для сетей <a NAME="t124014"></a>CSMA/CD или Token bus, а именно такую, как биты
располагаются в памяти. Это как раз то, с чем
сталкивается большинство программистов и
системных администраторов. <a NAME="t124015"></a>IEEE
документация использует порядок бит, который
используется при передаче. Assigned Numbers RFC
предоставляет дополнительные подробности о
различиях между этими представлениями.</p>


<p>&nbsp;</p>

<p><small>Подобное расположение позволяет 23 битам в
Ethernet адресе соответствовать идентификатору
группы IP. В процессе преобразования адресов 23
младших бита идентификатора группы помещаются в
23 бита Ethernet адреса. (См. рисунок 12.3.) </small></p>

<p><small>Старшие 5 бит в идентификаторе группы
игнорируются, так как они не уникальны. Каждому
Ethernet адресу соответствует 32 различных
идентификатора группы. Например, групповой адрес
224.128.64.32 (в шестнадцатиричном представлении
e0.80.40.20) и 224.0.64.32 (в шестнадцатиричном
представлении e0.00.40.20) оба будут трансформированы
в Ethernet адрес 01:00:5e:00:40:20. </small></p>

<p><small>Так как подобное сопоставление не
уникально, предполагается, что драйвер
устройства или IP модуль на рисунке 12.1 должен
осуществить фильтрацию, так как сетевая плата
может получить групповой фрейм, который хосту не
предназначен. Если сетевая плата не осуществляет
адекватную фильтрацию групповых фреймов,
драйвер устройства, вполне возможно, должен
будет получать все групповые фреймы и сам
осуществлять фильтрацию.<a NAME="t124016"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t12_3000.jpg" WIDTH="476" HEIGHT="153"></small></p>


<p ALIGN="CENTER"><small>Рисунок 12.3 Соответствие между IP
адресами класса D и групповыми адресами Ethernet.</small></p>

<p>&nbsp;</p>


<p>Существует два
варианта реализации групповой адресации в
сетевых платах, использующиеся в локальных
сетях. Одни осуществляют групповую фильтрацию,
основанную на значении аппаратного группового
адреса, что означает, что некоторые
нежелательные фреймы могут пройти. В другом
случае имеется небольшое фиксированное
количество групповых адресов, принимаемых
платой, при этом, если хосту необходимо принять
больше групповых адресов, чем поддерживается,
интерфейс должен быть помещен в режим &quot;разных
групп&quot; (multicast promiscuous). Однако, оба типа
интерфейсов все еще требуют, чтобы драйвер
устройства осуществлял проверку на предмет того,
необходимо ли дальше обрабатывать принятый
фрейм. Даже если интерфейс осуществляет
идеальную групповую фильтрацию (основанную на
48-битном аппаратном адресе) фильтрация все еще
необходима, так как сопоставление <a NAME="t124017"></a>IP
адресов класса D и 48-битных аппаратных адресов
осуществляется не один к одному. Однако, если
абстрагироваться от несовершенства
преобразования адресов и аппаратной фильтрации,
групповая адресация все же лучше, чем
широковещательная.</p>


<p>&nbsp;</p>

<p><small>Осуществить групповой запрос в
единственную физическую сеть довольно просто.
Отправляющий процесс указывает IP адрес
назначения, который является групповым адресом,
драйвер устройства конвертирует это в
соответствующий Ethernet адрес и отправляет.
Принимающие процессы должены указать своим IP
модулям, что они хочет получать датаграммы,
предназначенные определенному групповому
адресу, и драйвера устройств должен каким-либо
образом получать эти групповые фреймы. Все это
называется &quot;вступлением в группу&quot;. (Причина,
по которой мы использовали выражение
&quot;принимающие процессы&quot; во множественном
числе, объясняется тем, что обычно существует
несколько получателей, которым предназначено
групповое сообщение, либо на одном, либо на
разных хостах.) Когда групповая датаграмма
получена хостом, копия доставляется всем
процессам, которые принадлежат к группе. Это
отличается от UDP, где единственный процесс
получает входящую персональную UDP датаграмму.
Несколько процессов на одном хосте могут
принадлежать к одной группе. </small></p>

<p><small>Однако сложности растут как снежный ком,
когда группа распространяется на несколько
сетей, и групповые пакеты должны проходить через
маршрутизаторы. Маршрутизаторам необходимо
знать, принадлежат ли какие-либо хосты в данной
физической сети к определенной группе. Для
определения этого, существует протокол,
называемый протоколом группового управления
Internet (IGMP - Internet Group Management Protocol). Этому протоколу
полностью посвящена <a HREF="tcp13.html">следующая</a>
глава.</small></p>
<i><b>

<p>Широковещательные запросы в сетях FDDI и Token Ring</p>
</b></i>

<p><small><a NAME="t124018"></a>Сети FDDI используют ту же схему
преобразования между IP адресами класса D и
48-битными FDDI адресами [<a NAME="t124019"></a>Katz 1990]. Сети <a NAME="t124020"></a>Token ring обычно используют отличную
систему сопоставления из-за ограничений, которые
накладываются на большинство управляющих
устройств Token ring [<a NAME="t124021"></a>Pusateri 1993].</small></p>
<u><b>

<p><a NAME="t125000"></a>Краткие выводы</p>
</b></u>

<p><small>Широковещательная рассылка используется
при отправке пакетов всем хостам в сети (обычно
это локально подключенная сеть), а групповые
сообщения используются для отправки пакетов
определенному количеству хостов в сети. В этих
концепциях используются различные типы
фильтрации, которая осуществляется, когда
принятый фрейм проходит по стеку протоколов.
Каждый уровень может отбросить принятый пакет по
различным причинам. </small></p>

<p><small>Существуют четыре типа широковещательных
адресов: ограниченный, широковещательный адрес
сети, широковещательный адрес подсети и <a NAME="t125001"></a>широковещательный адрес всех
подсетей. Наиболее распространенный - <a NAME="t125002"></a>широковещательный
адрес подсети. Ограниченный широковещательный
адрес обычно используется системой только в
случае загрузки из сети. </small></p>

<p><small>Проблемы возникают, когда делается попытка
послать широковещательный запрос через
маршрутизаторы, чаще всего из-за того, что
маршрутизатор не знает маску подсети в сети
назначения. Результат зависит от того, какого
типа широковещательный адрес, от параметров
конфигурации и так далее.</small></p>

<p><small><a NAME="t125003"></a>IP адреса класса D называются
групповыми адресами. Они преобразовываются в
адреса Ethernet путем помещения их 23 младших битов в
фиксированный Ethernet адрес. Подобное
сопоставление не является уникальным, поэтому
требуется дополнительная фильтрация одним из
протоколов.</small></p>
<i><b>

<p>Упражнения</b></i> 

<ol>
  <li>Увеличивается ли сетевой
    траффик (загрузка сети) в случае
    широковещательных запросов?</li>
  <li>Представьте 50 хостов в Ethernet: 20 запускают TCP/IP, а 30
    используют какое-либо другое семейство
    протоколов. Как широковещательные запросы от
    одного семейства протоколов обрабатываются
    хостами, использующими другое семейство
    протоколов?</li>
  <li>Вы зашли терминалом на Unix систему, с которой
    раньше никогда не работали, и хотите найти
    широковещательный адрес, направленный в подсеть,
    для всех подключенных интерфейсов, которые
    поддерживают широковещательные сообщения. Как
    это можно сделать?</li>
  <li>Если Вы запустили <a NAME="t125004"></a>ping на
    широковещательный адрес с большим размером
    пакетов, как в примере:<p>sun %
    <b>ping 140.252.13.63 1472<br>
    </b>PING 140.252.13.63: 1472 data bytes<br>
    1480 bytes from sun (140.252.13.33): icmp_seq=0. time=6. ms<br>
    1480 bytes from svr4 (140.252.13.34): icmp_seq=0. time=84. ms<br>
    1480 bytes from bsdi (140.252.13.35): icmp_seq=0. time=128. ms</p>
    <p ALIGN="JUSTIFY">это работает, однако увеличение
    размера пакета на 1 байт приведет к следующей
    ошибке:</p>
    <p>sun % <b>ping 140.252.13.63 1473<br>
    </b>PING 140.252.13.63: 1473 data bytes<br>
    sendto: Message too long&nbsp;</p>
    <p ALIGN="JUSTIFY">Что произошло?</p>
  </li>
  <li>Повторите <a HREF="tcp10.html#t109001">упражнение 6</a> главы
    10, представив себе 8 RIP сообщений, направляемых с
    помощью групповой адресации вместо
    широковещательной (представьте, что
    используется RIP Version 2). Что изменится?</li>
</ol>

<hr>

</body>
</html>

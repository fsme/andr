<html>

<head>
<title>Программа Traceroute</title>

<meta http-equiv="Content-type" content="text/html; charset=koi8-r">
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>




<p><a NAME="t080000"></a>Глава 8 Программа Traceroute</p>
<u>

<p><b><a NAME="t081000"></a>Введение</p>
</b></u>

<p><small>Программа <a NAME="t081001"></a>Traceroute, написанная Van
Jacobson, - отладочное средство, которое позволяет
лучше понять устройство протоколов TCP/IP. Обычно
две последовательные датаграммы отправленные от
одного и того же источника к одному и тому же
пункту назначения проходят по одному и тому же
маршруту, однако гарантировать этого невозможно.
Traceroute позволяет нам посмотреть маршрут, по
которому двигаются IP датаграммы от одного хоста
к другому. С помощью Traceroute можно воспользоваться
IP опцией маршрутизации от источника. </small></p>

<p>&nbsp;</p>


<p>В страницах помощи о
программе Traceroute говорится: &quot;Разработана <a NAME="t081002"></a>Van Jacobson по предложению Steve Deering.
Отлажена и настроена C. <a NAME="t081003"></a>Philip Wood, <a NAME="t081004"></a>Tim Seaver и <a NAME="t081005"></a>Ken Adelman.&quot; </p>


<p><small><a NAME="t082000"></a>&nbsp;</small></p>
<u><b>

<p>Функционирование программы Traceroute</p>
</b></u>

<p><small>В разделе <a HREF="tcp07.html#t073000">&quot;Опция записи IP
маршрута&quot;</a> главы 7 мы описали <a NAME="t082001"></a>IP
опцию записи маршрута (RR). Возникает вопрос, зачем
писать новое приложение, когда данная опция уже
реализована? Существует три причины. Во-первых,
исторически не все маршрутизаторы поддерживают
опцию записи маршрута, из чего следует, что
некоторые маршруты становятся неиспользуемыми.
(Traceroute не требует каких-либо специальных
характеристик на промежуточных
маршрутизаторах.) </small></p>

<p><small>Во-вторых, запись маршрута обычно
осуществляется в одном направлении. Отправитель
включает опцию, а получатель должен вставить все
значения из принятого IP заголовка и каким-либо
образом вернуть их отправителю. В разделе <a HREF="tcp07.html#t073000">&quot;Опция записи IP маршрута&quot;</a>
главы 7 мы видели, что большинство реализаций
сервера Ping (функция ICMP эхо отклика, встроенная в
ядро) отображают входящий RR список, однако при
этом удваивается количество записанных IP
адресов (путь туда и обратно), помимо этого
существует еще несколько ограничений, которые
будут рассмотрены в следующем параграфе. (Traceroute
требует только того, чтобы на пункте назначения
присутствовал работающий UDP модуль - никаких
специальных серверных приложений не требуется.) </small></p>

<p><small>Третья и основная причина заключается в
том, что размер, предоставляемый для опций в IP
заголовке, недостаточен для того, чтобы
обработать большинство маршрутов. В поле опций IP
заголовка входит всего 9 IP адресов. Если во
времена <a NAME="t082002"></a>ARPANET этого хватало, на
сегодняшний день этого слишком мало. </small></p>

<p><small>Traceroute использует ICMP и поле <a NAME="t082003"></a>TTL в IP
заголовке. Поле TTL (время жизни) это 8-битное поле,
которое отправитель устанавливает в какое-либо
значение. Рекомендуемое исходное значение
указано в <a NAME="t082004"></a>Assigned Numbers RFC и в настоящее
время равно 64. Более старые системы
устанавливают это значение в 15 или 32. Мы видели в
некоторых примерах работы программы Ping (<a HREF="tcp07.html">глава 7</a>), что ICMP эхо отклики часто
отправляются с TTL, установленным в максимальное
значение - 255. </small></p>

<p><small>Каждый маршрутизатор, который обрабатывает
датаграмму, уменьшает значение TTL на единицу или
на количество секунд, в течение которых
маршрутизатор обрабатывал датаграмму. Так как
большинство маршрутизаторов задерживает
датаграмму меньше чем секунду, поле TTL, как
правило, уменьшается на единицу и довольно точно
соответствует количеству пересылок. </small></p>

<p>&nbsp;</p>


<p>RFC 1009 <a NAME="t082005"></a>[Braden and
Postel 1987] требует, чтобы маршрутизатор,
задерживающий датаграмму на время большее чем 1
секунда, уменьшал TTL на количество секунд. Совсем
немногие маршрутизаторы удовлетворяют этому
требованию. Современные требования к
маршрутизаторам, <a NAME="t082006"></a>Router Requirements RFC [<a NAME="t082007"></a>Almquist 1993], делают это требование
необязательным, позволяя маршрутизаторам
использовать поле TTL в качестве счетчика
пересылок.</p>


<p>&nbsp;</p>

<p><small>С помощью поля TTL предотвращается
зацикливание датаграммы в петлях маршрутизации.
Например, если маршрутизатор вышел из строя или
соединение между двумя маршрутизаторами
потеряно, может потребоваться некоторое время
(от нескольких секунд до нескольких минут), для
того чтобы определить, что маршрут потерян и что
его необходимо обойти. В это время существует
вероятность, что датаграмма будет уничтожена в
петле маршрутизации. Чтобы предотвратить потерю
датаграммы, поле TTL устанавливается в
максимальную величину. </small></p>

<p><small>Когда маршрутизатор получает IP датаграмму
с TTL равным либо 0, либо 1, он не должен отправлять
эту датаграмму дальше. (Хост приемник должен
доставить подобную датаграмму в приложение, так
как датаграмма не может быть смаршрутизировна.
Как правило, системы не должны получать
датаграммы с TTL равным 0.) Если такую датаграмму
получает маршрутизатор, он уничтожает ее и
посылает хосту, который ее отправил ICMP сообщение <a NAME="t082008"></a>&quot;время истекло&quot; (time exceeded). Принцип
работы Traceroute заключается в том, что IP датаграмма,
содержащая это ICMP сообщение, имеет в качестве
адреса источника IP адрес маршрутизатора. </small></p>

<p><small>Теперь мы можем понять, как работает Traceroute.
На хост назначения отправляется IP датаграмма с
TTL, установленным в единицу. Первый
маршрутизатор, который должен обработать
датаграмму, уничтожает ее (так как TTL равно 1) и
отправляет ICMP сообщение об истечении времени (time
exceeded). Таким образом, определяется первый
маршрутизатор в маршруте. Затем Traceroute отправляет
датаграмму с TTL равным 2, что позволяет получить IP
адрес второго маршрутизатора. Это продолжается
до тех пор, пока датаграмма не достигнет хоста
назначения. Однако, если датаграмма прибыла
именно на хост назначения, он не уничтожит ее и не
сгенерирует ICMP сообщение об истечении времени,
так как датаграмма достигла своего конечного
назначения. Как можно определить, что датаграмма
достигла конечного пункта назначения? </small></p>

<p><small>В UDP датаграммах, которые посылает Traceroute,
устанавливается несуществующий номер UDP порта
(больше чем 30000), что делает невозможным обработку
этой датаграммы каким-либо приложением. Поэтому
когда прибывает подобная датаграмма, UDP модуль
хоста назначения генерирует ICMP сообщение <a NAME="t082009"></a>&quot;порт недоступен&quot; (port unreachable) (см.
раздел <a HREF="tcp06.html#t065000">&quot;ICMP ошибка
недоступности порта&quot;</a> главы 6). Все что
необходимо в этом случае, Traceroute это определить
тип принятого ICMP сообщения - либо об истечении
времени, либо о недоступности порта - именно
таким образом мы узнаем, доставлена ли
датаграмма в пункт назначения. </small></p>

<p>&nbsp;</p>


<p>Программа Traceroute должна
уметь устанавливать поле TTL в исходящих
датаграммах. Не все интерфейсы TCP/IP поддерживают
это, и не все реализации предоставляют эту
возможность, однако большинство современных
систем предоставляют. А это означает, что Traceroute
может быть запущена. Однако обычно требуется,
чтобы эту программу запускал суперпользователь.</p>


<p><small><a NAME="t083000"></a>&nbsp;</small></p>
<u><b>

<p>Работа в локальной сети</p>
</b></u>

<p><small>А сейчас запустим traceroute. Мы будем
использовать сети, показанные на рисунке,
приведенном на внутренней стороне обложки, и
пройдем по маршруту от svr4 к slip через
маршрутизатор bsdi. Выделенный SLIP канал между bsdi и
slip имеет скорость 9000 бит/сек.</small></p>

<p>&nbsp;</p>


<p>svr4 % <b>traceroute slip</b><br>
traceroute to slip (140.252.13.65), 30 hops max, 40 byte packets<br>
1 bsdi (140.252.13.35)&nbsp; 20 ms&nbsp; 10 ms&nbsp; 10 ms<br>
2 slip (140.252.13.65)&nbsp; 120 ms&nbsp; 120 ms&nbsp; 120 ms<br>
</p>


<p>&nbsp;</p>

<p><small>Первая строка, без номера содержит имя и IP
адрес пункта назначения и указывает на то, что
величина TTL не может быть больше 30. Размер
датаграммы установлен в 40 байт, из которых 20 байт
отводится на IP заголовок, 8 байт на UDP заголовок и
12 байт на пользовательские данные. (В 12 байтах
пользовательских данных содержится номер
последовательности, который увеличивается на
единицу при отправке каждой следующей
датаграммы, копия исходящего TTL и время, когда
датаграмма была отправлена.) </small></p>

<p><small>Следующие две строки вывода начинаются с TTL,
после чего следует имя хоста или маршрутизатора
и их IP адреса. Для каждого значения TTL
отправляется 3 датаграммы. Для каждого
возвращенного ICMP сообщения рассчитывается и
печатается время возврата (round-trip). Если ответ не
получен в течении пяти секунд на любую из трех
датаграмм, печатается звездочка, после чего
отправляется следующая датаграмма. В нашем
примере первые три датаграммы имели TTL,
установленный в единицу, а ICMP сообщения
вернулись через 20, 10 и 10 миллисекунд. Следующие
три датаграммы были отправлены с TTL равным 2, а ICMP
сообщения вернулись с задержкой 120 миллисекунд.
Так как TTL со значением 2 достигло конечного
пункта назначения, программа прекратила свою
работу. </small></p>

<p><small>Времена возврата (round-trip) рассчитывается
программой traceroute на хосте отправителе. Они
представляют из себя полные времена возврата от
программы traceroute к маршрутизатору. Если
необходимо расчитать время, затраченное на
каждую пересылку, мы должны вычесть значение,
полученное как TTL N, из значения, полученного как
TTL N+1. </small></p>

<p><small>На рисунке 8.1 показан вывод <a NAME="t083004"></a>tcpdump
для данного исполнения программы traceroute. То что
первый пробный пакет к bsdi имел RTT равное 20
миллисекундам, а следующие два имели RTT равное 10
миллисекундам объясняется тем, что был
осуществлен ARP обмен. </small></p>

<p><small>Значение, которое выбирается как номер UDP
порта назначения, начинается с величины 33435 и
увеличивается на единицу каждый раз, когда
отправляется следующая датаграмма. Номер порта
может быть изменен с использованием опции
командной строки. UDP датаграмма содержит 12 байт
пользовательских данных, как упоминалось ранее,
в том случае, если в выводе traceroute мы видим, что
отправляются датаграммы размером в 40 байт.</small></p>

<p><small>Когда IP датаграмма имеет TTL равное единице,
tcpdump печатает комментарий [ttl 1]. Подобное
сообщение печатается, когда TTL равно 0 или 1, чтобы
предупредить нас о том, что в датаграмме что-то не
в порядке. В данном случае мы ожидаем увидеть TTL
равное 1, однако некоторые другие приложения
получат предупреждение о том, что датаграмма
скорее всего не достигла своего конечного пункта
назначения. Скорее всего мы никогда не увидим
датаграммы с TTL равным 0, если только
маршрутизатор, который отправил ее в кабель, не
вышел из строя.<a NAME="t083002"></a></small></p>

<p>&nbsp;</p>


<p> 1&nbsp; 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp
who-has bsdi tell svr4<br>
2&nbsp; 0.000586 (0.0006)&nbsp;&nbsp;&nbsp; arp reply bsdi is-at 0:0:c0:6f:2d:40<br>
<br>
3&nbsp; 0.003067 (0.0025)&nbsp;&nbsp;&nbsp; svr4.42804&gt;slip.33435: udp 12 [ttl 1]<br>
4&nbsp; 0.004325 (0.0013)&nbsp;&nbsp;&nbsp; bsdi&gt;svr4: icmp: time exceeded in-transit<br>
<br>
5&nbsp; 0.069810 (0.0655)&nbsp;&nbsp;&nbsp; svr4.42804&gt;slip.33436: udp 12 [ttl 1]<br>
6&nbsp; 0.071149 (0.0013)&nbsp;&nbsp;&nbsp; bsdi&gt;svr4: icmp: time exceeded in-transit<br>
<br>
7&nbsp; 0.085162 (0.0140)&nbsp;&nbsp;&nbsp; svr4.42804&gt;slip.33437: udp 12 [ttl 1]<br>
8&nbsp; 0.086375 (0.0012)&nbsp;&nbsp;&nbsp; bsdi&gt;svr4: icmp: time exceeded in-transit<br>
<br>
9&nbsp; 0.118608 (0.0322)&nbsp;&nbsp;&nbsp; svr4.42804&gt;slip.33438: udp 12<br>
10&nbsp; 0.226464 (0.1079)&nbsp;&nbsp;&nbsp; slip&gt;svr4: icmp: slip udp port 33438
unreachable<br>
<br>
11&nbsp; 0.287296 (0.0608)&nbsp;&nbsp;&nbsp; svr4.42804&gt;slip.33439: udp 12<br>
12&nbsp; 0.395230 (0.1079)&nbsp;&nbsp;&nbsp; slip&gt;svr4: icmp: slip udp port 33439
unreachable<br>
<br>
13&nbsp; 0.409504 (0.0143)&nbsp;&nbsp;&nbsp; svr4.42804&gt;slip.33440: udp 12<br>
14&nbsp; 0.517430 (0.1079)&nbsp;&nbsp;&nbsp; slip&gt;svr4: icmp: slip udp port 33440
unreachable<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 8.1 Вывод tcpdump для примера traceroute от svr4
к slip.</small></p>

<p>&nbsp;</p>

<p><small>ICMP cообщение <a NAME="t083003"></a>&quot;время истекло
при передаче&quot; (time exceeded in transit) это то, что мы
ожидаем увидеть от маршрутизатора bsdi, в том
случае если он уменьшит на единицу TTL и оно станет
равным нулю. ICMP сообщение придет от
маршрутизатора даже в том случае, если IP
датаграмма, которая была уничтожена,
направлялась на slip. </small></p>

<p><small>Существуют два различных ICMP сообщения об
истечении времени (рисунок&nbsp;6.3), в каждом из них
содержится различное поле code. На рисунке 8.2
показан формат этих ICMP сообщений.<a NAME="t083001"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t8_20000.jpg" WIDTH="514" HEIGHT="168"></small></p>


<p ALIGN="CENTER"><small>Рисунок 8.2 ICMP сообщение об
истечении времени (&quot;time exceeded&quot;).</small></p>

<p>&nbsp;</p>

<p><small>В сообщении, которое генерируется, когда TTL
достигает нуля, поле code равно нулю. </small></p>

<p><small>Существует возможность, что хост пошлет ICMP
сообщение &quot;время истекло в течении повторной
сборки&quot; (time exceeded during reassembly) в том случае, если
время истекло в течении <a NAME="t083005"></a>повторной
сборки фрагментированной датаграммы. (Мы
подробно рассмотрим фрагментацию и повторную
сборку в разделе <a HREF="tcp11.html#t115000">&quot;Фрагментация
IP&quot;</a> главы 11.) В этом случае поле code
устанавливается в единицу. </small></p>

<p><small>Строки с 9-ой по 14-ую на рисунке 8.1
соответствуют трем датаграммам, которые
посылаются с TTL равным 2. Они достигают конечного
пункта назначения, при этом генерируется <a NAME="t083006"></a>ICMP сообщение о недоступности порта. </small></p>

<p><small>Попробуем рассчитать время возврата,
которое соответствует SLIP каналу, как это было
сделано в разделе <a HREF="tcp07.html#t072000">&quot;Программа
Ping&quot;</a> главы 7, когда при работе программы Ping
была установлена скорость канала - 1200 бит/сек.
Исходящая UDP датаграмма содержит 12 байт данных, 8
байт UDP заголовка, 20 байт IP заголовка и 2 байта
(минимум) для создания SLIP фреймов (см. раздел <a HREF="tcp02.html#t024000">&quot;SLIP: IP по последовательной
линии&quot;</a> главы 2), что в целом составляет 42
байта. В отличие от Ping, размер возвращающихся
датаграмм изменяется. На рисунке 6.9, мы видели,
что возвращаемое ICMP сообщение содержит IP
заголовок датаграммы, которая вызвала ошибку и
первые 8 байт данных, которые следуют за IP
заголовком (содержащие UDP заголовок, в данном
случае traceroute). При этом мы получаем 20+8+20+8+2 или 58
байт. При скорости передачи в 960 байт/сек,
ожидаемое RTT составляет (42+58/960) или 104
миллисекунды. Это сопоставимо со значением,
рассчитанным для svr4 и равным 110 миллисекундам. </small></p>

<p><small>Номер порта источника на рисунке 8.1
достаточно большой (42804). traceroute устанавливает
номер порта источника IP датаграмм, которые она
посылает в логическое ИЛИ (logical OR), со своим
идентификатором процесса (32768). В этом случае,
если traceroute запущена несколько раз на одном и том
же хосте, каждый процесс просматривает номер
порта источника в UDP заголовке, который
возвращается в ICMP сообщении, и обрабатывает
только те сообщения, которые были отправлены в
качестве отклика на его запрос. </small></p>

<p><small>Необходимо отметить некоторые особенности
traceroute. Во-первых, не существует гарантии, что
маршрут, который используется сегодня, будет
использоваться и завтра, даже если две
последовательные датаграммы были отправлены к
одному и тому же пункту назначения. Если маршрут
изменится в процессе работы программы, Вы
увидите это, потому что traceroute напечатает новые IP
адреса для определенных TTL. </small></p>

<p><small>Во-вторых, не существует гарантии того, что
путь, по которому вернется ICMP сообщение, совпадет
с путем, по которому traceroute отправила UDP
датаграмму. Это означает, что время возврата,
которое печатает программа, может не совпадать
со временем, потребовавшимся на передачу
исходящей датаграммы и возвращенного сообщения.
(Возможен вариант, что UDP датаграмма дойдет от
источника до маршрутизатора за 1 секунду, однако
ICMP сообщение проделает обратный путь за 3
секунды, при этом время возврата будет
напечатано как 4 секунды.) </small></p>

<p><small>В-третьих, IP адрес, который возвращается в
сообщение ICMP, это IP адрес интерфейса, на который
маршрутизатор принял UDP датаграмму. Тогда как при
использовании <a NAME="t083007"></a>опции записи маршрута
(см. раздел <a HREF="tcp07.html#t073000">&quot;Опция записи IP
маршрута&quot;</a> главы 7) записывается IP адрес
исходящего интерфейса. Так как каждый
маршрутизатор по умолчанию имеет 2 или более
интерфейсов, запуск traceroute от хоста А к хосту В
может отличаться от того, который запущен с хоста
В на хост А. Действительно, если мы запустим traceroute
от хоста slip к svr4, вывод будет следующим:</small></p>

<p>&nbsp;</p>


<p>slip % <b>traceroute svr4</b><br>
traceroute to svr4 (140.252.13.34), 30 hops max, 40 byte packets<br>
1 bsdi (140.252.13.66)&nbsp; 110 ms&nbsp; 110 ms&nbsp; 110 ms<br>
2 slip (140.252.13.34)&nbsp; 110 ms&nbsp; 120 ms&nbsp; 110 ms<br>
</p>


<p>&nbsp;</p>

<p><small>В этом случае IP адрес, напечатанный для
хоста bsdi, это адрес SLIP интерфейса (140.252.13.66), тогда
как до этого адрес был 140.252.13.35, что
соответствовало интерфейсу Ethernet. Так как traceroute
пытается определить имя, связанное с IP адресом,
имена будут различны. (В нашем примере оба
интерфейса bsdi имеют одно и то же имя.) </small></p>

<p><small>Обратимся к рисунку 8.3. На нем показаны две
локальные сети, соединенные через
маршрутизаторы. Два маршрутизатора соединены по
каналу точка-точка. Если мы запустим traceroute с
хоста в левой локальной сети на хост в правой
локальной сети, IP адреса для маршрутизатора
будут if1 и if3. При использовании другого пути,
будут получены адреса if4 и if2. Два интерфейса if2 и
if3 имеют один и тот же идентификатор сети, тогда
как два других интерфейса имеют разные
идентификаторы сетей.<a NAME="t083008"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t8_30000.jpg" WIDTH="468" HEIGHT="78"></small></p>


<p ALIGN="CENTER"><small>Рисунок 8.3 Идентификация
интерфейсов программой traceroute.</small></p>

<p>&nbsp;</p>

<p><small>И в заключение отметим, что при работе с
глобальными сетями вывод traceroute значительно
легче читать, если вместо IP адресов печатаются
читаемые имена доменов. Однако, так как в ICMP
сообщении, принимаемом при работе traceroute,
содержится IP адрес, он и будет выдан, если
преобразовать IP адрес в имя домена не удалось. В
этом случае администратор должен позаботиться о
том, чтобы принятый IP адрес мог быть корректно
трансформирован в имя домена. Мы опишем, как IP
адреса конвертируются в имена с использованием
DNS, в разделе <a HREF="tcp14.html#t145000">&quot;Запросы
указателя&quot;</a> главы 14. </small></p>
<u><b>

<p><a NAME="t084000"></a>Вывод при работе в глобальных сетях</p>
</b></u>

<p><small>Вывод, показанный ранее для нашей маленькой
сети, достаточно реально показывает, как
функционируют протоколы. Однако, будет очень
интересно посмотреть, как работает traceroute в
больших сетях, например, в сети <a NAME="t084001"></a>Internet. </small></p>

<p><small>На рисунке 8.4 показано как отправляется
запрос от sun к Сетевому информационному центру (<a NAME="t084002"></a>NIC - Network Information Center).<a NAME="t084003"></a></small></p>

<p>&nbsp;</p>


<p>sun % <b>traceroute nic.ddn.mil</b><br>
traceroute to nic.ddn.mil (192.112.36.5), 30 hops max, 40 byte packets<br>
<br>
1 netb.tuc.noao.edu (140.252.1.183)&nbsp; 218 ms&nbsp; 227 ms&nbsp; 233 ms<br>
2 gateway.tuc.noao.edu (140.252.1.4)&nbsp; 233 ms&nbsp; 229 ms&nbsp; 204 ms<br>
<br>
3 butch.telcom.arizona.edu (140.252.104.2)&nbsp; 204 ms&nbsp; 228 ms&nbsp; 234 ms<br>
4 Gabby.Telcom.Arizona.EDU (128.196.128.1)&nbsp; 234 ms&nbsp; 228 ms&nbsp; 204 ms<br>
5 NSIgate.Telcom.Arizona.EDU (192.80.43.3)&nbsp; 233 ms&nbsp; 228 ms&nbsp; 234 ms<br>
<br>
6 JPL1.NSN.NASA.GOV (128.161.88.2)&nbsp; 234 ms&nbsp; 590 ms&nbsp; 262 ms<br>
7 JPL3.NSN.NASA.GOV (192.100.15.3)&nbsp; 238 ms&nbsp; 223 ms&nbsp; 234 ms<br>
8 GSFC3.NSN.NASA.GOV (128.161.3.33)&nbsp; 293 ms&nbsp; 318 ms&nbsp; 324 ms<br>
9 GSFC8.NSN.NASA.GOV (192.100.13.8)&nbsp; 294 ms&nbsp; 318 ms&nbsp; 294 ms<br>
10 SURA2.NSN.NASA.GOV (128.161.166.2)&nbsp; 323 ms&nbsp; 319 ms&nbsp; 294 ms<br>
11 nsn-FIX-pe.sura.net (192.80.214.253)&nbsp; 294 ms&nbsp; 318 ms&nbsp; 294 ms<br>
12 GSI.NSN.NASA.GOV (128.161.252.2)&nbsp; 293 ms&nbsp; 318 ms&nbsp; 324 ms<br>
<br>
13 NIC.DDN.MIL (192.112.36.5)&nbsp; 324 ms&nbsp; 321 ms&nbsp; 324 ms<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 8.4 traceroute от sun к nic.ddn.mil.</small></p>

<p>&nbsp;</p>


<p>Чтобы включить этот
пример в текст, мы запустили его для не-DDN узлов
(не военные узлы) от <a NAME="t084004"></a>nic.ddn.mil к <a NAME="t084005"></a>rs.internic.net,
новый &quot;<a NAME="t084006"></a>InterNIC&quot;. </p>


<p>&nbsp;</p>

<p><small>Когда датаграмма выходит из сети <a NAME="t084007"></a>tuc.noao.edu,
она попадает в сеть telcom.arizona.edu. Затем она попадает
в сеть Национального агентства по аэронавтике
США (NASA Science Internet), nsn.nasa.gov. Маршрутизаторы с TTL
равным 6 и 7 находятся в лаборатории Jet Propulsion (JPL).
Сеть sura.net (в выводе TTL равно 11) это сеть
Исследовательской ассоциации университетов
(Southeastern Universities Research Association Network). GSI (TTL равно 12) это
Government Systems, Inc., оператор для NIC. </small></p>

<p><small>Второе RTT для TTL равного 6 (590) почти в два раза
больше, чем два другие RTT (234 и 262). Это показывает
динамику IP маршрутизации. Подобное может
произойти где-нибудь по пути от источника к
маршрутизатору если какой-нибудь промежуточный
маршрутизатор задержал датаграмму. Однако мы не
можем сказать, была ли задержена исходящая
датаграмма или возвращающееся ICMP сообщение. </small></p>

<p><small>RTT для первой попытки с TTL равным 3 (204) меньше,
чем RTT для первой попытки с TTL равной 2 (233). Так как
каждое полученное RTT является полным временем
прохода от посылающего хоста к маршрутизатору,
это вполне объснимо. </small></p>

<p><small>В примере на рисунке 8.5 показана работа
программы Traceroute от хоста sun на хост нашего
издателя.<a NAME="t084008"></a></small></p>

<p>&nbsp;</p>


<p>sun % <b>traceroute aw.com</b><br>
traceroute to aw.com (192.207.117.2), 30 hops max, 40 byte packets<br>
1 netb.tuc.noao.edu (140.252.1.183)&nbsp; 227 ms&nbsp; 227 ms&nbsp; 234 ms<br>
2 gateway.tuc.noao.edu (140.252.1.4)&nbsp; 233 ms&nbsp; 229 ms&nbsp; 234 ms<br>
<br>
3 butch.telcom.arizona.edu (140.252.104.2)&nbsp; 233 ms&nbsp; 229 ms&nbsp; 234 ms<br>
4 Gabby.Telcom.Arizona.EDU (128.196.128.1)&nbsp; 264 ms&nbsp; 228 ms&nbsp; 234 ms<br>
5 Westgate.Telcom.Arizona.EDU (192.80.43.2) 234 ms 228 ms 234 ms<br>
<br>
6 uu-ua.AZ.westnet.net (192.31.39.233)&nbsp; 263 ms&nbsp; 258 ms&nbsp; 264 ms<br>
7 enss142.UT.westnet.net (192.31.39.21)&nbsp; 263 ms&nbsp; 258 ms&nbsp; 264 ms<br>
<br>
8 t3-2.Denver-cnss97.t3.ans.net (140.222.97.3)&nbsp; 293 ms&nbsp; 288 ms&nbsp; 275 ms<br>
9 t3-3.Denver-cnss96.t3.ans.net (140.222.96.4)&nbsp; 283 ms&nbsp; 263 ms&nbsp; 261 ms<br>
10 t3-1.St-Louis-cnss80.t3.ans.net (140.222.80.2)&nbsp; 282 ms&nbsp; 288 ms&nbsp; 294 ms<br>
11 t3-1.Chicago-cnss24.t3.ans.net (140.222.24.2)&nbsp; 293 ms&nbsp; 288 ms&nbsp; 294 ms<br>
12 t3-2.Cleveland-cnss40.t3.ans.net (140.222.40.3)&nbsp; 294 ms&nbsp; 288 ms&nbsp; 294 ms<br>
13 t3-1.New-York-cnss32.t3.ans.net (140.222.32.2)&nbsp; 323 ms&nbsp; 318 ms&nbsp; 324 ms<br>
14 t3-1.Washington-DC-cnss56.t3.ans.net (140.222.56.2)&nbsp; 323 ms&nbsp; 318 ms&nbsp; 324
ms<br>
15 t3-0.Washington-DC-cnss58.t3.ans.net (140.222.58.1)&nbsp; 324 ms&nbsp; 318 ms&nbsp; 324
ms<br>
16 t3-0.enss136.t3.ans.net (140.222.136.1)&nbsp; 323 ms&nbsp; 318 ms&nbsp; 324 ms<br>
<br>
17 Washington.DC.ALTER.NET (192.41.177.248)&nbsp; 323 ms&nbsp; 377 ms&nbsp; 324 ms<br>
18 Boston.MA.ALTER.NET (137.39.12.2)&nbsp; 324 ms&nbsp; 347 ms&nbsp; 324 ms<br>
19 AW-gw.ALTER.NET (137.39.62.2)&nbsp; 353 ms&nbsp; 378 ms&nbsp; 354 ms<br>
<br>
20 aw.com (192.207.117.2)&nbsp; 354 ms&nbsp; 349 ms&nbsp; 354 ms<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 8.5 traceroute от хоста sun.tuc.noao.edu к хосту
aw.com.</small></p>

<p>&nbsp;</p>

<p><small>После того как датаграмма вышла из сети
telcom.arizona.edu она попадает в региональную сеть
western.net (TTL 6 и 7). Затем датаграмма попадает на
магистраль (backbone) <a NAME="t084009"></a>NSFNET, t3.ans.net, которая
используется Advanced Network &amp; Services. (T3 это
общепринятая аббревиатура для каналов 45
Мбит/сек, которые используются в качестве
магистралей.) И последняя сеть это alter.net, точка
подсоединения к Internet для aw.com. </small></p>
<u><b>

<p><a NAME="t085000"></a>Опция IP маршрутизации от источника</p>
</b></u>

<p><small>Обычно IP маршрутизация осуществляется
динамически, т.е. каждый маршрутизатор принимает
решение о том, на какой <a NAME="t085001"></a>маршрутизатор
следующей пересылки необходимо отправить
датаграмму. Приложения не могут управлять этим
процессом и обычно этим и не занимаются. Поэтому
приходится использовать средства, такие как
Traceroute, чтобы проследить, как в действительности
происходит маршрутизация. </small></p>

<p><small>Идея, заложенная в маршрутизации от
источника, заключается в том, что отправитель сам
указывает маршрут по которому пройдет
датаграмма. Существует две формы: </small>

<ul>
  <li><small><a NAME="t085002"></a>Жесткая (strict) маршрутизация от
    источника. Отправитель указывает точный путь, по
    которому должна пройти IP датаграмма. Если
    маршрутизатор обнаруживает, что следующая
    пересылка, указанная в маршрутизации от
    источника, не является непосредственно
    подключенной сетью, возвращается ICMP ошибка
    &quot;маршрутизация от источника невозможна&quot;
    (source route failed). </small></li>
  <li><small><a NAME="t085003"></a>Свободная (loose) маршрутизация от
    источника. Отправитель указывает список IP
    адресов, через который должна пройти IP
    датаграмма, однако датаграмма может также пройти
    через другие маршрутизаторы между любыми двумя
    адресами, указанными в списке. </small></li>
</ul>

<p><small>Traceroute позволяет использовать
маршрутизацию от источника.</small></p>

<p>&nbsp;</p>


<p>Некоторые свободно
распространяемые исходные тексты программы
Traceroute содержат дополнения, которые позволяют
установить свободную маршрутизацию от
источника. Однако стандартные версии обычно не
включают эту опцию. Комментарии к дополнениям
гласят: &quot;исходные тексты программы Traceroute,
написанные <a NAME="t085004"></a>Van Jacobson (весна 1988 года),
поддерживали эту характеристику, однако она была
удалена по требованию людей, которые вывели из
строя свои шлюзы&quot;. Для того чтобы показать
пример, приведенный в этом разделе, автор
установил эти дополнения и модифицировал их
таким образом, чтобы можно было использовать оба
типа маршрутизации от источника.</p>


<p>&nbsp;</p>

<p><small>На рисунке 8.6 показан формат опции
маршрутизации от источника.<a NAME="t085005"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t8_60000.jpg" WIDTH="497" HEIGHT="126"></small></p>


<p ALIGN="CENTER"><small>Рисунок 8.6 Общий формат опции
маршрутизации от источника в IP заголовке.</small></p>

<p>&nbsp;</p>

<p><small>Формат практически идентичен формату опции
записи маршрута, которую мы рассмотрели на
рисунке 7.3. Однако, в случае маршрутизации от
источника мы должны заполнить список IP адресов,
перед тем как будет отправлена IP датаграмма,
тогда как в опции записи маршрута мы выделяли
пространство и устанавливали в 0 список IP
адресов, позволяя маршрутизаторам заполнить их в
процессе передачи датаграммы. В случае с
маршрутизацией от источника мы выделяем область
для заполнения и инициализируем определенное
количество требуемых IP адресов, обычно их
количество меньше чем 9. В случае опции записи
маршрута мы старались выделить как можно больше
места, для того чтобы использовать более чем 9
адресов. </small></p>

<p><small>Поле code устанавливается в 0x83 для свободной
маршрутизации от источника, и в 0x89 для жесткой
маршрутизации от источника. Поля len и ptr идентичны
тем, что мы описали в разделе <a HREF="tcp07.html#t073000">&quot;Опция
записи IP маршрута&quot;</a> главы 7. </small></p>

<p><small>Опции маршрутизации от источника обычно
называются &quot;маршрутизацией от источника с
записью&quot; (source and record route) (<a NAME="t085006"></a>LSRR -
свободная и <a NAME="t085007"></a>SSRR - жесткая), так как
список IP адресов обновляется в процессе того, как
датаграмма проходит по маршруту. Происходит
следующее:</small> 

<ul>
  <li><small>Отправляющий хост берет из приложения
    маршрут от источника, удаляет первый пункт (он
    становится адресом назначения для датаграммы),
    перемещает все оставшиеся пункты влево на один
    пункт (где лево - показано на рисунке 8.6) и
    помещает исходный адрес назначения на место
    последнего пункта в списке. Указатель все еще
    указывает на первый пункт списка (значение
    указателя равно 4). </small></li>
  <li><small>Каждый маршрутизатор, который обрабатывает
    датаграмму, проверяет, является ли этот адрес
    адресом назначения. Если нет, датаграмма
    обрабатывается как обычная. В этом случае должна
    быть использована свободная маршрутизация от
    источника, иначе мы не получим датаграмму. </small></li>
  <li><small>Если маршрутизатор является пунктом
    назначения и указатель не больше чем длина, в
    этом случае (1) следующий адрес в списке (куда
    указывает ptr) становится адресом назначения
    датаграммы, (2) IP адрес, соответствующий
    исходящему интерфейсу, замещает собой только что
    использованный адрес источника, и (3) указатель
    увеличивается на 4.</small></li>
</ul>

<p><small>Все это лучше показать на примере. На
рисунке 8.7 мы предположили, что посылающее
приложение на хосте S отправляет датаграмму к D,
указав маршрут от источника как R1, R2 и R3.<a NAME="t085008"></a></small></p>


<p ALIGN="CENTER"><small><img SRC="t8_70000.jpg" WIDTH="514" HEIGHT="89"></small></p>


<p ALIGN="CENTER"><small>Рисунок 8.7 Пример IP маршрутизации
от источника.</small></p>

<p>&nbsp;</p>

<p><small>На этом рисунке символ (#) означает поле
указателя, которое может принимать значение 4, 8, 12
и 16. Поле длины всегда будет 15 (3 IP адреса + 3 байта).
Обратите внимание на то, как меняется IP адрес
назначения в IP датаграмме при каждой пересылке. </small></p>

<p><small>Когда приложение получает данные, которые
маршрутизировались от источника, оно должно
выделить значение принятого маршрута и
использовать обратный маршрут для отправки
отклика.</small></p>

<p>&nbsp;</p>


<p>Требования к хостам <a NAME="t085009"></a>Host Requirements RFC указывает, что TCP клиент
должен иметь возможность указать маршрутизацию
от источника, и что TCP сервер должен иметь
возможность принять маршрутизацию от источника,
а также использовать обратный маршрут для всех
сегментов TCP соединения. Если TCP сервер позже
принял другой маршрут от источника, более новый
маршрут перезаписывает собой ранний маршрут.</p>


<p>&nbsp;</p>
<i><b>

<p>Примеры traceroute с использованием свободной
маршрутизации от источника</p>
</b></i>

<p><small>Опция <a NAME="t085010"></a>-g программы traceroute
позволяет нам указать промежуточные
маршрутизаторы, которые должны быть
использованы при <a NAME="t085011"></a>свободной
маршрутизации от источника. Эта опция может быть
указана до 8 раз. (Причина того, что указывается
именно 8, а не 9 раз, заключается в том, что
программный интерфейс, который будет
использоваться, потребует, чтобы последний пункт
являлся конечным пунктом назначения.) </small></p>

<p><small>Повторно обратимся к рисунку 8.4, из которого
видно, что маршрутизация к NIC, <a NAME="t085012"></a>nic.ddn.mil,
была осуществлена через сеть NASA. На рисунке 8.8 мы
заставим датаграммы пройти через <a NAME="t085013"></a>NSFNET,
вместо того чтобы использовать маршрутизатор
enss142.UT.westnet.net (192.31.39.21) в качестве промежуточного
маршрутизатора:<a NAME="t085014"></a></small></p>

<p>&nbsp;</p>


<p>sun % <b>traceroute -g 192.31.39.21 nic.ddn.mil</b><br>
traceroute to nic.ddn.mil (192.112.36.5), 30 hops max, 40 byte packets<br>
1 netb.tuc.noao.edu (140.252.1.183)&nbsp; 256 ms&nbsp; 256 ms&nbsp; 235 ms<br>
<br>
2 butch.telcom.arizona.edu (140.252.104.2)&nbsp; 234 ms&nbsp; 228 ms&nbsp; 234 ms<br>
3 Gabby.Telcom.Arizona.EDU (128.196.128.1)&nbsp; 234 ms&nbsp; 257 ms&nbsp; 233 ms<br>
<br>
4 enss142.UT.westnet.net (192.31.39.21)&nbsp; 294 ms&nbsp; 288 ms&nbsp; 295 ms<br>
<br>
5 t3-2.Denver-cnss97.t3.ans.net (140.222.97.3)&nbsp; 294 ms&nbsp; 286 ms&nbsp; 293 ms<br>
6 t3-3.Denver-cnss96.t3.ans.net (140.222.96.4)&nbsp; 293 ms&nbsp; 288 ms&nbsp; 294 ms<br>
7 t3-1.St-Louis-cnss80.t3.ans.net (140.222.80.2)&nbsp; 294 ms&nbsp; 318 ms&nbsp; 294 ms<br>
8 * t3-1.Chicago-cnss24.t3.ans.net (140.222.24.2)&nbsp; 318 ms&nbsp; 295 ms<br>
9 t3-2.Cleveland-cnss40.t3.ans.net (140.222.40.3)&nbsp; 319 ms&nbsp; 318 ms&nbsp; 324 ms<br>
10 t3-1.New-York-cnss32.t3.ans.net (140.222.32.2)&nbsp; 324 ms&nbsp; 318 ms&nbsp; 324 ms<br>
11 t3-1.Washington-DC-cnss56.t3.ans.net (140.222.56.2)&nbsp; 353 ms&nbsp; 348 ms&nbsp; 325
ms<br>
12 t3-0.Washington-DC-cnss58.t3.ans.net (140.222.58.1)&nbsp; 348 ms&nbsp; 347 ms&nbsp; 325
ms<br>
13 t3-0.enss145.t3.ans.net (140.222.145.1)&nbsp; 353 ms&nbsp; 348 ms&nbsp; 325 ms<br>
<br>
14 nsn-FIX-pe.sura.net (192.80.214.253)&nbsp; 353 ms&nbsp; 348 ms&nbsp; 325 ms<br>
15 GSI.NSN.NASA.GOV (128.161.252.2)&nbsp; 353 ms&nbsp; 348 ms&nbsp; 354 ms<br>
16 NIC.DDN.MIL (192.112.36.5)&nbsp; 354 ms&nbsp; 347 ms&nbsp; 354 ms<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 8.8 traceroute на <a NAME="t085015"></a>nic.ddn.mil со
свободной маршрутизацией от источника через NSFNET.</small></p>

<p>&nbsp;</p>

<p><small>Создается впечатление, что было сделано 16
пересылок со средним RTT около 350 миллисекунд,
тогда как обычный маршрут, показанный на рисунке
8.4, состоял только из 13 пересылок, и среднее RTT
равнялось примерно 322 миллисекундам. Из этого
можно сделать вывод, что маршрут по умолчанию
предпочтительнее. (Существуют и другие
ограничения, в соответствии с которыми
принимаются решения о прокладке маршрута; в том
числе организационные или политические.) </small></p>

<p><small>Мы сказали &quot;создается впечатление, что
было сделано 16 пересылок&quot;, так как имели
возможность сравнить этот вывод с нашим
предыдущим примером через <a NAME="t085016"></a>NFSNET (см.
рисунок 8.5), который показал 3 отсутствующих
маршрута в примере, который использует свободную
маршрутизацию от источника. (Это, возможно, было
вызвано ошибками в работе маршрутизаторов при
генерации <a NAME="t085017"></a>ICMP сообщения об истечении
времени при получении датаграмм,
маршрутизируемых от источника.) Маршрутизатор
gateway.tuc.noao.edu отсутствует между netb и butch, а
маршрутизаторы Westgate.Telcom.Arizona.edu и uu-ua.AZ.westnet.net
отсутствуют между Gabby и enss142.UT.westnet.net. Вполне
возможно, что мы не видим эти маршрутизаторы так
как они не могут корректно обработать входящие
датаграммы со свободной маршрутизации от
источника. В действительности, при использовании
NSFNET осуществляется 19 пересылок между источником
и NIC. В <a HREF="#t086001">упражнении 5</a> главы 8 будет
продолжено рассмотрение отсутствующих
маршрутизаторов. </small></p>

<p><small>Из этого примера видна еще одна проблема. В
командной строке мы должны указать IP адрес
маршрутизатора enss142.UT.westnet.net вместо его имени. Это
происходит потому, что процедура определяющая
соответствие между именем и адресом
(возвращается имя по заданному IP адресу, раздел <a HREF="tcp14.html#t145000">&quot;Запросы указателя&quot;</a>, главы
14), или наоборот, когда задается имя, а
возвращается IP адрес, не работает. Функции
определения адреса по имени и имени по адресу
используют два различных файла в системе DNS (Domain
Name System), и не все администраторы синхронизируют
эти два файла друг с другом. Нет ничего
необычного в том, что в одном направлении DNS
работает, но не работает в другом. </small></p>

<p><small>Вместо первого RTT для TTL равного 8 мы видим в
выводе звездочку (*). Это указывает на то, что был
отработан тайм-аут и на первую посылку в течении
пяти секунд не был получен отклик. </small></p>

<p><small>И последнее, на что необходимо обратить
внимание, сравнивая этот рисунок с рисунком&nbsp;8.4,
заключается в том, что маршрутизатор nsn-FIX-pe.sura.net
подключен как к NSFNET, так и к сети NASA. </small></p>
<i><b>

<p>Примеры traceroute при использовании жесткой
маршрутизации от источника</p>
</b></i>

<p><small>Опция <a NAME="t085018"></a>-G в нашей версии traceroute
идентична опции <a NAME="t085019"></a>-g, описанной ранее,
однако она определяет жесткую маршрутизацию от
источника вместо свободной. Посмотрим что
произойдет, если указан неверный жесткий маршрут
от источника. Обратимся к рисунку 8.5, на котором
показана нормальная последовательность
маршрутизаторов для датаграмм, двигающихся из
нашей подсети к <a NAME="t085020"></a>NSFNET через netb, gateway, butch
и gabby. (Мы отбросили суффиксы доменов, .tuc.noao.edu и
.telcom.arizona.edu, во всех строках вывода, показанных
ниже, чтобы сделать их более читаемыми.) Мы
указали жесткий маршрут от источника, который не
использует butch, а пытается пройти
непосредственно от gateway к gabby. Это не должно
сработать, что показано на рисунке 8.9.<a NAME="t085021"></a></small></p>

<p>&nbsp;</p>


<p>sun % <b>traceroute -G netb -G gateway -G gabby westgate</b><br>
traceroute to westgate (192.80.43.2), 30 hops max, 40 byte packets<br>
1 netb (140.252.1.183)&nbsp; 272 ms&nbsp; 257 ms&nbsp; 261 ms<br>
2 gateway (140.252.1.4)&nbsp; 263 ms&nbsp; 259 ms&nbsp; 234 ms<br>
3 gateway (140.252.1.4)&nbsp; 263 ms !S *&nbsp; 235 ms !S<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 8.9 traceroute с жесткой маршрутизацией
от источника, который не работает.</small></p>

<p>&nbsp;</p>

<p><small>Здесь необходимо обратить внимание на
выражение !S, следующее за RTT для TTL равного 3. Это
означает, что программа traceroute получила ICMP
сообщение &quot;маршрутизация от источника не
сработала&quot; (source route failed): type равняется 3 и code
равняется 5 на рисунке 6.3. Звездочка во втором RTT
для TTL равного 3 указывает на то, что на эту
посылку не был получен ответ. Это как раз то что
мы ожидали, так как для gateway не существует
возможности послать датаграмму непосредственно
к gabby. </small></p>

<p><small>Причина того, что датаграммы с TTL 2 и 3 пришли
именно от gateway, заключается в том, что TTL с номером
2 отправлялась из gateway, когда он получил входящую
датаграмму с TTL равным 1. Он определяет, что время
жизни (TTL) истекло перед тем, как был обнаружен
жесткий маршрут от источника (кстати,
неправильный), поэтому и было отправлено ICMP
сообщение об истечении времени. Строка с TTL
равным 3 получена gateway с входящим TTL равным 2, он
просмотрел жесткий маршрут от источника,
определил, что он неверен, после чего послал ICMP
сообщение о том, что маршрутизация от источника
не может быть осуществлена. </small></p>

<p><small>На рисунке 8.10 показан вывод <a NAME="t085022"></a>tcpdump,
соответствующий этому примеру. Этот вывод
получен на SLIP канале между sun и netb. Мы указали
опцию <a NAME="t085023"></a>-v для tcpdump, чтобы получить
информацию о маршрутизации от источника. При
этом появляется часть вывода, который нам не
нужен, как, например, идентификатор датаграммы.
Этот вывод был удален. Сокращение <a NAME="t085024"></a>SSRR
означает &quot;жесткая маршрутизация от источника
с записью&quot; (strict source and record route).<a NAME="t085025"></a></small></p>

<p>&nbsp;</p>


<p> 1 0.0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.33593
&gt; netb.33435: udp 12 [ttl 1] <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (optlen=16
SSRR{#gateway gabby westgate} EOL)<br>
2 0.270278 (0.2703)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; netb &gt; sun: icmp: time exceeded
in-transit<br>
3 0.284784 (0.0145)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.33593 &gt; netb.33436: udp 12 [ttl
1] <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (optlen=16
SSRR{#gateway gabby westgate} EOL)<br>
4 0.540338 (0.2556)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; netb &gt; sun: icmp: time exceeded
in-transit<br>
5 0.550062 (0.0097)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.33593 &gt; netb.33437: udp 12 [ttl
1] <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (optlen=16
SSRR{#gateway gabby westgate} EOL)<br>
6 0.810310 (0.2602)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; netb &gt; sun: icmp: time exceeded
in-transit<br>
7 0.818030 (0.0077)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.33593 &gt; netb.33438: udp 12 (ttl
2,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; optlen=16
SSRR{#gateway gabby westgate} EOL)<br>
8 1.080337 (0.2623)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gateway &gt; sun: icmp: time exceeded
in-transit<br>
9 1.092564 (0.0122)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.33593 &gt; netb.33439: udp 12 (ttl
2, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; optlen=16
SSRR{#gateway gabby westgate} EOL)<br>
10 1.350322 (0.2578)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gateway &gt; sun: icmp: time exceeded
in-transit<br>
11 1.357382 (0.0071)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.33593 &gt; netb.33440: udp 12 (ttl
2, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; optlen=16
SSRR{#gateway gabby westgate} EOL)<br>
12 1.590586 (0.2332)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gateway &gt; sun: icmp: time exceeded
in-transit<br>
13 1.598926 (0.0083)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.33593 &gt; netb.33441: udp 12 (ttl
3, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; optlen=16
SSRR{#gateway gabby westgate} EOL)<br>
14 1.860341 (0.2614)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gateway &gt; sun: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icmp:
gateway unreachable - source route failed<br>
15 1.875230 (0.0149)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.33593 &gt; netb.33442: udp 12 (ttl
3, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; optlen=16
SSRR{#gateway gabby westgate} EOL)<br>
16 6.876579 (5.0013)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.33593 &gt; netb.33443: udp 12 (ttl
3, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; optlen=16
SSRR{#gateway gabby westgate} EOL)<br>
17 7.110518 (0.2339)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gateway &gt; sun: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icmp:
gateway unreachable - source route failed<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 8.10 Вывод tcpdump для traceroute с
неработающей жесткой маршрутизацией от
источника.</small></p>

<p>&nbsp;</p>

<p><small>Обратите внимание на то, что каждая UDP
датаграмма, посланная sun, имеет в качестве
назначения netb, а не хост назначения (westgate). Мы
описали это с помощью примера, показанного на
рисунке 8.7. Два других маршрутизатора указаны с
опцией -G (gateway и gabby), а <a NAME="t085026"></a>конечный пункт
назначения (westgate) появляется в списке опций SSRR
для первой пересылки. </small></p>

<p><small>Также из этого вывода можно заметить, что
тайм-аут, используемый traceroute (время между
строками 15 и 16), составляет 5 секунд. </small></p>
<i><b>

<p>Время возврата traceroute при использовании
свободной маршрутизации от источника</p>
</b></i>

<p><small>Раньше мы уже упоминали о том, что не
существует гарантии того, что маршрут от А до В
тот же самый, как и маршрут от В до А. Найти
различие между этими двумя маршрутами можно
только зайдя терминалами на обе системы и
запустив traceroute на каждой из них. Однако,
используя свободную маршрутизацию от источника,
мы можем определить маршрут в обоих
направлениях. </small></p>

<p><small>Добиться этого можно, если указать
свободную маршрутизацию от источника с
назначением по свободному маршруту и указать
посылающий хост в качестве конечного пункта
назначения. Например, с хоста sun мы можем найти
маршрут к и от хоста bruno.cs.colorado.edu (см. рисунок 8.11).<a NAME="t085027"></a></small></p>

<p>&nbsp;</p>


<p>sun % <b>traceroute -g bruno.cs.colorado.edu sun<br>
</b>traceroute to sun (140.252.13.33), 30 hops max, 40 byte packets<br>
1 netb.tuc.noao.edu (140.252.1.183)&nbsp; 230 ms&nbsp; 227 ms&nbsp; 233 ms<br>
2 gateway.tuc.noao.edu (140.252.1.4)&nbsp; 233 ms&nbsp; 229 ms&nbsp; 234 ms<br>
<br>
3 butch.telcom.arizona.edu (140.252.104.2)&nbsp; 234 ms&nbsp; 229 ms&nbsp; 234 ms<br>
4 Gabby.Telcom.Arizona.EDU (128.196.128.1)&nbsp; 233 ms&nbsp; 231 ms&nbsp; 234 ms<br>
5 NSIgate.Telcom.Arizona.EDU (192.80.43.3)&nbsp; 294 ms&nbsp; 258 ms&nbsp; 234 ms<br>
<br>
6 JPL1.NSN.NASA.GOV (128.161.88.2)&nbsp; 264 ms&nbsp; 258 ms&nbsp; 264 ms<br>
7 JPL2.NSN.NASA.GOV (192.100.15.2)&nbsp; 264 ms&nbsp; 258 ms&nbsp; 264 ms<br>
8 NCAR.NSN.NASA.GOV (128.161.97.2)&nbsp; 324 ms *&nbsp; 295 ms<br>
<br>
9 cu-gw.ucar.edu (192.43.244.4)&nbsp; 294 ms&nbsp; 318 ms&nbsp; 294 ms<br>
<br>
10 engr-gw.Colorado.EDU (128.138.1.3)&nbsp; 294 ms&nbsp; 288 ms&nbsp; 294 ms<br>
11 bruno.cs.colorado.edu (128.138.243.151)&nbsp; 293 ms&nbsp; 317 ms&nbsp; 294 ms<br>
12 engr-gw-ot.cs.colorado.edu (128.138.204.1)&nbsp; 323 ms&nbsp; 317 ms&nbsp; 384 ms<br>
13 cu-gw.Colorado.EDU (128.138.1.1)&nbsp; 294 ms&nbsp; 318 ms&nbsp; 294 ms<br>
<br>
14 enss.ucar.edu (192.43.244.10)&nbsp; 323 ms&nbsp; 318 ms&nbsp; 294 ms<br>
<br>
15 t3-1.Denver-cnss97.t3.ans.net (140.222.97.2)&nbsp; 294 ms&nbsp; 288 ms&nbsp; 384 ms<br>
16 t3-0.enss142.t3.ans.net (140.222.142.1)&nbsp; 293 ms&nbsp; 288 ms&nbsp; 294 ms<br>
<br>
17 Gabby.Telcom.Arizona.EDU (192.80.43.1)&nbsp; 294 ms&nbsp; 288 ms&nbsp; 294 ms<br>
18 Butch.Telcom.Arizona.EDU (128.196.128.88)&nbsp; 293 ms&nbsp; 317 ms&nbsp; 294 ms<br>
<br>
19 gateway.tuc.noao.edu (140.252.104.1)&nbsp; 294 ms&nbsp; 289 ms&nbsp; 294 ms<br>
20 netb.tuc.noao.edu (140.252.1.183)&nbsp; 324 ms&nbsp; 321 ms&nbsp; 294 ms<br>
21 sun.tuc.noao.edu (140.252.13.33)&nbsp; 534 ms&nbsp; 529 ms&nbsp; 564 ms<br>
</p>


<p>&nbsp;</p>

<p><small>Рисунок 8.11 Пример traceroute, показывающий
несимметричные маршруты.</small></p>

<p>&nbsp;</p>

<p><small>Исходящий маршрут (TTL 1-11) отличается от
обратного маршрута (TTL 11-21), это является хорошей
иллюстрацией того, что маршрутизация в Internet
может быть несимметричной. </small></p>

<p><small>Этот вывод также иллюстрирует проблему,
которую мы обнаружили при рассмотрении рисунка
8.3. Сравните вывод для TTL 2 и 19: оба относятся к
маршрутизатору gateway.tuc.noao.edu, однако IP адреса
различны. Так как traceroute идентифицирует входящий
интерфейс, это означает, что мы прошли через
маршрутизатор с разных сторон, в тот момент,
когда использовали исходящий маршрут (TTL 2) и
когда использовали обратный маршрут (TTL 19). Точно
так же можно сравнить TTL 3 и 18, TTL 4 и 17.</small></p>
<u><b>

<p><a NAME="t086000"></a>Краткие выводы</p>
</b></u>

<p><small>Traceroute это незаменимое средство при работе с
сетями TCP/IP. Оно функционирует довольно просто:
отправляет UDP датаграммы, начинающиеся с TTL 1,
увеличивает TTL на единицу, для того чтобы
определить пересылку через каждый встретившийся
маршрутизатор. Каждый маршрутизатор, который
отбрасывает UDP датаграмму, возвращает сообщение
ICMP об истечении времени (ICMP time exceeded), а пункт
конечного назначения генерирует ICMP сообщение о
недоступности порта (ICMP port unreachable). </small></p>

<p><small>Мы запускали traceroute и в локальных и в
глобальных сетях, а также использовали эту
программу, для того чтобы проверить IP
маршрутизацию от источника. Мы использовали
свободную маршрутизацию от источника, чтобы
проверить, будет ли одинаковым маршрут к
конечной точке назначения и маршрут от конечной
точки назначения.</small></p>
<i><b>

<p><a NAME="t086001"></a>Упражнения</b></i> 

<ol>
  <li>Что произойдет, если IP модуль
    уменьшит входящий TTL на единицу, а затем проверит
    на равенство нулю?</li>
  <li>Как traceroute рассчитывает RTT? Сравните это с
    расчетом RTT, который осуществляет ping.</li>
  <li>(Это и следующее упражнения основано на
    реальных проблемах, которые возникли при
    разработке traceroute и взяты из комментариев к
    исходным текстам traceroute.) Представьте, что между
    источником и пунктом назначения находится 3
    маршрутизатора (R1, R2 и R3), средний маршрутизатор
    (R2) уменьшил на единицу TTL, однако некорректно
    перенаправил IP датаграмму, когда входящий TTL был
    равен единице. Опишите, что произойдет. Что Вы
    увидите, если запустите traceroute?</li>
  <li>Представьте еще раз, что между источником и
    конечным пунктом назначения находится 3
    маршрутизатора. При этом хост, который является
    пунктом назначения, работает с ошибкой. Он
    использует входящий TTL в качестве исходящего TTL
    для ICMP сообщения. Опишите, что произойдет, и как
    Вы это можете увидеть.</li>
  <li>Мы могли бы запустить tcpdump на SLIP канале между sun и
    netb, когда запускали пример с рисунка 8.8. Если мы
    укажем опцию <a NAME="t086010"></a>-v, то можем увидеть
    значение TTL для возвращающихся ICMP сообщений. При
    этом, мы увидим, что входящий TTL от netb равен 255, от
    butch равен 253, от Gabby равен 252 и от enss142.UT.westnet.net равен
    249. Дает ли это какую-либо дополнительную
    информацию о том, где существуют отсутствующие
    маршрутизаторы?</li>
  <li><a NAME="t086002"></a>SunOS и <a NAME="t086003"></a>SVR4 предоставляют
    версию программы <a NAME="t086004"></a>ping с опцией <a NAME="t086005"></a>-l, что позволяет использовать
    свободную маршрутизацию от источника. В
    страницах помощи говорится, что это идентично
    использованию опции <a NAME="t086006"></a>-R (которая
    указывает на то, что необходима <a NAME="t086007"></a>запись
    маршрута). Если Вы имеете доступ к обеим этим
    системам, попробуйте использовать эти две опции
    вместе. Что произойдет? Если Вы можете
    просмотреть датаграммы с использованием tcpdump,
    опишите что будет происходить.</li>
  <li>Сравните пути прохождения ping и traceroute с разных
    рабочих станций на один и тот же хост.</li>
  <li>Сравните время возврата для ping и traceroute.</li>
  <li>Мы указали traceroute о необходимости использовать
    исходный номер порта назначения UDP, равный 33435, и
    увеличивать его на единицу для каждого
    следующего отправляемого пакета. В разделе <a HREF="tcp01.html#t019000">&quot;Номера портов&quot;</a> главы 1
    говорится, что обычно номера динамически
    назначаемых портов находятся в диапазоне от 1024
    до 5000, при этом порт назначения Traceroute никогда не
    будет занят на хосте, который является пунктом
    назначения. Является ли это справедливым для <a NAME="t086008"></a>Solaris 2.2? (Подсказка: прочитайте раздел <a HREF="tcp_e.html#t354000">&quot;Solaris 2.2&quot;</a> приложения E.)</li>
  <li>Прочитайте RFC 1393 [<a NAME="t086009"></a>Malkin 1993b], и найдите
    альтернативные способы определения маршрута к
    пункту назначения. В чем их преимущества и
    недостатки?</li>
</ol>

<hr>

</body>
</html>
